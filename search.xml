<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式缓存</title>
      <link href="2021/08/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
      <url>2021/08/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="在项目中缓存是如何使用的？缓存如果使用不当会造成什么后果？"><a href="#在项目中缓存是如何使用的？缓存如果使用不当会造成什么后果？" class="headerlink" title="在项目中缓存是如何使用的？缓存如果使用不当会造成什么后果？"></a>在项目中缓存是如何使用的？缓存如果使用不当会造成什么后果？</h3><h4 id="项目中缓存是如何使用的？"><a href="#项目中缓存是如何使用的？" class="headerlink" title="项目中缓存是如何使用的？"></a>项目中缓存是如何使用的？</h4><p>这个，需要结合自己项目的业务来。</p><h4 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h4><p>用缓存，主要有两个用途：<strong>高性能</strong>、<strong>高并发</strong>。</p><h4 id="用了缓存之后会有什么不良后果？"><a href="#用了缓存之后会有什么不良后果？" class="headerlink" title="用了缓存之后会有什么不良后果？"></a>用了缓存之后会有什么不良后果？</h4><p>常见的缓存问题有以下几个：</p><ul><li>缓存与数据库双写不一致 </li><li>缓存雪崩、缓存穿透</li><li>缓存并发竞争</li></ul><h4 id="缓存数据的处理流程是怎样的？"><a href="#缓存数据的处理流程是怎样的？" class="headerlink" title="缓存数据的处理流程是怎样的？"></a>缓存数据的处理流程是怎样的？</h4><p>简单来说就是:</p><ol><li>如果用户请求的数据在缓存中就直接返回；</li><li>缓存中不存在的话就看数据库中是否存在；</li><li>数据库中存在的话就更新缓存中的数据；</li><li>数据库中不存在的话就返回空数据。</li></ol><h3 id="Redis-和-Memcached-有什么区别？Redis-的线程模型是什么？为什么单线程的-Redis-比多线程的-Memcached-效率要高得多？"><a href="#Redis-和-Memcached-有什么区别？Redis-的线程模型是什么？为什么单线程的-Redis-比多线程的-Memcached-效率要高得多？" class="headerlink" title="Redis 和 Memcached 有什么区别？Redis 的线程模型是什么？为什么单线程的 Redis 比多线程的 Memcached 效率要高得多？"></a>Redis 和 Memcached 有什么区别？Redis 的线程模型是什么？为什么单线程的 Redis 比多线程的 Memcached 效率要高得多？</h3><h4 id="redis-和-memcached-有啥区别？"><a href="#redis-和-memcached-有啥区别？" class="headerlink" title="redis 和 memcached 有啥区别？"></a>redis 和 memcached 有啥区别？</h4><p><strong>共同点</strong> ：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong> ：</p><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><h4 id="redis-的线程模型"><a href="#redis-的线程模型" class="headerlink" title="redis 的线程模型"></a>redis 的线程模型</h4><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。</p><p>来看客户端与 redis 的一次通信过程：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210806161320423.png" alt="image-20210806161320423"></p><ul><li><p>首先，redis 服务端进程初始化的时候，会将 server socket 的 <code>AE_READABLE</code> 事件与连接应答处理器关联。</p></li><li><p>客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</p></li><li><p>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 <code>AE_READABLE</code> 事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器关联。</p></li><li><p>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</p></li><li><p>这样便完成了一次通信。关于 Redis 的一次通信过程。</p></li></ul><h4 id="为啥-redis-单线程模型也能效率这么高？"><a href="#为啥-redis-单线程模型也能效率这么高？" class="headerlink" title="为啥 redis 单线程模型也能效率这么高？"></a>为啥 redis 单线程模型也能效率这么高？</h4><ul><li>纯内存操作；</li><li>核心是基于非阻塞的 IO 多路复用机制；</li><li>C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快；</li><li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li></ul><h3 id="Redis-没有使用多线程？为什么不使用多线程？Redis6-0-之后为何引入了多线程？"><a href="#Redis-没有使用多线程？为什么不使用多线程？Redis6-0-之后为何引入了多线程？" class="headerlink" title="Redis 没有使用多线程？为什么不使用多线程？Redis6.0 之后为何引入了多线程？"></a>Redis 没有使用多线程？为什么不使用多线程？Redis6.0 之后为何引入了多线程？</h3><p>虽然说 Redis 是单线程模型，但是， 实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</p><p>大体上来说，<strong>Redis 6.0 之前主要还是单线程处理。</strong></p><h4 id="Redis6-0-之前为什么不使用多线程？"><a href="#Redis6-0-之前为什么不使用多线程？" class="headerlink" title="Redis6.0 之前为什么不使用多线程？"></a><strong>Redis6.0 之前为什么不使用多线程？</strong></h4><p>我觉得主要原因有下面 3 个：</p><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><h4 id="Redis6-0-之后为何引入了多线程？"><a href="#Redis6-0-之后为何引入了多线程？" class="headerlink" title="Redis6.0 之后为何引入了多线程？"></a>Redis6.0 之后为何引入了多线程？</h4><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">io-threads-do-reads</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure><p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code>redis.conf</code> :</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">io-threads</span> <span class="string">4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure><h3 id="Redis-都有哪些数据类型？分别在哪些场景下使用比较合适？"><a href="#Redis-都有哪些数据类型？分别在哪些场景下使用比较合适？" class="headerlink" title="Redis 都有哪些数据类型？分别在哪些场景下使用比较合适？"></a>Redis 都有哪些数据类型？分别在哪些场景下使用比较合适？</h3><p>redis 主要有以下几种数据类型：</p><ul><li><strong>string</strong>：普通的 set 和 get，做简单的 KV 缓存，一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li><li><strong>hash</strong>：类似 map 的一种结构，这个一般就是可以将结构化的数据（系统中对象数据的存储），比如一个对象（前提是<strong>这个对象没嵌套其他的对象</strong>）给缓存在 redis 里，然后每次读写缓存的时候，可以就操作 hash 里的<strong>某个字段</strong>。</li><li><strong>list</strong>：有序列表，可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西，</li><li><strong>set</strong>：set 是无序集合，自动去重。可以基于 set 玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？对吧。</li><li><strong>sorted set</strong>：是排序的 set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。场景：需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li></ul><h3 id="Redis是如何判断数据是否过期的呢？Redis-的过期策略都有哪些？手写一下-LRU-代码实现？"><a href="#Redis是如何判断数据是否过期的呢？Redis-的过期策略都有哪些？手写一下-LRU-代码实现？" class="headerlink" title="Redis是如何判断数据是否过期的呢？Redis 的过期策略都有哪些？手写一下 LRU 代码实现？"></a>Redis是如何判断数据是否过期的呢？Redis 的过期策略都有哪些？手写一下 LRU 代码实现？</h3><h4 id="数据过期判断"><a href="#数据过期判断" class="headerlink" title="数据过期判断"></a>数据过期判断</h4><p>Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p><h4 id="redis-过期策略"><a href="#redis-过期策略" class="headerlink" title="redis 过期策略"></a>redis 过期策略</h4><p>redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p><p>所谓<strong>定期删除</strong>，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的<strong>灾难</strong>。实际上 redis 是每隔 100ms <strong>随机抽取</strong>一些 key 来检查和删除的。</p><p>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p><blockquote><p>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p></blockquote><p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？</p><p>答案是：<strong>走内存淘汰机制</strong>。</p><h4 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h4><p>redis 内存淘汰机制有以下几个：</p><ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key（这个是<strong>最常用</strong>的）。</li><li>allkeys-random：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除最近最少使用的 key（这个一般不太合适）。</li><li>volatile-random：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机移除</strong>某个 key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除。</li></ul><h4 id="手写一个-LRU-算法"><a href="#手写一个-LRU-算法" class="headerlink" title="手写一个 LRU 算法"></a>手写一个 LRU 算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传递进来最多能缓存多少数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheSize 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span></span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis-事务？"><a href="#Redis-事务？" class="headerlink" title="Redis 事务？"></a>Redis 事务？</h3><p>Redis 可以通过 <strong>MULTI，EXEC，DISCARD 和 WATCH</strong> 等命令来实现事务(transaction)功能。使用 MULTI命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了EXEC]命令将执行所有命令。</p><p><strong>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</strong></p><p>Redis官网也解释了自己为啥不支持回滚。简单来说就是Redis开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p><h3 id="如何保证-Redis-高并发、高可用？Redis-的主从复制原理能介绍一下么？Redis-的哨兵原理能介绍一下么？"><a href="#如何保证-Redis-高并发、高可用？Redis-的主从复制原理能介绍一下么？Redis-的哨兵原理能介绍一下么？" class="headerlink" title="如何保证 Redis 高并发、高可用？Redis 的主从复制原理能介绍一下么？Redis 的哨兵原理能介绍一下么？"></a>如何保证 Redis 高并发、高可用？Redis 的主从复制原理能介绍一下么？Redis 的哨兵原理能介绍一下么？</h3><p>见网站博客。</p><h3 id="Redis-的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？"><a href="#Redis-的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？" class="headerlink" title="Redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？"></a>Redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？</h3><h4 id="redis-持久化的两种方式"><a href="#redis-持久化的两种方式" class="headerlink" title="redis 持久化的两种方式"></a>redis 持久化的两种方式</h4><ul><li>RDB：RDB 持久化机制，是对 redis 中的数据执行<strong>周期性</strong>的持久化。</li><li>AOF：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 redis 重启的时候，可以通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据集。</li></ul><p>如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。</p><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p><h4 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a>RDB 优缺点</h4><ul><li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，<strong>非常适合做冷备</strong>，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。</li><li>RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis <strong>保持高性能</strong>，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li><li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。</li><li>如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。</li><li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li></ul><h4 id="AOF-优缺点"><a href="#AOF-优缺点" class="headerlink" title="AOF 优缺点"></a>AOF 优缺点</h4><ul><li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次<code>fsync</code>操作，最多丢失 1 秒钟的数据。</li><li>AOF 日志文件以 <code>append-only</code> 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li><li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 <code>rewrite</code> log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li><li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常<strong>适合做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li><li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li><li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 <code>fsync</code> 一次日志文件，当然，每秒一次 <code>fsync</code>，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）</li><li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是<strong>基于当时内存中的数据进行指令的重新构建</strong>，这样健壮性会好很多。</li></ul><h4 id="RDB-和-AOF-到底该如何选择"><a href="#RDB-和-AOF-到底该如何选择" class="headerlink" title="RDB 和 AOF 到底该如何选择"></a>RDB 和 AOF 到底该如何选择</h4><ul><li>不要仅仅使用 RDB，因为那样会导致你丢失很多数据；</li><li>也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</li><li>redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li></ul><h3 id="Redis-集群模式的工作原理能说一下么？在集群模式下，Redis-的-key-是如何寻址的？分布式寻址都有哪些算法？了解一致性-hash-算法吗？如何动态增加和删除一个节点？"><a href="#Redis-集群模式的工作原理能说一下么？在集群模式下，Redis-的-key-是如何寻址的？分布式寻址都有哪些算法？了解一致性-hash-算法吗？如何动态增加和删除一个节点？" class="headerlink" title="Redis 集群模式的工作原理能说一下么？在集群模式下，Redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？如何动态增加和删除一个节点？"></a>Redis 集群模式的工作原理能说一下么？在集群模式下，Redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？如何动态增加和删除一个节点？</h3><h4 id="redis-cluster-介绍"><a href="#redis-cluster-介绍" class="headerlink" title="redis cluster 介绍"></a>redis cluster 介绍</h4><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><h4 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h4><p> <strong>基本通信原理</strong></p><p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p><p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）几种存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code>。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210806164328350.png" alt="image-20210806164328350"></p><p>redis 维护集群元数据采用另一个方式， <code>gossip</code> 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210806164415142.png" alt="image-20210806164415142"></p><p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p><p>gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p><ul><li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code>。</li><li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li></ul><p><strong>gossip 协议</strong></p><p>gossip 协议包含多种消息，包含 <code>ping</code>,<code>pong</code>,<code>meet</code>,<code>fail</code> 等等。</p><ul><li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb add-node</span><br></pre></td></tr></table></figure><p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。</p><ul><li>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。</li><li>pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新。</li><li>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。</li></ul><p><strong>ping 消息深入</strong></p><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p><p>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code>，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率。</p><p>每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数减 2</code> 个其它节点的信息。</p><h4 id="分布式寻址算法"><a href="#分布式寻址算法" class="headerlink" title="分布式寻址算法"></a>分布式寻址算法</h4><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>redis cluster 的 hash slot 算法</li></ul><p><strong>hash 算法</strong></p><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210806165256905.png" alt="image-20210806165256905" style="zoom: 50%;" /><p><strong>一致性 hash 算法</strong></p><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p><p>然而，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点，这样就实现了数据的均匀分布，负载均衡。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210806165425055.png" alt="image-20210806165425055" style="zoom: 33%;" /><p><strong>redis cluster 的 hash slot 算法</strong></p><p>redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p><p>redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210806171326766.png" alt="image-20210806171326766" style="zoom:50%;" /><h4 id="redis-cluster-的高可用与主备切换原理"><a href="#redis-cluster-的高可用与主备切换原理" class="headerlink" title="redis cluster 的高可用与主备切换原理"></a>redis cluster 的高可用与主备切换原理</h4><p>redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p><p><strong>判断节点宕机</strong></p><ul><li><p>如果一个节点认为另外一个节点宕机，那么就是 <code>pfail</code>，<strong>主观宕机</strong>。如果多个节点都认为另外一个节点宕机了，那么就是 <code>fail</code>，<strong>客观宕机</strong>，跟哨兵的原理几乎一样，sdown，odown。在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回 <code>pong</code>，那么就被认为 <code>pfail</code>。</p></li><li><p>如果一个节点认为某个节点 <code>pfail</code> 了，那么会在 <code>gossip ping</code> 消息中，<code>ping</code> 给其他节点，如果<strong>超过半数</strong>的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code>。</p></li></ul><p><strong>从节点过滤</strong></p><ul><li><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。</p></li><li><p>检查每个 slave node 与 master node 断开连接的时间，如果超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code>，那么就<strong>没有资格</strong>切换成 <code>master</code>。</p></li></ul><p><strong>从节点选举</strong></p><ul><li><p>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p></li><li><p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node<code>（N/2 + 1）</code>都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。</p></li><li><p>从节点执行主备切换，从节点切换为主节点。</p></li></ul><p><strong>与哨兵比较</strong></p><p>整个流程跟哨兵相比，非常类似，所以说，redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能。</p><h3 id="了解什么是-redis-的雪崩、穿透和击穿？Redis-崩溃之后会怎么样？系统该如何应对这种情况？如何处理-Redis-的穿透？"><a href="#了解什么是-redis-的雪崩、穿透和击穿？Redis-崩溃之后会怎么样？系统该如何应对这种情况？如何处理-Redis-的穿透？" class="headerlink" title="了解什么是 redis 的雪崩、穿透和击穿？Redis 崩溃之后会怎么样？系统该如何应对这种情况？如何处理 Redis 的穿透？"></a>了解什么是 redis 的雪崩、穿透和击穿？Redis 崩溃之后会怎么样？系统该如何应对这种情况？如何处理 Redis 的穿透？</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了，这就是缓存雪崩。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210806165932347.png" alt="image-20210806165932347" style="zoom:50%;" /><p>缓存雪崩的事前事中事后的解决方案如下：</p><ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210806171411879.png" alt="image-20210806171411879" style="zoom:50%;" /><p>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis，如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。</p><p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空白的值。</p><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。</p><p>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“<strong>视缓存于无物</strong>”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210806170116308.png" alt="image-20210806170116308" style="zoom:50%;" /><p><strong>有哪些解决办法？</strong></p><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p><strong>布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210807161444523.png" alt="image-20210807161444523"></p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><strong>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说</strong>！</p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><p><strong>解决方式</strong></p><ul><li>可以将热点数据设置为永远不过期；</li><li>或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</li></ul><h3 id="如何保证缓存与数据库的双写一致性？"><a href="#如何保证缓存与数据库的双写一致性？" class="headerlink" title="如何保证缓存与数据库的双写一致性？"></a>如何保证缓存与数据库的双写一致性？</h3><ul><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ul><h3 id="Redis-的并发竞争问题是什么？如何解决这个问题？了解-Redis-事务的-CAS-方案吗？"><a href="#Redis-的并发竞争问题是什么？如何解决这个问题？了解-Redis-事务的-CAS-方案吗？" class="headerlink" title="Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？"></a>Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？</h3><p><strong>多客户端同时并发写</strong>一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。 redis 自己就有天然解决这个问题的 CAS 类的乐观锁方案。</p>]]></content>
      
      
      <categories>
          
          <category> Distributed </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="2021/08/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>2021/08/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="分布式事务的概念"><a href="#分布式事务的概念" class="headerlink" title="分布式事务的概念"></a>分布式事务的概念</h3><p>分布式事务指的是一个请求<strong>在多个系统的调用链当中如何确保数据一致</strong>。</p><h3 id="分布式事务协议"><a href="#分布式事务协议" class="headerlink" title="分布式事务协议"></a>分布式事务协议</h3><p><strong>分布式事务协议：</strong></p><ul><li><strong>2PC</strong></li><li><strong>3PC</strong></li><li><strong>TCC</strong></li></ul><h3 id="2PC-两阶段提交协议"><a href="#2PC-两阶段提交协议" class="headerlink" title="2PC 两阶段提交协议"></a>2PC 两阶段提交协议</h3><p>2PC是非常经典的<strong>强一致、中心化的原子提交协议</strong>，协议中定义了两类节点：一个中心化协调者节点和多个参与者节点。2PC分为两个阶段：</p><ul><li><p><strong>准备阶段：</strong></p><ul><li> 协调者向所有参与者<strong>发送事务内容</strong>，询问是否可以提交事务，并等待所有参与者答复；</li><li>各参与者执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）；</li><li>如参与者执行成功，给协调者反馈YES，即可以提交；如执行失败，给协调者反馈NO，即不可提交。</li></ul></li><li><p><strong>提交阶段</strong>（所有参与者均反馈YES）：</p><ul><li>协调者向所有参与者发出正式提交事务的请求（即Commit请求）；</li><li>参与者执行Commit请求，并释放整个事务期间占用的资源；</li><li>各参与者向协调者反馈Ack完成的消息；</li><li>协调者收到所有参与者反馈的Ack消息后，即完成事务提交。</li></ul></li><li><p><strong>提交阶段</strong>（任何一个参与者反馈NO）：</p><ul><li>协调者向所有参与者发出回滚请求（即Rollback请求）；</li><li>参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源；</li><li>各参与者向协调者反馈Ack完成的消息；</li><li>协调者收到所有参与者反馈的Ack消息后，即完成事务中断。</li></ul></li></ul><p><strong>2PC两阶段提交过程中会遇到一些问题：</strong></p><ol><li><strong>性能问题</strong>：从流程上可以看出，其最大缺点就在于它的执行过程中间，<strong>节点都处于阻塞状态</strong>。各个操作数据库的节点此时都占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知进行全局提交，参与者进行本地事务提交后才会释放资源。</li><li><strong>协调者单点故障问题</strong>：事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，会导致参与者收不到提交或回滚的通知，从而导致参与者节点始终处于事务无法完成的中间状态。</li><li><strong>丢失消息导致的数据不一致问题</strong>：在第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就会导致节点间数据的不一致问题。</li></ol><h3 id="3PC三阶段提交协议"><a href="#3PC三阶段提交协议" class="headerlink" title="3PC三阶段提交协议"></a>3PC三阶段提交协议</h3><p>2PC的改进版本，其在两阶段提交的基础上增加了CanCommit阶段，并引入了超时机制。一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。</p><ul><li><p><strong>阶段1：CanCommit</strong></p><ul><li>协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者答复；</li><li>参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES并进入预备状态，否则反馈NO。</li></ul></li><li><p><strong>阶段2：PreCommit</strong> <strong>事务预提交</strong>：（所有参与者均反馈YES时）</p><ul><li>协调者向所有参与者发出PreCommit请求，进入准备阶段；</li><li>参与者收到PreCommit请求后，执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）；</li><li>各参与者向协调者反馈Ack响应或No响应，并等待最终指令。</li></ul></li><li><p><strong>阶段2：PreCommit</strong> ：<strong>中断事务</strong>（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）</p><ul><li>协调者向所有参与者发出abort请求；</li><li>无论收到协调者发出的abort请求，或在等待协调者请求过程中出现超时，参与者均会中断事务。</li></ul></li><li><p><strong>阶段3：do Commit</strong> <strong>提交事务</strong>：（所有参与者均反馈Ack响应时）</p><ul><li>如果协调者处于工作状态，则向所有参与者发出do Commit请求；</li><li>参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源；</li><li>各参与者向协调者反馈Ack完成的消息；</li><li>协调者收到所有参与者反馈的Ack消息后，即完成事务提交。</li></ul></li><li><p><strong>阶段3：do Commit</strong> <strong>中断事务</strong>：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）　　</p><ul><li> 如果协调者处于工作状态，向所有参与者发出abort请求；　　</li><li>参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源；　　</li><li>各参与者向协调者反馈Ack完成的消息；　　</li><li>协调者收到所有参与者反馈的Ack消息后，即完成事务中断。</li></ul></li></ul><h3 id="TCC-补偿事务协议"><a href="#TCC-补偿事务协议" class="headerlink" title="TCC 补偿事务协议"></a>TCC 补偿事务协议</h3><p>TCC 将事务提交分为 Try - Confirm - Cancel 3个操作：</p><ul><li>Try：预留业务资源/数据效验</li><li>Confirm：确认执行业务操作</li><li>Cancel：取消执行业务操作</li></ul><p>TCC事务处理流程和 2PC 二阶段提交类似，不过 2PC通常都是在跨库的DB层面，而<strong>TCC本质就是一个应用层面的2PC</strong>。</p><h3 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h3><p><strong>概念</strong></p><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p><ul><li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li>可用性（A）：保证每个请求不管成功或者失败都有响应。</li><li>分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。</li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210807155418846.png" alt="image-20210807155418846" style="zoom:50%;" /><p><strong>CAP特性的取舍</strong></p><ol><li>满足CA舍弃P，也就是满足一致性和可用性，舍弃容错性。但是这也就意味着你的系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同的机器上。</li><li>满足CP舍弃A，也就是满足一致性和容错性，舍弃可用性。如果你的系统允许有段时间的访问失效等问题，这个是可以满足的。就好比多个人并发买票，后台网络出现故障，你买的时候系统就崩溃了。</li><li>满足AP舍弃C，也就是满足可用性和容错性，舍弃一致性。这也就是意味着你的系统在并发访问的时候可能会出现数据不一致的情况。</li></ol><p>实时证明，大多数都是牺牲了一致性。像12306还有淘宝网，就好比是你买火车票，本来你看到的是还有一张票，其实在这个时刻已经被买走了，你填好了信息准备买的时候发现系统提示你没票了。这就是牺牲了一致性。</p><p>但是不是说牺牲一致性一定是最好的。就好比mysql中的事务机制，张三给李四转了100块钱，这时候必须保证张三的账户上少了100，李四的账户多了100。因此需要数据的一致性，而且什么时候转钱都可以，也需要可用性。但是可以转钱失败是可以允许的。</p>]]></content>
      
      
      <categories>
          
          <category> Distributed </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2PC </tag>
            
            <tag> 3PC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ面试题</title>
      <link href="2021/07/30/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/07/30/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="RabbitMQ是什么？"><a href="#RabbitMQ是什么？" class="headerlink" title="RabbitMQ是什么？"></a>RabbitMQ是什么？</h2><p>RabbitMQ是实现了高级消息队列协议（<code>AMQP</code>）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。</p><p>PS: 也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。</p><h2 id="RabbitMQ特点"><a href="#RabbitMQ特点" class="headerlink" title="RabbitMQ特点?"></a>RabbitMQ特点?</h2><ol><li><p><strong>可靠性</strong>: RabbitMQ使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</p></li><li><p><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</p></li><li><p><strong>扩展性</strong>: 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</p></li><li><p><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</p></li><li><p><strong>多种协议</strong>: RabbitMQ除了原生支持AMQP协议，还支持STOMP， MQTT等多种消息 中间件协议。</p></li><li><p><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</p></li><li><p><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</p></li><li><p><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</p></li></ol><h2 id="AMQP是什么"><a href="#AMQP是什么" class="headerlink" title="AMQP是什么?"></a>AMQP是什么?</h2><p>RabbitMQ就是 AMQP 协议的 <code>Erlang</code> 的实现(当然 RabbitMQ 还支持 <code>STOMP2</code>、 <code>MQTT3</code> 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</p><p>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</p><h2 id="AMQP协议3层？"><a href="#AMQP协议3层？" class="headerlink" title="AMQP协议3层？"></a>AMQP协议3层？</h2><ul><li><p><strong>Module Layer</strong>:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</p></li><li><p><strong>Session Layer</strong>:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</p></li><li><p><strong>TransportLayer</strong>:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</p></li></ul><h2 id="AMQP模型的几大组件？"><a href="#AMQP模型的几大组件？" class="headerlink" title="AMQP模型的几大组件？"></a>AMQP模型的几大组件？</h2><ul><li>交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。</li><li>队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。</li><li>绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。</li></ul><h2 id="说说生产者Producer和消费者Consumer"><a href="#说说生产者Producer和消费者Consumer" class="headerlink" title="说说生产者Producer和消费者Consumer?"></a>说说生产者Producer和消费者Consumer?</h2><p>生产者</p><ul><li>消息生产者，就是投递消息的一方。</li><li>消息一般包含两个部分：消息体（<code>payload</code>)和标签(<code>Label</code>)。</li></ul><p>消费者</p><ul><li>消费消息，也就是接收消息的一方。</li><li>消费者连接到RabbitMQ服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</li></ul><h2 id="为什么需要消息队列？"><a href="#为什么需要消息队列？" class="headerlink" title="为什么需要消息队列？"></a>为什么需要消息队列？</h2><p>从本质上来说是因为互联网的快速发展，业务不断扩张，促使技术架构需要不断的演进。</p><p>从以前的单体架构到现在的微服务架构，成百上千的服务之间相互调用和依赖。从互联网初期一个服务器上有 100 个在线用户已经很了不得，到现在坐拥10亿日活的微信。此时，我们需要有一个「工具」来解耦服务之间的关系、控制资源合理合时的使用以及缓冲流量洪峰等等。因此，消息队列就应运而生了。</p><p>它常用来实现：<code>异步处理</code>、<code>服务解耦</code>、<code>流量控制（削峰）</code>。</p><h2 id="说说Broker服务节点、Queue队列、Exchange交换器？"><a href="#说说Broker服务节点、Queue队列、Exchange交换器？" class="headerlink" title="说说Broker服务节点、Queue队列、Exchange交换器？"></a>说说Broker服务节点、Queue队列、Exchange交换器？</h2><ul><li>Broker可以看做RabbitMQ的服务节点。一般请下一个Broker可以看做一个RabbitMQ服务器。</li><li>Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</li><li>Exchange:生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li></ul><h2 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h2><p>优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。缺点有以下几个：</p><ul><li>系统可用性降低 系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩 溃，你不就完了？</li><li>系统复杂度提高 硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？</li><li>怎么保证消息传递的顺序性？问题一大堆。</li><li>一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致 了。</li></ul><h2 id="如何保证消息的可靠性？"><a href="#如何保证消息的可靠性？" class="headerlink" title="如何保证消息的可靠性？"></a>如何保证消息的可靠性？</h2><p>消息到MQ的过程中搞丢，MQ自己搞丢，MQ到消费过程中搞丢。</p><p><code>生产者到RabbitMQ</code>：事务机制和Confirm机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</p><p><code>RabbitMQ自身</code>：持久化、集群、普通模式、镜像模式。</p><p><code>RabbitMQ到消费者</code>：basicAck机制、死信队列、消息补偿机制。</p><h2 id="什么是RoutingKey路由键？"><a href="#什么是RoutingKey路由键？" class="headerlink" title="什么是RoutingKey路由键？"></a>什么是RoutingKey路由键？</h2><p>生产者将消息发送给交换器的时候，会指定一个<code>RoutingKey</code>,用来指定这个消息的路由规则，这个<code>RoutingKey</code>需要与交换器类型和绑定键(<code>BindingKey</code>)联合使用才能最终生效。</p><h2 id="Binding绑定？"><a href="#Binding绑定？" class="headerlink" title="Binding绑定？"></a>Binding绑定？</h2><p>通过绑定将交换器和队列关联起来，一般会指定一个<code>BindingKey</code>,这样RabbitMq就知道如何正确路由消息到队列了。</p><h2 id="交换器4种类型？"><a href="#交换器4种类型？" class="headerlink" title="交换器4种类型？"></a>交换器4种类型？</h2><p>主要有以下4种。</p><ul><li>fanout:把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</li><li>direct:把消息路由到BindingKey和RoutingKey完全匹配的队列中。</li><li>topic:</li><li>匹配规则：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RoutingKey&#96; 为一个 点号&#39;.&#39;: 分隔的字符串。比如: &#96;java.xiaoka.show</span><br></pre></td></tr></table></figure><p><code>BindingKey</code>和<code>RoutingKey</code>一样也是点号“.“分隔的字符串。</p><p><code>BindingKey</code>可使用 * 和 # 用于做模糊匹配，*匹配一个单词，#匹配多个或者0个</p><p><code>headers</code>:不依赖路由键匹配规则路由消息。是根据发送消息内容中的<code>headers</code>属性进行匹配。性能差，基本用不到。</p><h2 id="生产者消息运转？"><a href="#生产者消息运转？" class="headerlink" title="生产者消息运转？"></a>生产者消息运转？</h2><ol><li><p><code>Producer</code>先连接到Broker,建立连接Connection,开启一个信道(Channel)。</p></li><li><p><code>Producer</code>声明一个交换器并设置好相关属性。</p></li><li><p><code>Producer</code>声明一个队列并设置好相关属性。</p></li><li><p><code>Producer</code>通过路由键将交换器和队列绑定起来。</p></li><li><p><code>Producer</code>发送消息到<code>Broker</code>,其中包含路由键、交换器等信息。</p></li><li><p>相应的交换器根据接收到的路由键查找匹配的队列。</p></li><li><p>如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。</p></li><li><p>关闭信道。</p></li><li><p>管理连接。</p></li></ol><h2 id="消费者接收消息过程？"><a href="#消费者接收消息过程？" class="headerlink" title="消费者接收消息过程？"></a>消费者接收消息过程？</h2><ol><li><p><code>Producer</code>先连接到<code>Broker</code>,建立连接<code>Connection</code>,开启一个信道(<code>Channel</code>)。</p></li><li><p>向<code>Broker</code>请求消费响应的队列中消息，可能会设置响应的回调函数。</p></li><li><p>等待<code>Broker</code>回应并投递相应队列中的消息，接收消息。</p></li><li><p>消费者确认收到的消息,<code>ack</code>。</p></li><li><p><code>RabbitMq</code>从队列中删除已经确定的消息。</p></li><li><p>关闭信道。</p></li><li><p>关闭连接。</p></li></ol><h3 id="交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？"><a href="#交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？" class="headerlink" title="交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？"></a>交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？</h3><ul><li>mandatory ：true 返回消息给生产者。</li><li>mandatory: false 直接丢弃。</li></ul><h2 id="死信队列？"><a href="#死信队列？" class="headerlink" title="死信队列？"></a>死信队列？</h2><p>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</p><h2 id="导致的死信的几种原因？"><a href="#导致的死信的几种原因？" class="headerlink" title="导致的死信的几种原因？"></a>导致的死信的几种原因？</h2><ul><li>消息被拒（<code>Basic.Reject /Basic.Nack</code>) 且 <code>requeue = false</code>。</li><li>消息TTL过期。</li><li>队列满了，无法再添加。</li></ul><h2 id="延迟队列？"><a href="#延迟队列？" class="headerlink" title="延迟队列？"></a>延迟队列？</h2><p>存储对应的延迟消息，指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p><h2 id="优先级队列？"><a href="#优先级队列？" class="headerlink" title="优先级队列？"></a>优先级队列？</h2><ul><li>优先级高的队列会先被消费。</li><li>可以通过<code>x-max-priority</code>参数来实现。</li><li>当消费速度大于生产速度且Broker没有堆积的情况下，优先级显得没有意义。</li></ul><h2 id="事务机制？"><a href="#事务机制？" class="headerlink" title="事务机制？"></a>事务机制？</h2><p>RabbitMQ 客户端中与事务机制相关的方法有三个:</p><ol><li><p><code>channel.txSelect</code> 用于将当前的信道设置成事务模式。</p></li><li><p><code>channel . txCommit</code> 用于提交事务 。</p></li><li><p><code>channel . txRollback</code> 用于事务回滚,如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常,通过txRollback来回滚。</p></li></ol><h2 id="发送确认机制？"><a href="#发送确认机制？" class="headerlink" title="发送确认机制？"></a>发送确认机制？</h2><p>生产者把信道设置为<code>confirm</code>确认模式,设置后，所有再改信道发布的消息都会被指定一个唯一的ID，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（<code>Basic.Ack</code>)给生产者（包含消息的唯一ID)，这样生产者就知道消息到达对应的目的地了。</p><h2 id="消费者获取消息的方式？"><a href="#消费者获取消息的方式？" class="headerlink" title="消费者获取消息的方式？"></a>消费者获取消息的方式？</h2><ul><li>推</li><li>拉</li></ul><h2 id="消费者某些原因无法处理当前接受的消息如何来拒绝？"><a href="#消费者某些原因无法处理当前接受的消息如何来拒绝？" class="headerlink" title="消费者某些原因无法处理当前接受的消息如何来拒绝？"></a>消费者某些原因无法处理当前接受的消息如何来拒绝？</h2><p>channel .basicNack channel .basicReject</p><h2 id="消息传输保证层级？"><a href="#消息传输保证层级？" class="headerlink" title="消息传输保证层级？"></a>消息传输保证层级？</h2><ul><li><p><code>At most once</code>:最多一次。消息可能会丢失，但不会重复传输。</p></li><li><p><code>At least once</code>：最少一次。消息绝不会丢失，但可能会重复传输。</p></li><li><p><code>Exactly once</code>:  恰好一次，每条消息肯定仅传输一次。</p></li></ul><h2 id="了解Virtual-Host吗"><a href="#了解Virtual-Host吗" class="headerlink" title="了解Virtual Host吗?"></a>了解Virtual Host吗?</h2><p>每一个RabbitMQ服务器都能创建虚拟的消息服务器，也叫虚拟主机(virtual host)，简称vhost。默认为“/”。</p><h2 id="集群中的节点类型？"><a href="#集群中的节点类型？" class="headerlink" title="集群中的节点类型？"></a>集群中的节点类型？</h2><ul><li><p>内存节点：ram,将变更写入内存。</p></li><li><p>磁盘节点：disc,磁盘写入操作。</p></li><li><p>RabbitMQ要求最少有一个磁盘节点。</p></li></ul><h2 id="队列结构？"><a href="#队列结构？" class="headerlink" title="队列结构？"></a>队列结构？</h2><p>通常由以下两部分组成？</p><ol><li><p><code>rabbit_amqqueue_process</code>:负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认(包括生产端的 confirm 和消费端的 ack) 等。</p></li><li><p><code>backing_queue</code>:是消息存储的具体形式和引擎，并向 rabbit a<code>mqqueue process</code>提供相关的接口以供调用。</p></li></ol><h2 id="RabbitMQ中消息可能有的几种状态"><a href="#RabbitMQ中消息可能有的几种状态" class="headerlink" title="RabbitMQ中消息可能有的几种状态?"></a>RabbitMQ中消息可能有的几种状态?</h2><ul><li><p><code>alpha</code>: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中 。</p></li><li><p><code>beta</code>: 消息内容保存在磁盘中，消息索引保存在内存中。</p></li><li><p><code>gamma</code>: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。</p></li><li><p><code>delta</code>: 消息内容和索引都在磁盘中 。</p></li></ul><h2 id="在何种场景下使用了消息中间件？"><a href="#在何种场景下使用了消息中间件？" class="headerlink" title="在何种场景下使用了消息中间件？"></a>在何种场景下使用了消息中间件？</h2><ul><li>接口之间耦合比较严重</li><li>面对大流量并发时，容易被冲垮</li><li>存在性能问题</li></ul><h2 id="生产者如何将消息可靠投递到MQ？"><a href="#生产者如何将消息可靠投递到MQ？" class="headerlink" title="生产者如何将消息可靠投递到MQ？"></a>生产者如何将消息可靠投递到MQ？</h2><ol><li><p>Client发送消息给MQ；</p></li><li><p>MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息；</p></li><li><p>Client收到Ack消息后，认为消息已经投递成功。</p></li></ol><h2 id="MQ如何将消息可靠投递到消费者？"><a href="#MQ如何将消息可靠投递到消费者？" class="headerlink" title="MQ如何将消息可靠投递到消费者？"></a>MQ如何将消息可靠投递到消费者？</h2><ol><li><p>MQ将消息push给Client（或Client来pull消息）</p></li><li><p>Client得到消息并做完业务逻辑</p></li><li><p>Client发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Client会重复消息，这里就引出消费幂等的问题；</p></li><li><p>MQ将已消费的消息删除</p></li></ol><h2 id="如何保证RabbitMQ消息队列的高可用"><a href="#如何保证RabbitMQ消息队列的高可用" class="headerlink" title="如何保证RabbitMQ消息队列的高可用?"></a>如何保证RabbitMQ消息队列的高可用?</h2><p>RabbitMQ 有三种模式：<code>单机模式</code>，<code>普通集群模式</code>，<code>镜像集群模式</code>。</p><ol><li><p><strong>单机模式</strong>：就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</p></li><li><p><strong>普通集群模式</strong>：意思就是在多台机器上启动多个RabbitMQ实例，每个机器启动一个。</p></li><li><p><strong>镜像集群模式</strong>：这种模式，才是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据(元数据指RabbitMQ的配置数据)还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="2021/07/23/RabbitMQ/"/>
      <url>2021/07/23/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="MQ-的相关概念"><a href="#MQ-的相关概念" class="headerlink" title="MQ 的相关概念"></a>MQ 的相关概念</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p><h3 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h3><p><strong>流量消峰</strong></p><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><p><strong>应用解耦</strong></p><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000004.png" alt="RabbitMQ-00000004"></p><p><strong>异步处理</strong></p><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p><p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p><p>使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B服务也不用做这些操作，A 服务还能及时的得到异步处理成功的消息。</p><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000005.png" alt="RabbitMQ-00000005"></p><h3 id="MQ-的分类"><a href="#MQ-的分类" class="headerlink" title="MQ 的分类"></a>MQ 的分类</h3><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a><strong>ActiveMQ</strong></h4><p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，较低的概率丢失数据。</p><p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a><strong>Kafka</strong></h4><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件，以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p><p><strong>优点</strong>：性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级，可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</p><p><strong>缺点</strong>：Kafka 单机超过64个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong>。</p><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a><strong>RocketMQ</strong></h4><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p><p><strong>优点</strong>：<strong>单机吞吐量十万级</strong>，可用性非常高，分布式架构，<strong>消息可以做到 0 丢失</strong>，MQ 功能较为完善，还是分布式的，扩展性好，支<strong>持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降。</p><p><strong>缺点</strong>：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般，没有在MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。</p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><strong>RabbitMQ</strong></h4><p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，<strong>是当前最主流的消息中间件之一。</strong></p><p><strong>优点</strong>：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备，健壮、稳定、易用、跨平台、支持多种语言。如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高。 </p><p><strong>缺点</strong>：商业版需要收费，学习成本较高。</p><h3 id="MQ-的选择"><a href="#MQ-的选择" class="headerlink" title="MQ 的选择"></a>MQ 的选择</h3><p><strong>Kafka</strong></p><p>Kafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了。</p><p><strong>RocketMQ</strong></p><p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p><p><strong>RabbitMQ</strong></p><p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p><h2 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="RabbitMQ-的概念"><a href="#RabbitMQ-的概念" class="headerlink" title="RabbitMQ 的概念"></a>RabbitMQ 的概念</h3><p>RabbitMQ 是一个消息中间件，它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。</p><p>RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210625230930992.png" alt="image-20210625230930992"></p><h3 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h3><ul><li><p>生产者：产生数据发送消息的程序。</p></li><li><p>交换机：是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定。</p></li><li><p>队列：队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</p></li><li><p>消费者：大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p></li></ul><h3 id="各个名词介绍"><a href="#各个名词介绍" class="headerlink" title="各个名词介绍"></a>各个名词介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000007.png" alt="RabbitMQ-00000007"></p><ul><li><p>Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。</p></li><li><p>Virtual host：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</p></li><li><p>Connection：publisher／consumer 和 broker 之间的 TCP 连接。</p></li><li><p>Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。 </p></li><li><p>Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。</p></li><li><p>Queue：消息最终被送到这里等待 consumer 取走。</p></li><li><p>Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</p></li></ul><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><h3 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h3><p><strong>1、下载</strong></p><p>官网下载地址：<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p><p>这里选择的版本号（注意这两版本要求）</p><ul><li><p>rabbitmq-server-3.8.8-1.el7.noarch.rpm</p><p>GitHub：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8</a></p><p>加载下载：<a href="https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm">https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p></li><li><p>erlang-21.3.8.21-1.el7.x86_64.rpm</p><p>官网：<a href="https://www.erlang-solutions.com/downloads/">https://www.erlang-solutions.com/downloads/</a></p><p>加速：<a href="https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm">https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm</a></p></li></ul><p><strong>2、安装</strong></p><p>上传到 <code>/usr/local/software</code> 目录下(如果没有 software 需要自己创建)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong>3、启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server</span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><h3 id="Web管理界面及授权操作"><a href="#Web管理界面及授权操作" class="headerlink" title="Web管理界面及授权操作"></a>Web管理界面及授权操作</h3><p><strong>1、安装</strong></p><p>默认情况下，是没有安装web端的客户端插件，需要安装才可以生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><p>安装完毕以后，重启服务即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><p>访问 <a href="http://42.192.149.71:15672/">http://42.192.149.71:15672</a> ，用默认账号密码(guest)登录，出现权限问题。默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户</p><p><strong>2、添加用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建账号和密码</span></span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置用户角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为用户添加资源权限</span></span><br><span class="line"><span class="comment"># set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span></span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br><span class="line"><span class="comment"># 添加配置、写、读权限</span></span><br></pre></td></tr></table></figure><p>用户级别：</p><ol><li><strong>administrator</strong>：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理。</li><li><strong>monitoring</strong>：监控者 登录控制台，查看所有信息。</li><li><strong>policymaker</strong>：策略制定者 登录控制台，指定策略。</li><li><strong>managment</strong>：普通管理员 登录控制台。</li></ol><p>再次登录，用 admin 用户。</p><ol><li><p>关闭应用的命令为：rabbitmqctl stop_app</p></li><li><p>清除的命令为：rabbitmqctl reset</p></li><li><p>重新启动命令为：rabbitmqctl start_app</p></li></ol><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>在下图中，“ P” 是生产者，“ C” 是消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000012.png" alt="RabbitMQ-00000012"></p><p>连接的时候，需要开启 5672 端口。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210626162052259.png" alt="image-20210626162052259"></p><p><strong>依赖</strong></p><p>pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>消息生产者</strong></p><p>发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;42.192.149.71&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//channel 实现了自动 close 接口 自动关闭 不需要显示关闭</span></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化 也就是是否用完就删除</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * 1.发送到那个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的 key 是哪个</span></span><br><span class="line"><span class="comment">         * 3.其他的参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息消费者</strong></p><p>获取“生产者”发出的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;42.192.149.71&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.........&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费消息 - 接受消息</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消息被取消时的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p>Work Queues—工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。我们把任务封装为消息并将其发送到队列，在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p><h3 id="轮训分发消息"><a href="#轮训分发消息" class="headerlink" title="轮训分发消息"></a>轮训分发消息</h3><p>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。</p><p><strong>1、抽取工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到一个连接的 channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;42.192.149.71&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、启动两个工作线程来接受消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个工作线程，相当于之前的消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息接受</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String receivedMessage = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + receivedMessage);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息被取消</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;C1 消费者启动等待消费.................. &quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选中 <code>Allow multiple instances</code>：<br><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210627125840217.png" alt="image-20210627125840217"></p><p>启动后：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210627130146584.png" alt="image-20210627130146584"></p><p><strong>3、启动一个发送消息线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送完成：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果展示</strong></p><p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000016.png" alt="RabbitMQ-00000016"></p><h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。</p><p>RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息，以及后续发送给该消费者的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong> </p><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>，因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了。当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</strong></p><h3 id="手动消息应答的方法"><a href="#手动消息应答的方法" class="headerlink" title="手动消息应答的方法"></a>手动消息应答的方法</h3><ul><li><p>Channel.basicAck(用于肯定确认)：RabbitMQ 已知道该消息成功被处理，可以将其丢弃了。 </p></li><li><p>Channel.basicNack(用于否定确认) </p></li><li><p>Channel.basicReject(用于否定确认)：与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了。</p></li></ul><p><strong>Multiple 的解释：</strong></p><p>手动应答的好处是可以批量应答并且减少网络拥堵 。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000017.png" alt="RabbitMQ-00000017"></p><ul><li><p>true 代表批量应答 channel 上未应答的消息：比如说 channel 上有传送 tag 的消息 5、6、7、8， 当前 tag 是8 那么此时5-8的这些还未应答的消息都会被确认收到消息应答。</p></li><li><p>false 同上面相比只会应答 tag=8 的消息， 5、6、7 这三个消息依然不会被确认收到消息应答。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000018.png" alt="RabbitMQ-00000018"></p><h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000019.png" alt="RabbitMQ-00000019"></p><h3 id="消息手动应答代码"><a href="#消息手动应答代码" class="headerlink" title="消息手动应答代码"></a>消息手动应答代码</h3><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答。</p><p>消费者在上面代码的基础上增加了以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><strong>消息生产者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">            String message = sc.nextLine();</span><br><span class="line">            <span class="comment">//发布消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者 01：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者01</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较 短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + message);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">             * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者 02：</strong>把睡眠时间改成30秒。</p><p>正常情况下消息发送方发送两个消息，C1 和 C2 分别接收到消息并进行处理。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210714222013729.png" alt="image-20210714222013729"></p><p>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了，此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000022.png" alt="RabbitMQ-00000022"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000023.png" alt="RabbitMQ-00000023"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000024.png" alt="RabbitMQ-00000024"></p><h2 id="RabbitMQ-持久化"><a href="#RabbitMQ-持久化" class="headerlink" title="RabbitMQ 持久化"></a>RabbitMQ 持久化</h2><p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p><p> <strong>队列如何实现持久化</strong></p><p>之前创建的队列都是非持久化的，rabbitmq 如果重启的话，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让队列持久化</span></span><br><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//声明队列</span></span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000026.png" alt="RabbitMQ-00000026"></p><p>以下为控制台中持久化与非持久化队列的 UI 显示区、</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000027.png" alt="RabbitMQ-00000027"></p><p>消息实现持久化需要在消息<strong>生产者</strong>修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添加这个属性。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000028.png" alt="RabbitMQ-00000028"></p><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p><h2 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h2><p><strong>问题</strong></p><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个<strong>消费者 1</strong> 处理任务的速度非常快，而另外一个<strong>消费者 2</strong> 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，<strong>在消费者中消费之前</strong>，我们可以设置参数 <code>channel.basicQos(1);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不公平分发</span></span><br><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br><span class="line"><span class="comment">//采用手动应答</span></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000030.png" alt="RabbitMQ-00000030"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210714222609107.png" alt="image-20210714222609107"></p><p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p><h2 id="预取值分发"><a href="#预取值分发" class="headerlink" title="预取值分发"></a>预取值分发</h2><p><strong>带权的消息分发</strong></p><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息，另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。</p><p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p><p>通常，增加预取值将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>。应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000032.png" alt="RabbitMQ-00000032"></p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><h3 id="发布确认逻辑"><a href="#发布确认逻辑" class="headerlink" title="发布确认逻辑"></a>发布确认逻辑</h3><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于它是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><h3 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a>发布确认的策略</h3><p>开启发布确认的方法：发布确认默认是没有开启的，如果要开启，需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure><h4 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h4><p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个发送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">    <span class="comment">//队列声明</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h4><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">    <span class="comment">//队列声明</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">//批量确认消息大小</span></span><br><span class="line">    <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//未确认消息个数</span></span><br><span class="line">    <span class="keyword">int</span> outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        outstandingMessageCount++;</span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">            outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">    <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        channel.waitForConfirms();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h4><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 它是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000034.png" alt="RabbitMQ-00000034"></p><p>如何处理异步未确认消息?</p><p>最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p><p><strong>以上 3 种发布确认速度对比 :</strong></p><ul><li><p>单独发布消息：同步等待确认，简单，但吞吐量非常有限。</p></li><li><p>批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是哪条消息出现了问题。</p></li><li><p>异步处理：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些。</p></li></ul><h2 id="绑定-bindings"><a href="#绑定-bindings" class="headerlink" title="绑定 bindings"></a>绑定 bindings</h2><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和哪个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210715090437837.png" alt="image-20210715090437837" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210715090506348.png" alt="image-20210715090506348"></p><h2 id="Exchanges"><a href="#Exchanges" class="headerlink" title="Exchanges"></a>Exchanges</h2><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息，是应该把这些消息放到特定队列还是说把他们放到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000035.png" alt="RabbitMQ-00000035"></p><p><strong>Exchanges 的类型：</strong></p><ul><li>直接(direct)</li><li>主题(topic) </li><li>标题(headers) </li><li>扇出(fanout)</li></ul><h3 id="Fanout-exchange"><a href="#Fanout-exchange" class="headerlink" title="Fanout exchange"></a>Fanout exchange</h3><h4 id="Fanout-介绍"><a href="#Fanout-介绍" class="headerlink" title="Fanout 介绍"></a>Fanout 介绍</h4><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000039.png" alt="RabbitMQ-00000039"></p><h4 id="Fanout-实战"><a href="#Fanout-实战" class="headerlink" title="Fanout 实战"></a>Fanout 实战</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000040.png" alt="RabbitMQ-00000040"></p><p>Logs 和临时队列的绑定关系如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000041.png" alt="RabbitMQ-00000041"></p><p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘。</p><p>ReceiveLogs01 将接收到的消息打印在控制台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.five;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息打印在屏幕........... &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;控制台打印接收到的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReceiveLogs02 把消息写出到文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息写到文件........... &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\test\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">            FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据写入文件成功&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EmitLog 发送消息给两个消费者接收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 声明一个 exchange</span></span><br><span class="line"><span class="comment">         * 1.exchange 的名称</span></span><br><span class="line"><span class="comment">         * 2.exchange 的类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">            String message = sc.nextLine();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Direct-exchange"><a href="#Direct-exchange" class="headerlink" title="Direct exchange"></a>Direct exchange</h3><p>在本节我们将向其中添加一些特别的功能—让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p><h4 id="Direct-介绍"><a href="#Direct-介绍" class="headerlink" title="Direct 介绍"></a>Direct 介绍</h4><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性，它只能进行无意识的广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，<strong>消息只去到它绑定的 routingKey 队列中去</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000042.png" alt="RabbitMQ-00000042"></p><p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个：一个绑定键为 black，另一个绑定键为 green。</p><p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p><h4 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000043.png" alt="RabbitMQ-00000043"></p><p>当然如果 exchange 的绑定类型是direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示。</p><h4 id="Direct-实战"><a href="#Direct-实战" class="headerlink" title="Direct 实战"></a>Direct 实战</h4><p>关系：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000044.png" alt="RabbitMQ-00000044"></p><p>交换机：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000045.png" alt="RabbitMQ-00000045"></p><ul><li><p>c2：绑定disk，routingKey为error。</p></li><li><p>c1：绑定console，routingKey为info、warning。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.six;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        String queueName = <span class="string">&quot;disk&quot;</span>;</span><br><span class="line">        <span class="comment">//队列声明</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//队列绑定</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            message = <span class="string">&quot;接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;,消息:&quot;</span> + message;</span><br><span class="line">            System.out.println(<span class="string">&quot;error 消息已经接收：\n&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        String queueName = <span class="string">&quot;console&quot;</span>;</span><br><span class="line">        <span class="comment">//队列声明</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//队列绑定</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            message = <span class="string">&quot;接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;,消息:&quot;</span> + message;</span><br><span class="line">            System.out.println(<span class="string">&quot;info和warning 消息已经接收：\n&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogDirect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建多个 bindingKey</span></span><br><span class="line">        Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;info&quot;</span>, <span class="string">&quot;普通 info 信息&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>, <span class="string">&quot;警告 warning 信息&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;错误 error 信息&quot;</span>);</span><br><span class="line">        <span class="comment">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>, <span class="string">&quot;调试 debug 信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//获取 key value</span></span><br><span class="line">            String bindingKey = bindingKeyEntry.getKey();</span><br><span class="line">            String message = bindingKeyEntry.getValue();</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="keyword">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topics-exchange"><a href="#Topics-exchange" class="headerlink" title="Topics exchange"></a>Topics exchange</h3><h4 id="Topic-的介绍"><a href="#Topic-的介绍" class="headerlink" title="Topic 的介绍"></a>Topic 的介绍</h4><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。</p><p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性—比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 <strong>topic</strong> 类型</p><p><strong>Topic的要求</strong></p><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是<strong>一个单词列表</strong>，<strong>以点号分隔开</strong>。这些单词可以是任意单词。比如说：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p><p>在这个规则列表中，其中有两个替换符是大家需要注意的：</p><ul><li>***(星号)可以代替一个单词**</li><li><strong>#(井号)可以替代零个或多个单词</strong></li></ul><h4 id="Topic-匹配案例"><a href="#Topic-匹配案例" class="headerlink" title="Topic 匹配案例"></a>Topic 匹配案例</h4><p>下图绑定关系如下</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000046.png" alt="RabbitMQ-00000046"></p><ul><li><p>Q1–&gt;绑定的是：</p><ul><li>中间带 orange 带 3 个单词的字符串 <code>(*.orange.*)</code></li></ul></li><li><p>Q2–&gt;绑定的是：</p><ul><li>最后一个单词是 rabbit 的 3 个单词 <code>(*.*.rabbit)</code></li><li>第一个单词是 lazy 的多个单词 <code>(lazy.#)</code></li></ul></li></ul><p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的：</p><table><thead><tr><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>quick.orange.rabbit</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>azy.orange.elephant</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>quick.orange.fox</td><td>被队列 Q1 接收到</td></tr><tr><td>lazy.brown.fox</td><td>被队列 Q2 接收到</td></tr><tr><td>lazy.pink.rabbit</td><td>虽然满足两个绑定但只被队列 Q2 接收一次</td></tr><tr><td>quick.brown.fox</td><td>不匹配任何绑定不会被任何队列接收到会被丢弃</td></tr><tr><td>quick.orange.male.rabbit</td><td>是四个单词不匹配任何绑定会被丢弃</td></tr><tr><td>lazy.orange.male.rabbit</td><td>是四个单词但匹配 Q2</td></tr></tbody></table><p>注意：</p><ul><li>当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了</li><li>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</li></ul><h4 id="Topic-实战"><a href="#Topic-实战" class="headerlink" title="Topic 实战"></a>Topic 实战</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000047.png" alt="RabbitMQ-00000047"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.seven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Q1--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         *      中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment">         * Q2--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class="line"><span class="comment">         *      第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>, <span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">            String bindingKey = bindingKeyEntry.getKey();</span><br><span class="line">            String message = bindingKeyEntry.getValue();</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="keyword">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//声明 Q1 队列与绑定关系</span></span><br><span class="line">        String queueName = <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        <span class="comment">//声明</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息........... &quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收队列:&quot;</span> + queueName + <span class="string">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;,消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//声明 Q2 队列与绑定关系</span></span><br><span class="line">        String queueName = <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        <span class="comment">//声明</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息........... &quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收队列:&quot;</span> + queueName + <span class="string">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;,消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><h3 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因<strong>导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p><h3 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h3><ul><li><p>消息 TTL 过期：TTL是Time To Live的缩写, 也就是生存时间。</p></li><li><p>队列达到最大长度：队列满了，无法再添加数据到 mq 中。</p></li><li><p>消息被拒绝：(basic.reject 或 basic.nack) 并且 requeue=false。</p></li></ul><h3 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000048.png" alt="RabbitMQ-00000048"></p><h4 id="死信之TTL"><a href="#死信之TTL" class="headerlink" title="死信之TTL"></a>死信之TTL</h4><p>消费者 C1 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列 - 消费者01</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常队列</span></span><br><span class="line">        String normalQueue = <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//设置消息的 TTL 时间 10s</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 C1 ，之后关闭消费者，模拟其接收不到消息。再启动 Producer：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000049.png" alt="RabbitMQ-00000049"></p><p>消费者 C2 代码：以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收死信消息........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02 接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(deadQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000050.png" alt="RabbitMQ-00000050"></p><h4 id="死信之最大长度"><a href="#死信之最大长度" class="headerlink" title="死信之最大长度"></a>死信之最大长度</h4><ol><li>消息生产者代码去掉 TTL 属性：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210628101337825.png" alt="image-20210628101337825"></p><ol start="2"><li>C1 消费者修改以下代码**(启动之后关闭该消费者 模拟其接收不到消息)**:</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000051.png" alt="RabbitMQ-00000051"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置正常队列的长度限制，例如发10个，4个则为死信</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><mark>注意此时需要把原先队列删除，因为参数改变了。</mark></p><ol start="3"><li>C2 消费者代码不变(启动 C2 消费者) </li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000052.png" alt="RabbitMQ-00000052"></p><h4 id="死信之消息被拒"><a href="#死信之消息被拒" class="headerlink" title="死信之消息被拒"></a>死信之消息被拒</h4><ol><li><p>消息生产者代码同上生产者一致</p></li><li><p>C1 消费者代码(启动之后关闭该消费者 模拟其接收不到消息)</p></li></ol><p>拒收消息 “info5” ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="comment">//        //设置正常队列的长度限制，例如发10个，4个则为死信</span></span><br><span class="line"><span class="comment">//        params.put(&quot;x-max-length&quot;,6);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正常队列</span></span><br><span class="line">        String normalQueue = <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息........... &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(<span class="string">&quot;info5&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line">                <span class="comment">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//开启手动应答</span></span><br><span class="line">        channel.basicConsume(normalQueue, <span class="keyword">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000053.png" alt="RabbitMQ-00000053"></p><ol start="3"><li>C2 消费者代码不变：启动消费者 1 然后再启动消费者 2 </li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000054.png" alt="RabbitMQ-00000054"></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="延迟队列概念："><a href="#延迟队列概念：" class="headerlink" title="延迟队列概念："></a><strong>延迟队列概念：</strong></h3><p>延时队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p><h3 id="延迟队列使用场景："><a href="#延迟队列使用场景：" class="headerlink" title="延迟队列使用场景："></a><strong>延迟队列使用场景：</strong></h3><ol><li>订单在十分钟之内未支付则自动取消；</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒；</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒；</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员；</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭。那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p><p>如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。</p><p>但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000055.png" alt="RabbitMQ-00000055"></p><h3 id="RabbitMQ-中的-TTL"><a href="#RabbitMQ-中的-TTL" class="headerlink" title="RabbitMQ 中的 TTL"></a>RabbitMQ 中的 TTL</h3><p>TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p><p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><ul><li><strong>队列设置TTL</strong>：在创建队列的时候设置队列的“x-message-ttl”属性</li></ul><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000057.png" alt="RabbitMQ-00000057"></p><ul><li><strong>消息设置TTL</strong>：是针对每条消息设置TTL</li></ul><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000056.png" alt="RabbitMQ-00000056"></p><p><strong>两者的区别</strong> </p><ul><li><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。</p></li><li><p>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p></li></ul><h3 id="整合-springboot"><a href="#整合-springboot" class="headerlink" title="整合 springboot"></a>整合 springboot</h3><ol><li>创建一个空项目：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000058.png" alt="RabbitMQ-00000058"></p><ol start="2"><li>添加依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>修改配置文件:</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">42.192.149.71</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><ol start="4"><li>添加Swagger 配置类 :</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;zhiyuan&quot;</span>, <span class="string">&quot;http://oddfar.com&quot;</span>, <span class="string">&quot;test@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列-TTL"><a href="#队列-TTL" class="headerlink" title="队列 TTL"></a>队列 TTL</h3><p><strong>代码架构图</strong> </p><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000060.png" alt="RabbitMQ-00000060"></p><p><strong>1、配置文件类代码 ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 死信队列交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 A 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueaBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queuebBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明死信队列 QD</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明死信队列 QD 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、消息生产者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.contorller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、消息消费者代码</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.contorller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhiyuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起一个请求 <a href="http://localhost:8080/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB">http://localhost:8080/ttl/sendMsg/嘻嘻嘻</a></p><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628162017168.png" alt="image-20210628162017168"></p><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p><p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p><h3 id="延时队列TTL优化"><a href="#延时队列TTL优化" class="headerlink" title="延时队列TTL优化"></a>延时队列TTL优化</h3><p>在这里新增了一个队列 QC，绑定关系如下，该队列不设置TTL 时间</p><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000062.png" alt="RabbitMQ-00000062"></p><p>配置文件类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgTtlQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_C = <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列 C 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//没有声明 TTL 属性</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queuecBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时队列优化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ttlTime 延时的毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> String ttlTime)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, correlationData -&gt; &#123;</span><br><span class="line">        correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">        <span class="keyword">return</span> correlationData;</span><br><span class="line">    &#125;);</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), ttlTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起请求：</p><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD1/20000">http://localhost:8080/ttl/sendExpirationMsg/你好1/20000</a></p><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD2/2000">http://localhost:8080/ttl/sendExpirationMsg/你好2/2000</a></p><p><img src="https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000063.png" alt="RabbitMQ-00000063"></p><p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“。</p><p>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。这也就是为什么第二个延时2秒，却后执行。</p><p>此外，我们还可以通过Rabbitmq 插件实现延迟队列。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点，看需要适用的场景。</p><h2 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h2><p>在生产环境中由于一些不明原因，导致 RabbitMQ  重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ </p><p><strong>确认机制方案：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000068.png" alt="RabbitMQ-00000068"></p><p><strong>代码架构图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000069.png" alt="RabbitMQ-00000069"></p><p>在配置文件当中需要添加</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure><ul><li><p><code>NONE</code> 值是禁用发布确认模式，是默认值。</p></li><li><p><code>CORRELATED</code> 值是发布消息成功到交换器后会触发回调方法。</p></li><li><p><code>SIMPLE</code> 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。</p></li></ul><p><strong>1、添加配置类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明业务 Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、消息生产者的回调接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 消息相关数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack             交换机是否收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause           为收到消息的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息，原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、消息生产者</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyCallBack myCallBack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息回调和退回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息 id 为 1</span></span><br><span class="line">        CorrelationData correlationData1 = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        String routingKey = <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);</span><br><span class="line">        log.info(routingKey + <span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class="line"></span><br><span class="line">        CorrelationData correlationData2 = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        routingKey = <span class="string">&quot;key2&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);</span><br><span class="line">        log.info(routingKey + <span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、消息消费者</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问： <a href="http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD">http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD</a></p><p>结果分析：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210629135636990.png" alt="image-20210629135636990"></p><p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败。</p><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>Mandatory 参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setReturnsCallback(myCallBack);</span><br></pre></td></tr></table></figure><p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</p><p>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消息退回</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？</p><p>前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p><p>备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p><p><strong>架构图</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000072.png" alt="RabbitMQ-00000072"></p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p><strong>概念</strong></p><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等.</p><p><strong>消息重复消费</strong></p><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p><p><strong>解决思路</strong></p><p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识，比如时间戳或者 UUID ，订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。</p><p><strong>消费端的幂等性保障</strong></p><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p><p>业界主流的幂等性有两种操作:</p><ol><li>唯一 ID+指纹码机制，用数据库主键去重；</li><li>利用 redis 的原子性去实现。</li></ol><ul><li>唯一ID+指纹码机制 </li></ul><p>指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码，它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p><ul><li> note Redis 原子性</li></ul><p>利用 redis 执行 setnx 命令，天然具有幂等性，从而实现不重复消费。</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p><strong>使用场景</strong></p><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。</p><p>但是，天猫商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果、小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p><p><strong>如何添加？</strong></p><ol><li>控制台页面添加</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000076.png" alt="RabbitMQ-00000076"></p><ol start="2"><li>队列中代码添加优先级</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br></pre></td></tr></table></figure><ol start="3"><li>消息中代码添加优先级</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">10</span>).build();</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><p>要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序。</p><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给消息赋予一个 priority 属性</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">10</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap();</span><br><span class="line">        params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210629163922085.png" alt="image-20210629163922085"></p><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><p><strong>使用场景</strong></p><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p><p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p><p><strong>两种模式</strong> </p><p>队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p><p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure><p><strong>内存开销对比</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/RabbitMQ-00000077.png" alt="RabbitMQ-00000077"></p><p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB。</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> Exchange </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyCat-高可用集群搭建、架构剖析</title>
      <link href="2021/07/17/MyCat%E2%80%94%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90/"/>
      <url>2021/07/17/MyCat%E2%80%94%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="MyCat高可用集群搭建"><a href="#MyCat高可用集群搭建" class="headerlink" title="MyCat高可用集群搭建"></a>MyCat高可用集群搭建</h2><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><h4 id="MyCat实现读写分离架构"><a href="#MyCat实现读写分离架构" class="headerlink" title="MyCat实现读写分离架构"></a>MyCat实现读写分离架构</h4><p>在之前的笔记中， 已经讲解过了通过MyCat来实现MySQL的读写分离，从而完成MySQL集群的负载均衡， 如下面的结构图： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528142409915.png" alt="image-20210528142409915" style="zoom: 50%;" /> <p>但是以上架构存在问题 ，由于MyCat中间件是单节点的服务，前端客户端所有的压力过来都直接请求这一台MyCat，存在单点故障。所以这个时候， 我们就需要考虑MyCat的集群 。</p><h4 id="MyCat集群架构"><a href="#MyCat集群架构" class="headerlink" title="MyCat集群架构"></a>MyCat集群架构</h4><p>通过MyCat来实现后端MySQL的负载均衡 ，通过HAProxy再实现MyCat集群的负载均衡：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528142453972.png" alt="image-20210528142453972" style="zoom: 45%;" /> <p>HAProxy 负责将请求分发到 MyCat 上，起到负载均衡的作用，同时 HAProxy 也能检测到 MyCat 是否存活，HAProxy 只会将请求转发到存活的 MyCat 上。如果一台 MyCat 服务器宕机，HAPorxy 转发请求时不会转发到宕机的 MyCat 上，所以 MyCat 依然可用。</p><p><strong>HAProxy介绍：</strong></p><p>HAProxy 是一个开源的、高性能的基于TCP(第四层)和HTTP(第七层)应用的负载均衡软件。 使用HAProxy可以快速、可靠地实现基于TCP与HTTP应用的负载均衡解决方案。</p><p>具有以下优点： </p><ol><li><p>可靠性和稳定性好, 可以与硬件级的F5负载均衡服务器媲美 ;</p></li><li><p>处理能力强, 最高可以通过维护4w-5w个并发连接, 单位时间处理的最大请求数达到2w个 ;</p></li><li><p>支持多种负载均衡算法 ;</p></li><li><p>有功能强大的监控界面, 通过此页面可以实时了解系统的运行情况 ;</p></li></ol><p>但是，上述的架构也是存在问题的， 因为所有的客户端请求都是先到达HAProxy，由HAProxy再将请求再向下分发，如果HAProxy宕机的话，就会造成整个MyCat集群不能正常运行，依然存在单点故障。</p><h4 id="MyCat的高可用集群"><a href="#MyCat的高可用集群" class="headerlink" title="MyCat的高可用集群"></a>MyCat的高可用集群</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528142546548.png" alt="image-20210528142546548" style="zoom: 45%;" /> <p><strong>图解说明：</strong></p><ol><li><p>HAProxy 实现了 MyCat 多节点的集群高可用和负载均衡，而 HAProxy 自身的高可用则可以通过Keepalived 来实现。因此，HAProxy 主机上要同时安装 HAProxy 和 Keepalived，Keepalived 负责为该服务器抢占 vip（虚拟 ip），抢占到 vip 后，对该主机的访问可以通过原来的 ip访问，也可以直接通过 vip访问。</p></li><li><p>Keepalived 抢占 vip 有优先级，由keepalived.conf 配置中的 priority 属性决定。但是一般哪台主机上的Keepalived服务先启动就会抢占到vip，即使是slave，只要先启动也能抢到（要注意避免Keepalived的资源抢占问题）。</p></li><li><p>HAProxy 负责将 vip 上的请求分发到 MyCat 集群节点上，起到负载均衡的作用。同时 HAProxy 也能检测到 MyCat 是否存活，HAProxy 只会将请求转发到存活的 MyCat 上。</p></li><li><p>如果 Keepalived+HAProxy 高可用集群中的一台服务器宕机，集群中另外一台服务器上的 Keepalived会立刻抢占 vip 并接管服务，此时抢占了 vip 的 HAProxy 节点可以继续提供服务。</p></li><li><p>如果一台 MyCat 服务器宕机，HAPorxy 转发请求时不会转发到宕机的 MyCat 上，所以 MyCat 依然可用。</p></li></ol><p>综上：MyCat 的高可用及负载均衡由 HAProxy 来实现，而 HAProxy 的高可用，由 Keepalived 来实现。</p><p><strong>keepalived介绍:</strong></p><ul><li>Keepalived是一种基于VRRP协议来实现的高可用方案,可以利用其来避免单点故障。 通常有两台甚至多台服务器运行Keepalived，一台为主服务器(Master), 其他为备份服务器, 但是对外表现为一个虚拟IP(VIP), 主服务器会发送特定的消息给备份服务器, 当备份服务器接收不到这个消息时, 即认为主服务器宕机 , 备份服务器就会接管虚拟IP, 继续提供服务, 从而保证了整个集群的高可用。</li><li>VRRP(虚拟路由冗余协议-Virtual Router Redundancy Protocol)协议是用于实现路由器冗余的协议，VRRP 协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器 IP(一个或多个)，而在路由器组内部，如果实际拥有这个对外 IP 的路由器如果工作正常的话就是 MASTER，或者是通过算法选举产生。MASTER 实现针对虚拟路由器 IP 的各种网络功能，如 ARP 请求，ICMP，以及数据的转发等；其他设备不拥有该虚拟 IP，状态是 BACKUP，除了接收 MASTER 的VRRP 状态通告信息外，不执行对外的网络功能。当主机失效时，BACKUP 将接管原先 MASTER 的网络功能。</li><li>VRRP 协议使用多播数据来传输 VRRP 数据，VRRP 数据使用特殊的虚拟源 MAC 地址发送数据而不是自身网卡的 MAC 地址，VRRP 运行时只有 MASTER 路由器定时发送 VRRP 通告信息，表示 MASTER 工作正常以及虚拟路由器 IP(组)，BACKUP 只接收 VRRP 数据，不发送数据，如果一定时间内没有接收到 MASTER 的通告信息，各 BACKUP 将宣告自己成为 MASTER，发送通告信息，重新进行 MASTER 选举状态。</li></ul><h3 id="高可用集群搭建"><a href="#高可用集群搭建" class="headerlink" title="高可用集群搭建"></a>高可用集群搭建</h3><h4 id="部署环境规划"><a href="#部署环境规划" class="headerlink" title="部署环境规划"></a>部署环境规划</h4><table><thead><tr><th align="left">名称</th><th align="center">IP</th><th align="center">端口</th><th align="center">用户名/密码</th></tr></thead><tbody><tr><td align="left">MySQL Master</td><td align="center">192.168.192.157</td><td align="center">3306</td><td align="center">root/123456</td></tr><tr><td align="left">MySQL Slave</td><td align="center">192.168.192.158</td><td align="center">3306</td><td align="center">root/123456</td></tr><tr><td align="left">MyCat节点1</td><td align="center">192.168.192.157</td><td align="center">8066</td><td align="center">root/123456</td></tr><tr><td align="left">MyCat节点2</td><td align="center">192.168.192.158</td><td align="center">8066</td><td align="center">root/123456</td></tr><tr><td align="left">HAProxy节点1/keepalived主</td><td align="center">192.168.192.159</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">HAProxy节点2/keepalived备</td><td align="center">192.168.192.160</td><td align="center"></td><td align="center"></td></tr></tbody></table><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528142700817.png" alt="image-20210528142700817" style="zoom:50%;" /> <h4 id="MySQL主从复制搭建"><a href="#MySQL主从复制搭建" class="headerlink" title="MySQL主从复制搭建"></a>MySQL主从复制搭建</h4><p>环境搭建之前需要每台服务器上都已经安装MySQL。</p><h5 id="master"><a href="#master" class="headerlink" title="master"></a>master</h5><ol><li>在master 的配置文件（/usr/my.cnf）中，配置如下内容：</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql 服务ID,保证整个集群环境中唯一</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#mysql binlog 日志的存储路径和文件名</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">/var/lib/mysql/mysqlbin</span></span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br><span class="line"><span class="comment">#是否只读,1 代表只读, 0 代表读写</span></span><br><span class="line"><span class="meta">read-only</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#指定同步的数据库</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db01</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db02</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db03</span></span><br></pre></td></tr></table></figure><ol start="2"><li>执行完毕之后，需要重启MySQL：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart ;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建同步数据的账户，并且进行授权操作：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">flush privileges;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>查看master状态：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528142344820.png" alt="image-20210528142344820">  </p><p>字段含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File : 从哪个日志文件开始推送日志文件 </span><br><span class="line">Position ： 从哪个位置开始推送日志</span><br><span class="line">Binlog_Do_DB : 指定需要同步的数据库</span><br></pre></td></tr></table></figure><h5 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h5><ol><li>在 slave 端配置文件中，配置如下内容：</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql服务端ID,唯一</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">2</span></span><br><span class="line"><span class="comment">#指定binlog日志</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">/var/lib/mysql/mysqlbin</span></span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line"><span class="meta">relay-log</span>=<span class="string">mysql-relay</span></span><br></pre></td></tr></table></figure><ol start="2"><li>执行完毕之后，需要重启MySQL：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart;</span><br></pre></td></tr></table></figure><ol start="3"><li>执行如下指令 ：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。</span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span> <span class="string">&#x27;192.168.192.157&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>, master_log_file<span class="operator">=</span><span class="string">&#x27;mysqlbin.000002&#x27;</span>, master_log_pos<span class="operator">=</span><span class="number">120</span>;</span><br></pre></td></tr></table></figure><p>但是如果之前节点之间有主从复制关系，需要先停止两者的联系：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure><ol start="4"><li>开启同步操作：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br><span class="line">show slave status;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528143557533.png" alt="image-20210528143557533"></p><h5 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create database db01;</span><br><span class="line"></span><br><span class="line">user db01;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">user</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span>(<span class="number">11</span>)</span> not <span class="keyword">null</span> auto_increment,</span></span><br><span class="line"><span class="function">name <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">sex <span class="title">varchar</span><span class="params">(<span class="number">1</span>)</span>,</span></span><br><span class="line"><span class="function">primary <span class="title">key</span> <span class="params">(id)</span></span></span><br><span class="line"><span class="function">)engine</span>=innodb <span class="keyword">default</span> charset=utf8;</span><br><span class="line"></span><br><span class="line"><span class="function">insert into <span class="title">user</span><span class="params">(id,name,sex)</span> <span class="title">values</span><span class="params">(<span class="keyword">null</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">user</span><span class="params">(id,name,sex)</span> <span class="title">values</span><span class="params">(<span class="keyword">null</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">user</span><span class="params">(id,name,sex)</span> <span class="title">values</span><span class="params">(<span class="keyword">null</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在主节点以及从节点上都可以查到数据：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528143435791.png" alt="image-20210528143435791"></p><h4 id="MyCat安装配置"><a href="#MyCat安装配置" class="headerlink" title="MyCat安装配置"></a>MyCat安装配置</h4><h5 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.157:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.158:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两台服务器均需要安装MyCat（依赖JDK）、JDK，并且MyCat服务做相同的配置 。MyCat、JDK安装见本博客的MyCat入门文档。</p><h5 id="测试验证-1"><a href="#测试验证-1" class="headerlink" title="测试验证"></a>测试验证</h5><ol><li><p>两台服务器均启动MyCat：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/mycat start;</span><br><span class="line">mysql -h 192.168.192.157/8 -P 8066 -u root -p;</span><br></pre></td></tr></table></figure></li><li><p>通过查看日志验证环境是否搭建成功（记得修改日志级别为：DEBUG）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Tom2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528145225031.png" alt="image-20210528145225031"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528145515739.png" alt="image-20210528145515739"></p><p>读操作走从节点，写操作走主节点。</p></li></ol><h4 id="HAProxy安装配置"><a href="#HAProxy安装配置" class="headerlink" title="HAProxy安装配置"></a>HAProxy安装配置</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ol><li>准备好HAProxy安装包，分别上传到两台服务器（192.168.192.159/160都安装）的/root目录下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haproxy-1.5.16.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>解压到/usr/local/src目录下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf haproxy-1.5.16.tar.gz -C /usr/local/src</span><br></pre></td></tr></table></figure><ol start="3"><li>进入解压后的目录，查看内核版本，进行编译：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/haproxy-1.5.16</span><br><span class="line">uname -r</span><br><span class="line">make TARGET=linux2632 PREFIX=/usr/local/haproxy ARCH=x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> TARGET=linux310，内核版本，使用uname -r查看内核，如：2.6.32-431.el6.x86_64，此时该参数就为linux2632；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ARCH=x86_64:系统位数；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PREFIX=/usr/<span class="built_in">local</span>/haprpxy <span class="comment">#/usr/local/haprpxy，为haprpxy安装路径。</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>编译完成后，进行安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install PREFIX=/usr/local/haproxy</span><br></pre></td></tr></table></figure><ol start="5"><li>安装完成后，创建目录：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/data/haproxy/</span><br></pre></td></tr></table></figure><ol start="6"><li>创建HAProxy配置文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/haproxy/haproxy.conf</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">global</span></span><br><span class="line"><span class="string">log</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">local0</span> </span><br><span class="line"><span class="string">maxconn</span> <span class="number">4096</span> </span><br><span class="line"><span class="string">chroot</span> <span class="string">/usr/local/haproxy</span> </span><br><span class="line"><span class="string">pidfile</span> <span class="string">/usr/data/haproxy/haproxy.pid</span></span><br><span class="line"><span class="string">uid</span> <span class="number">99</span></span><br><span class="line"><span class="string">gid</span> <span class="number">99</span></span><br><span class="line"><span class="string">daemon</span></span><br><span class="line"><span class="string">node</span> <span class="string">mysql-haproxy-01</span></span><br><span class="line"><span class="string">description</span> <span class="string">mysql-haproxy-01</span></span><br><span class="line"><span class="string">defaults</span></span><br><span class="line"><span class="string">log</span> <span class="string">global</span></span><br><span class="line"><span class="string">mode</span> <span class="string">tcp</span></span><br><span class="line"><span class="string">option</span> <span class="string">abortonclose</span></span><br><span class="line"><span class="string">option</span> <span class="string">redispatch</span></span><br><span class="line"><span class="string">retries</span> <span class="number">3</span></span><br><span class="line"><span class="string">maxconn</span> <span class="number">2000</span></span><br><span class="line"><span class="string">timeout</span> <span class="string">connect</span> <span class="string">50000ms</span></span><br><span class="line"><span class="string">timeout</span> <span class="string">client</span> <span class="string">50000ms</span></span><br><span class="line"><span class="string">timeout</span> <span class="string">server</span> <span class="string">50000ms</span></span><br><span class="line"><span class="string">listen</span> <span class="string">proxy_status</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:48066</span></span><br><span class="line"><span class="string">mode</span> <span class="string">tcp</span></span><br><span class="line"><span class="string">balance</span> <span class="string">roundrobin</span></span><br><span class="line"><span class="string">server</span> <span class="string">mycat_1</span> <span class="number">192.168</span><span class="number">.192</span><span class="number">.157</span><span class="string">:8066</span> <span class="string">check</span></span><br><span class="line"><span class="string">server</span> <span class="string">mycat_2</span> <span class="number">192.168</span><span class="number">.192</span><span class="number">.158</span><span class="string">:8066</span> <span class="string">check</span></span><br><span class="line"><span class="string">frontend</span> <span class="string">admin_stats</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8888</span></span><br><span class="line"><span class="string">mode</span> <span class="string">http</span></span><br><span class="line"><span class="string">stats</span> <span class="string">enable</span></span><br><span class="line"><span class="string">option</span> <span class="string">httplog</span></span><br><span class="line"><span class="string">maxconn</span> <span class="number">10</span></span><br><span class="line"><span class="string">stats</span> <span class="string">refresh</span> <span class="string">30s</span></span><br><span class="line"><span class="string">stats</span> <span class="string">uri</span> <span class="string">/admin</span></span><br><span class="line"><span class="string">stats</span> <span class="string">auth</span> <span class="string">admin:123123</span></span><br><span class="line"><span class="string">stats</span> <span class="string">hide-version</span></span><br><span class="line"><span class="string">stats</span> <span class="string">admin</span> <span class="string">if</span> <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p><strong>内容解析如下</strong> : </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#global 配置中的参数为进程级别的参数，通常与其运行的操作系统有关</span></span><br><span class="line"><span class="string">global</span></span><br><span class="line"><span class="comment">#定义全局的syslog服务器, 最多可定义2个; local0 是日志设备, 对应于/etc/rsyslog.conf中的配置 , 默认收集info级别日志</span></span><br><span class="line"><span class="string">log</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">local0</span> </span><br><span class="line"><span class="comment">#log 127.0.0.1 local1 notice</span></span><br><span class="line"><span class="comment">#log loghost local0 info</span></span><br><span class="line"><span class="comment">#设定每个haproxy进程所接受的最大并发连接数 ;</span></span><br><span class="line"><span class="string">maxconn</span> <span class="number">4096</span> </span><br><span class="line"><span class="comment">#修改HAproxy工作目录至指定的目录并在放弃权限之前执行chroot操作, 可以提升haproxy的安全级别</span></span><br><span class="line"><span class="string">chroot</span> <span class="string">/usr/local/haproxy</span> </span><br><span class="line"><span class="comment">#进程ID保存文件</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/usr/data/haproxy/haproxy.pid</span></span><br><span class="line"><span class="comment">#指定用户ID</span></span><br><span class="line"><span class="string">uid</span> <span class="number">99</span></span><br><span class="line"><span class="comment">#指定组ID</span></span><br><span class="line"><span class="string">gid</span> <span class="number">99</span></span><br><span class="line"><span class="comment">#设置HAproxy以守护进程方式运行</span></span><br><span class="line"><span class="string">daemon</span></span><br><span class="line"><span class="comment">#debug</span></span><br><span class="line"><span class="comment">#quiet</span></span><br><span class="line"><span class="string">node</span> <span class="string">mysql-haproxy-01</span>  <span class="comment">## 定义当前节点的名称，用于 HA 场景中多 haproxy 进程共享同一个 IP 地址时</span></span><br><span class="line"><span class="string">description</span> <span class="string">mysql-haproxy-01</span> <span class="comment">## 当前实例的描述信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#defaults：用于为所有其他配置段提供默认参数，这默认配置参数可由下一个&quot;defaults&quot;所重新设定</span></span><br><span class="line"><span class="string">defaults</span></span><br><span class="line"><span class="comment">#继承global中的log定义</span></span><br><span class="line"><span class="string">log</span> <span class="string">global</span></span><br><span class="line"><span class="comment">#所使用的处理模式(tcp:四层 , http:七层, health:状态检查,只返回OK)</span></span><br><span class="line"><span class="comment">### tcp: 实例运行于纯 tcp 模式，在客户端和服务器端之间将建立一个全双工的连接，且不会对 7 层报文做任何类型的检查，此为默认模式</span></span><br><span class="line"><span class="comment">### http:实例运行于 http 模式，客户端请求在转发至后端服务器之前将被深度分析，所有不与 RFC 模式兼容的请求都会被拒绝</span></span><br><span class="line"><span class="comment">### health：实例运行于 health 模式，其对入站请求仅响应“OK”信息并关闭连接，且不会记录任何日志信息 ，此模式将用于相应外部组件的监控状态检测请求</span></span><br><span class="line"><span class="string">mode</span> <span class="string">tcp</span></span><br><span class="line"><span class="comment">#当服务器负载很高的时候，自动结束掉当前队列处理时间比较长的连接</span></span><br><span class="line"><span class="string">option</span> <span class="string">abortonclose</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当使用了cookie时，haproxy将会将请求的后端服务器的serverID插入到cookie中，以保证会话的session持久性，而此时，后端服务器宕机，但是客户端的cookie不会刷新，设置此参数，将会将客户请求强制定向到另外一个后端server上，以保证服务的正常。</span></span><br><span class="line"><span class="string">option</span> <span class="string">redispatch</span></span><br><span class="line"><span class="string">retries</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 前端的最大并发连接数（默认为 2000）</span></span><br><span class="line"><span class="string">maxconn</span> <span class="number">2000</span></span><br><span class="line"><span class="comment"># 连接超时(默认是毫秒,单位可以设置 us,ms,s,m,h,d)</span></span><br><span class="line"><span class="string">timeout</span> <span class="string">connect</span> <span class="number">5000</span></span><br><span class="line"><span class="comment"># 客户端超时时间</span></span><br><span class="line"><span class="string">timeout</span> <span class="string">client</span> <span class="number">50000</span></span><br><span class="line"><span class="comment"># 服务器超时时间</span></span><br><span class="line"><span class="string">timeout</span> <span class="string">server</span> <span class="number">50000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#listen: 用于定义通过关联“前端”和“后端”一个完整的代理，通常只对 TCP 流量有用</span></span><br><span class="line"><span class="string">listen</span> <span class="string">proxy_status</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:48066</span> <span class="comment"># 绑定端口</span></span><br><span class="line"><span class="string">mode</span> <span class="string">tcp</span></span><br><span class="line"><span class="string">balance</span> <span class="string">roundrobin</span> <span class="comment"># 定义负载均衡算法，可用于&quot;defaults&quot;、&quot;listen&quot;和&quot;backend&quot;中,默认为轮询</span></span><br><span class="line"><span class="comment">#格式: server &lt;name&gt; &lt;address&gt; [:[port]] [param*]</span></span><br><span class="line"><span class="comment"># weight : 权重，默认为 1，最大值为 256，0 表示不参与负载均衡</span></span><br><span class="line">        <span class="comment"># backup : 设定为备用服务器，仅在负载均衡场景中的其他 server 均不可以启用此 server</span></span><br><span class="line">        <span class="comment"># check  : 启动对此 server 执行监控状态检查，其可以借助于额外的其他参数完成更精细的设定</span></span><br><span class="line">        <span class="comment"># inter  : 设定监控状态检查的时间间隔，单位为毫秒，默认为 2000，也可以使用 fastinter 和 downinter 来根据服务器端专题优化此事件延迟</span></span><br><span class="line">        <span class="comment"># rise   : 设置 server 从离线状态转换至正常状态需要检查的次数（不设置的情况下，默认值为 2）</span></span><br><span class="line">        <span class="comment"># fall   : 设置 server 从正常状态转换至离线状态需要检查的次数（不设置的情况下，默认值为 3）</span></span><br><span class="line">        <span class="comment"># cookie : 为指定 server 设定 cookie 值，此处指定的值将会在请求入站时被检查，第一次为此值挑选的 server 将会被后续的请求所选中，其目的在于实现持久连接的功能</span></span><br><span class="line">        <span class="comment"># maxconn: 指定此服务器接受的最大并发连接数，如果发往此服务器的连接数目高于此处指定的值，其将被放置于请求队列，以等待其他连接被释放</span></span><br><span class="line"><span class="string">server</span> <span class="string">mycat_1</span> <span class="number">192.168</span><span class="number">.192</span><span class="number">.157</span><span class="string">:8066</span> <span class="string">check</span> <span class="string">inter</span> <span class="string">10s</span></span><br><span class="line"><span class="string">server</span> <span class="string">mycat_2</span> <span class="number">192.168</span><span class="number">.192</span><span class="number">.158</span><span class="string">:8066</span> <span class="string">check</span> <span class="string">inter</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来匹配接收客户所请求的域名，uri等，并针对不同的匹配，做不同的请求处理.</span></span><br><span class="line"><span class="comment"># HAProxy 的状态信息统计页面</span></span><br><span class="line"><span class="string">frontend</span> <span class="string">admin_stats</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8888</span></span><br><span class="line"><span class="string">mode</span> <span class="string">http</span></span><br><span class="line"><span class="string">stats</span> <span class="string">enable</span></span><br><span class="line"><span class="string">option</span> <span class="string">httplog</span></span><br><span class="line"><span class="string">maxconn</span> <span class="number">10</span></span><br><span class="line"><span class="string">stats</span> <span class="string">refresh</span> <span class="string">30s</span></span><br><span class="line"><span class="string">stats</span> <span class="string">uri</span> <span class="string">/admin</span></span><br><span class="line"><span class="string">stats</span> <span class="string">auth</span> <span class="string">admin:123123</span></span><br><span class="line"><span class="string">stats</span> <span class="string">hide-version</span></span><br><span class="line"><span class="string">stats</span> <span class="string">admin</span> <span class="string">if</span> <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p>HAProxy的负载均衡策略：</p><table><thead><tr><th>策略</th><th>含义</th></tr></thead><tbody><tr><td>roundrobin</td><td>表示简单的轮循，即客户端每访问一次，请求轮循跳转到后端不同的节点机器上</td></tr><tr><td>static-rr</td><td>基于权重轮循，根据权重轮循调度到后端不同节点</td></tr><tr><td>leastconn</td><td>加权最少连接，表示最少连接者优先处理</td></tr><tr><td>source</td><td>表示根据请求源IP，这个跟Nginx的IP_hash机制类似，使用其作为解决session问题的一种方法</td></tr><tr><td>uri</td><td>表示根据请求的URL，调度到后端不同的服务器</td></tr><tr><td>url_param</td><td>表示根据请求的URL参数来进行调度</td></tr><tr><td>hdr（name）</td><td>表示根据HTTP请求头来锁定每一次HTTP请求</td></tr><tr><td>rdp-cookie（name）</td><td>表示根据cookie（name）来锁定并哈希每一次TCP请求</td></tr></tbody></table><h5 id="启动访问"><a href="#启动访问" class="headerlink" title="启动访问"></a>启动访问</h5><ol><li>启动HAProxy：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/haproxy.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>查看HAProxy进程：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep haproxy</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528153132223.png" alt="image-20210528153132223"></p><ol start="3"><li>访问</li></ol><p><a href="http://192.168.192.159:8888/admin">http://192.168.192.159:8888/admin</a></p><p>   界面：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528153356137.png" alt="image-20210528153356137">  </p><h4 id="Keepalived安装配置"><a href="#Keepalived安装配置" class="headerlink" title="Keepalived安装配置"></a>Keepalived安装配置</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528153439544.png" alt="image-20210528153439544" style="zoom: 50%;" /> <ol><li><p>Keepalived之间维持一个心跳，如果与VIP绑定的Keepalived挂掉，则另外一台Keepalived立刻获得VIP绑定，执行请求分发功能。</p></li><li><p>当位于绑定VIP的Keepalived上的HAProxy挂掉后，Keepalived无法执行分发功能，但是另外一台的Keepalived仍然可以监控到该Keepalived存活，不能获得VIP绑定，这时这台Keepalived会试图重启HAProxy，如果启动不成功，Keepalived的脚本文件会将自己挂掉（自杀），之后另外一台Keepalived会立刻与VIP绑定，执行请求分发功能。</p></li></ol><h5 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h5><p>在两台服务器上均安装HAProxy（159/160），并进行配置。</p><ol><li>上传安装包到Linux：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + p --------&gt; put D:/tmp/keepalived-1.4.5.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>解压安装包到目录 /usr/local/src：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf keepalived-1.4.5.tar.gz -C /usr/<span class="built_in">local</span>/src</span><br></pre></td></tr></table></figure><ol start="3"><li>安装依赖插件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc openssl-devel popt-devel</span><br></pre></td></tr></table></figure><ol start="4"><li>进入解压后的目录，进行配置和编译：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/keepalived-1.4.5</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/keepalived</span><br></pre></td></tr></table></figure><ol start="5"><li>进行编译，完成后进行安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ol start="6"><li>运行前配置：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/src/keepalived-1.4.5/keepalived/etc/init.d/keepalived /etc/init.d/</span><br><span class="line">mkdir /etc/keepalived</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/</span><br><span class="line">cp /usr/<span class="built_in">local</span>/src/keepalived-1.4.5/keepalived/etc/sysconfig/keepalived /etc/sysconfig/</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived/sbin/keepalived /usr/sbin/</span><br></pre></td></tr></table></figure><ol start="7"><li>修改配置文件 /etc/keepalived/keepalived.conf：</li></ol><ul><li>Master: 192.168.192.159</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">notification_email &#123;</span><br><span class="line">javadct@163.com</span><br><span class="line">&#125;</span><br><span class="line">notification_email_from keepalived@showjoy.com</span><br><span class="line">smtp_server 127.0.0.1</span><br><span class="line">smtp_connect_timeout 30</span><br><span class="line">router_id haproxy01  #标识</span><br><span class="line">vrrp_skip_check_adv_addr</span><br><span class="line">vrrp_garp_interval 0</span><br><span class="line">vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">script &quot;&#x2F;etc&#x2F;keepalived&#x2F;haproxy_check.sh&quot;</span><br><span class="line">interval 2</span><br><span class="line">weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">#主机配MASTER，备机配BACKUP</span><br><span class="line">state MASTER</span><br><span class="line">#所在机器网卡</span><br><span class="line">interface eth1</span><br><span class="line">virtual_router_id 51</span><br><span class="line">#数值越大优先级越高，越容易抢占</span><br><span class="line">priority 120</span><br><span class="line">advert_int 1</span><br><span class="line">authentication &#123;</span><br><span class="line">auth_type PASS</span><br><span class="line">auth_pass 1111</span><br><span class="line">&#125;</span><br><span class="line">## 将 track_script 块加入 instance 配置块</span><br><span class="line">    track_script &#123;</span><br><span class="line">    chk_haproxy ## 检查 HAProxy 服务是否存活</span><br><span class="line">    &#125;</span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line">#虚拟IP</span><br><span class="line">192.168.192.200</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BackUP: 1921.68.192.160</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">notification_email &#123;</span><br><span class="line">javadct@163.com</span><br><span class="line">&#125;</span><br><span class="line">notification_email_from keepalived@showjoy.com</span><br><span class="line">smtp_server 127.0.0.1</span><br><span class="line">smtp_connect_timeout 30</span><br><span class="line">#标识本节点</span><br><span class="line">router_id haproxy02</span><br><span class="line">vrrp_skip_check_adv_addr</span><br><span class="line">vrrp_garp_interval 0</span><br><span class="line">vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># keepalived 会定时执行脚本并对脚本执行的结果进行分析，动态调整 vrrp_instance 的优先级</span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line"># 检测 haproxy 状态的脚本路径</span><br><span class="line">script &quot;&#x2F;etc&#x2F;keepalived&#x2F;haproxy_check.sh&quot;</span><br><span class="line">#检测时间间隔</span><br><span class="line">interval 2</span><br><span class="line">#如果条件成立，权重+2</span><br><span class="line">weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">#主机配MASTER，备机配BACKUP</span><br><span class="line">state BACKUP</span><br><span class="line">#所在机器网卡</span><br><span class="line">interface eth1</span><br><span class="line">virtual_router_id 51</span><br><span class="line">#数值越大优先级越高</span><br><span class="line">priority 100</span><br><span class="line">advert_int 1</span><br><span class="line">authentication &#123;</span><br><span class="line">auth_type PASS</span><br><span class="line">auth_pass 1111</span><br><span class="line">&#125;</span><br><span class="line">## 将 track_script 块加入 instance 配置块</span><br><span class="line">    track_script &#123;</span><br><span class="line">    chk_haproxy ## 检查 HAProxy 服务是否存活</span><br><span class="line">    &#125;</span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line">#虚拟IP</span><br><span class="line">192.168.192.200</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>编写检测haproxy的shell脚本 在/etc/keepalived/haproxy_check.sh， haproxy_check.sh：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">A=`ps -C haproxy --no-header | wc -l`</span><br><span class="line"></span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line"></span><br><span class="line">  /usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/haproxy.conf</span><br><span class="line"></span><br><span class="line">  echo &quot;haproxy restart ...&quot; &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">  sleep 1</span><br><span class="line"></span><br><span class="line">  if [ `ps -C haproxy --no-header | wc -l` -eq 0 ];then</span><br><span class="line"></span><br><span class="line">    /etc/init.d/keepalived stop</span><br><span class="line"></span><br><span class="line">    echo &quot;stop keepalived&quot; &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h5><ol><li>启动Keepalived：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></table></figure><ol start="2"><li>登录验证：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p123456 -h 192.168.192.200 -P 48066</span><br></pre></td></tr></table></figure><p>上面语句其实也是访问HAProxy，进而访问到MySQL中的数据信息。</p><p>当主节点挂掉之后，备用节点与VIP进行绑定，而当主节点重新启用后，主节点重新与VIP进行绑定，而备用节点仍然是备用节点。</p><p>要想知道VIP与哪台服务器绑定可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a 地址  </span><br></pre></td></tr></table></figure><h2 id="MyCat架构剖析"><a href="#MyCat架构剖析" class="headerlink" title="MyCat架构剖析"></a>MyCat架构剖析</h2><h3 id="MyCat总体架构介绍"><a href="#MyCat总体架构介绍" class="headerlink" title="MyCat总体架构介绍"></a>MyCat总体架构介绍</h3><h4 id="源码下载及导入"><a href="#源码下载及导入" class="headerlink" title="源码下载及导入"></a>源码下载及导入</h4><p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529082401450.png" alt="image-20210529082401450"></p><p>导入编辑器： </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529160150015.png" alt="image-20210529160150015"> </p><h4 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h4><p>MyCat在逻辑上由几个模块组成：通信协议、路由解析、结果集处理、数据库连接、监控等模块。如图所示： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528190944761.png" alt="image-20210528190944761" style="zoom: 50%;" /> <ol><li><p>通信协议模块： 通信协议模块承担底层的收发数据、线程回调处理工作， MyCat通信协议默认采用Reactor模式，在协议层采用MySQL协议；</p></li><li><p>路由解析模块：负责对传入的SQL语句进行语法解析，解析语句的条件、类型、关键字等，并进行优化；</p></li><li><p>SQL执行模块：负责从连接池中获取连接，再根据路由解析的结果，把SQL语句分发到相应的节点执行;</p></li><li><p>数据库链接模块：负责创建、管理、维护后端的连接池。为减少每次建立数据库连接的开销，数据库使用连接池机制对连接声明周期进行管理；</p></li><li><p>结果集处理模块：负责对跨分片的查询结果进行汇聚、排序、截取等；</p></li><li><p>监控管理模块：负责MyCat的连接、内存等资源进行监控和管理。监控主要通过管理指令及监控服务展现一些监控数据； 管理则主要通过轮询事件来检测和释放不适用的资源。</p></li></ol><h4 id="总体执行流程"><a href="#总体执行流程" class="headerlink" title="总体执行流程"></a>总体执行流程</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528191042826.png" alt="image-20210528191042826" style="zoom:50%;" /> <h3 id="MyCat网络I-O架构及实现"><a href="#MyCat网络I-O架构及实现" class="headerlink" title="MyCat网络I/O架构及实现"></a>MyCat网络I/O架构及实现</h3><h4 id="BIO、NIO与AIO"><a href="#BIO、NIO与AIO" class="headerlink" title="BIO、NIO与AIO"></a>BIO、NIO与AIO</h4><ol><li>BIO</li></ol><p>BIO(同步阻塞I/O) 通常由一个单独的Acceptor线程负责监听客户端的连接，接收到客户端的连接请求后，会为每个客户端创建一个新的线程进行处理，处理完成之后，再给客户端返回结果，销毁线程 。</p><p>每个客户端请求接入时，都需要开启一个线程进行处理，一个线程只能处理一个客户端连接。 当客户端变多时，会创建大量的处理线程，每个线程都需要分配栈空间和CPU，并且频繁的线程上下文切换也会造成性能的浪费，所以该模式无法满足高性能、高并发接入的需求。</p><ol start="2"><li>NIO</li></ol><p>NIO(同步非阻塞I/O)基于Reactor模式作为底层通信模型，Reactor模式可以将事件驱动的应用进行事件分派，将客户端发送过来的服务请求分派给合适的处理类(handler)。当Socket有流可读或可写入Socket时，操作系统会通知相应的应用程序进行处理，应用程序再将流读取到缓冲区或写入操作系统。这时已经不是一个连接对应一个处理线程了，而是一个有效的请求对应一个线程，当没有数据时，就没有工作线程来处理。</p><p>NIO 的最大优点体现在线程轮询访问Selector，当read或write到达时则处，未到达时则继续轮询。</p><ol start="3"><li>AIO</li></ol><p>AIO是全程 Asynchronous IO(异步非阻塞的IO)，是一种非阻塞异步的通信模式。在NIO的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。AIO中客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><p>AIO与NIO的主要区别在于回调与轮询，客户端不需要关注服务处理事件是否完成，也不需要轮询，只需要关注自己的回调函数。</p><h4 id="通信架构"><a href="#通信架构" class="headerlink" title="通信架构"></a>通信架构</h4><p>在MyCat中实现了NIO与AIO两种I/O模式，可以通过配置文件server.xml进行指定 : </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;usingAIO&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>usingAIO为1代表使用AIO模型，为0表示使用NIO模型。</p><p><strong>MyCat的AIO架构</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529161255070.png" alt="image-20210529161255070" style="zoom:50%;" /> <ol><li><p>MyCatStartUp是整个MyCat服务启动的入口；</p></li><li><p>在获取到MyCat的home目录后，把主要的任务交给MyCatServer，并调用其startup方法；</p></li><li><p>初始化系统配置，获取配置文件中的usingAIO的配置，如果配置为1，说明使用AIO模型，进入到AIO的分支，并创建两个连接，一个是管理后台连接(9066)，一个server的连接(8066)；</p></li><li><p>进入AIO分支，主要有AIOAcceptor接收客户端请求，绑定端口，创建服务端的异步Socket；在accept方法中完成两件事: ①FrontedConnection的创建，这是前段连接的关键; ② register注册事件，MySQL协议握手包就在此时发送。</p></li></ol><p>AIOAcceptor的accept方法 ： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529164017969.png" alt="image-20210529164017969" style="zoom:50%;" /> <p><strong>MyCat的NIO架构</strong></p><p>如果设置的usingAIO为0，那么将走NIOAcceptor通道，流程如下： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529164113087.png" alt="image-20210529164113087" style="zoom:50%;" /> <ol><li><p>如果走NIO分支，将首先创建NIOAcceptor对象，并调用其start方法；</p></li><li><p>NIOAcceptor 负责处理Accept事件，服务端接收客户端的连接事件，就是MyCat作为服务端去处理前端业务程序发过来的连接请求， 建立连接后，调用NIOAcceptor的NIOReactor.postRegister方法进行注册（并没有注解注册，而是放入缓冲队列，避免加锁的竞争）。 </p></li></ol><p>NIOAcceptor的accept方法 ： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529164242242.png" alt="image-20210529164242242" style="zoom:50%;" /> <h3 id="Mycat实现MySQL协议"><a href="#Mycat实现MySQL协议" class="headerlink" title="Mycat实现MySQL协议"></a>Mycat实现MySQL协议</h3><h4 id="MySQL协议简介"><a href="#MySQL协议简介" class="headerlink" title="MySQL协议简介"></a>MySQL协议简介</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>MySQL协议处于应用层之下、TCP/IP之上，在MySQL客户端和服务端之间使用。包含了链接器、MySQL代理、主从复制服务器之间通信，并支持SSL加密、传输数据的压缩、连接和身份验证及数据交互等。其中，握手认证阶段和命令执行阶段是MySQL协议中的两个重要阶段。</p><h5 id="握手认证阶段"><a href="#握手认证阶段" class="headerlink" title="握手认证阶段"></a>握手认证阶段</h5><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529162549815.png" alt="image-20210529162549815" style="zoom:50%;" /> <ol><li><p>握手认证阶段是客户端连接服务器的必经之路，客户端与服务端完成TCP的三次握手以后，服务端会向客户端发送一个初始化握手包，握手包中包含了协议版本、MySQLServer版本、线程ID、服务器的权能标识和字符集等信息。</p></li><li><p>客户端在接收到服务端的初始化握手包之后，会发送身份验证包给服务端（AuthPacket），该包中包含用户名、密码等信息。</p></li><li><p>服务端接收到客户端的登录验证包之后，需要进行逻辑校验，校验该登录信息是否正确。如果信息都符合，则返回一个OKPacket，表示登录成功，否则返回ERR_Packet，表示拒绝。</p></li></ol><p>Wireshark抓包如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529162841533.png" alt="image-20210529162841533"> </p><p>报文分析如下： </p><ol><li>初始化握手包：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529163131557.png" alt="image-20210529163131557" style="zoom:50%;" /> <p>通过抓包工具Wireshark抓取到的握手包信息如下：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529164324303.png" alt="image-20210529164324303" style="zoom:50%;" />  <p>说明：</p><ul><li><p>Packet Length：包的长度</p></li><li><p>Packet Number：包的序号</p></li><li><p>Server Greeting：消息体，包含了协议版本、MySQLServer版本、线程ID和字符集等信息。 </p></li></ul><ol start="2"><li>登录认证包</li></ol><p>客户端在接收到服务端发来的初始握手包之后，向服务端发出认证请求，该请求包含以下信息（由Wireshark抓获）： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529164431474.png" alt="image-20210529164431474" style="zoom:50%;" /> <ol start="3"><li>OK包或ERROR包</li></ol><p>服务端接收到客户端的登录认证包之后，如果通过认证，则返回一个OKPacket，如果未通过认证，则返回一个ERROR包。</p><p>OK报文如下： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529164511413.png" alt="image-20210529164511413" style="zoom:50%;" /> <p>ERROR报文如下：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529164537597.png" alt="image-20210529164537597" style="zoom:50%;" /> <h5 id="命令执行阶段"><a href="#命令执行阶段" class="headerlink" title="命令执行阶段"></a>命令执行阶段</h5><p>在握手认证阶段通过并完成以后，客户端可以向服务端发送各种命令来请求数据，此阶段的流程是：命令请求-&gt;返回结果集。</p><p>Wireshark 捕获的数据包如下： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529164707467.png" alt="image-20210529164707467" style="zoom:50%;" /> <ol><li>命令包：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529164733540.png" alt="image-20210529164733540" style="zoom:50%;" /> <ol start="2"><li>结果集包：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529165457373.png" alt="image-20210529165457373" style="zoom:50%;" /> <h4 id="MySQL协议在MyCat中实现"><a href="#MySQL协议在MyCat中实现" class="headerlink" title="MySQL协议在MyCat中实现"></a>MySQL协议在MyCat中实现</h4><h5 id="握手认证实现"><a href="#握手认证实现" class="headerlink" title="握手认证实现"></a>握手认证实现</h5><p>在MyCat中同时实现了NIO和AIO，通过配置可以选择NIO和AIO。MyCat Server在启动阶段已经选择好采用NIO还是AIO，因此建立I/O通道后，MyCat服务端一直等待客户端的连接，当有连接到来的时候，MyCat首先发送握手包。 </p><ol><li>握手包源码实现：MyCat源码中io.mycat.net.FrontendConnection类的实现如下：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200127183259378.png" alt="image-20200127183259378"> </p><p>握手包信息组装完毕后，通过FrontedConnection写回客户端。</p><ol start="2"><li>认证包源码实现</li></ol><p>客户端接收到握手包后，紧接着向服务端发起一个认证包，MyCat封装为类 AuthPacket：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529165547943.png" alt="image-20210529165547943" style="zoom:50%;" /> <p>客户端发送的认证包转由 FrontendAuthenticator 的Handler来处理，主要操作就是 拆包，检查用户名、密码合法性，检查连接数是够超出限制。源码实现如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200127232022594.png" alt="image-20200127232022594"> </p><p>认证失败，调用failure方法，认证成功调用success方法。</p><p>failure方法源码： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529165726080.png" alt="image-20210529165726080" style="zoom:50%;" /> <p>success方法源码： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529165801988.png" alt="image-20210529165801988" style="zoom:50%;" /> <h5 id="命令执行实现"><a href="#命令执行实现" class="headerlink" title="命令执行实现"></a>命令执行实现</h5><p>命令执行阶段就是SQL命令和SQL语句执行阶段，在该阶段MyCat主要需要做的事情，就是对客户端发来的数据包进行拆包，并判断命令的类型，并解析SQL语句，执行响应的SQL语句，最后把执行结果封装在结果集包中，返回给客户端。</p><p>从客户端发来的命令交给 FrontendCommandHandler 中的handle方法处理：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200127235140959.png" alt="image-20200127235140959"> </p><p>处理具体的请求，返回客户端结果集数据包：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200128000050787.png" alt="image-20200128000050787"> </p><h3 id="MyCat线程架构与实现"><a href="#MyCat线程架构与实现" class="headerlink" title="MyCat线程架构与实现"></a>MyCat线程架构与实现</h3><h4 id="MyCat线程池实现"><a href="#MyCat线程池实现" class="headerlink" title="MyCat线程池实现"></a>MyCat线程池实现</h4><p>在MyCat中大量用到了线程池，通过线程池来避免频繁的创建和销毁线程而造成的系统性能的浪费。在MyCat中使用的线程池是JDK中提供的线程池 ThreadPoolExecutor 的子类 NameableExecutor ， 构造方法如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200108114506434.png" alt="image-20200108114506434"> </p><p>父类构造为： </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200108114611505.png" alt="image-20200108114611505"> </p><p>构造参数含义：</p><ul><li><p>corePoolSize : 核心池大小</p></li><li><p>maximumPoolSize : 最大线程数 </p></li><li><p>keepAliveTime: 线程没有任务执行时，最多能够存活多久</p></li><li><p>timeUnit: 时间单位 </p></li><li><p>workQueue: 阻塞任务队列</p></li><li><p>threadFactory: 线程工厂，用来创建线程</p></li></ul><h4 id="MyCat线程架构"><a href="#MyCat线程架构" class="headerlink" title="MyCat线程架构"></a>MyCat线程架构</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529170443397.png" alt="image-20210529170443397" style="zoom:50%;" /> <p>在MyCat中主要有两大线程池：timerExecutor 和 businessExecutor。</p><ol><li><p>timerExecutor 线程池主要完成系统时间定时更新、处理器定时检查、数据节点定时连接、空闲超时检查、数据节点定时心跳检测等任务。</p></li><li><p>businessExecutor是MyCat最重要的线程资源池，该资源池的线程使用的范围非常广，涵盖以下方面： </p><ul><li>后端用原生协议连接数据</li><li>JDBC执行SQL语句</li><li>SQL拦截</li><li>数据合并服务</li><li>批量SQL作业</li><li>查询结果的异步分发</li><li>基于guava实现异步回调</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200108141645417.png" alt="image-20200108141645417"> </p><h3 id="MyCat内存管理及缓存框架与实现"><a href="#MyCat内存管理及缓存框架与实现" class="headerlink" title="MyCat内存管理及缓存框架与实现"></a>MyCat内存管理及缓存框架与实现</h3><p>这里所提到的内存管理指的是MyCat缓冲区管理，众所周知设置缓冲区的唯一目的是提高系统的性能，缓冲区通常是部分常用的数据存放在缓冲池中以便系统直接访问，避免使用磁盘IO访问磁盘数据，从而提高性能。</p><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ol><li><p>缓冲池组成：缓冲池的最小单位为chunk，默认的chunk大小为4096字节(DEFAULT_BUFFER_CHUNK_SIZE)，BufferPool的总大小为4096 x processors x 1000(其中processors为处理器数量)。对I/O进程而言，他们共享一个缓冲池。缓冲池有两种类型：本地缓存线程（以$_开头的线程）缓冲区和其他缓冲区，分配buffer时，优先获取ThreadLocalPool中的buffer，没有命中时会获取BufferPool中的buffer。</p></li><li><p>分配MyCat缓冲池：分配缓冲池时，可以指定大小，也可以用默认值。</p><ul><li>allocate()：先检测是否为本地线程，当执行线程为本地缓存线程时，localBufferPool取出一个可用的buffer。如果不是，则从ConcurrentLinkedQueue队列中取出一个buffer进行分配，如果队列没有可用的buffer，则创建一个直接缓冲区。</li><li>allocate(size)：如果用户指定的size不大于chunkSize，则调用allocate()进行分配；反之则调用createTempBuffer(size)创建临时非直接缓冲区。</li></ul></li></ol><ol start="3"><li>MyCat缓冲池的回收：回收时先判断buffer是否有效，有如下情况时缓冲池不回收。<ul><li>不是直接缓冲区</li><li>buffer是空的</li><li>buffer的容量大于chunkSize</li></ul></li></ol><h4 id="MyCat缓存架构"><a href="#MyCat缓存架构" class="headerlink" title="MyCat缓存架构"></a>MyCat缓存架构</h4><ol><li>缓存框架选择：MyCat支持ehcache、mapdb、leveldb缓存，可通过配置文件cacheserver.properties来进行配置：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200108154627518.png" alt="image-20200108154627518"> </p><ol start="2"><li>缓存内容：MyCat有路由缓存、表主键到datanode缓存、ER关系缓存。<ul><li>路由缓存: 即SQLRouteCache, 根据SQL语句查找路由信息的缓存, 该缓存只是针对select语句, 如果执行了之前已经执行过的某个SQL语句(缓存命中), 那么路由信息就不需要重复计算了, 直接从缓存中获取。</li><li> 表主键到datanode缓存: 当分片字段与主键字段不一致时, 直接通过主键值查询时无法定位具体分片的(只能全分片下发), 所以设置该缓存之后, 就可以利用主键值查找到分片名, 缓存的key是ID值, value是节点名。</li><li> ER关系缓存: 在ER分片时使用, 而且在insert查询中才会使用缓存, 当子表插入数据时, 根据父子关联字段确定子表分片, 下次可以直接从缓存中获取所在的分片。 </li></ul></li></ol><p>查看缓存指令： show @@cache；</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200108155642414.png" alt="image-20200108155642414"> </p><h3 id="MyCat连接池架构与实现"><a href="#MyCat连接池架构与实现" class="headerlink" title="MyCat连接池架构与实现"></a>MyCat连接池架构与实现</h3><p>这里所讨论的连接池是MyCat的后端连接池，也就是MyCat后端与各个数据库节点之间的连接架构。</p><ol><li><p>连接池创建：MyCat按照每个dataHost创建一个连接池，根据schema.xml文件的配置取得最小的连接数minCon，并初始化minCon个连接。在初始化连接时，还需要判定用户选择的是JDBC还是原生的MySQL协议，以便于创建对应的连接。</p></li><li><p>连接池分配：分配连接就是从连接池队列中取出一个连接，在取出一个连接时，MyCat需要根据负载均衡（balance属性）的类型选择不同的数据源，因为连接和数据源绑在一起，所以需要知道MyCat读写的是那些数据源，才能分配响应的连接。 </p></li><li><p>架构：</p></li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529171853415.png" alt="image-20210529171853415" style="zoom:50%;" /> <h3 id="MyCat主从切换架构与实现"><a href="#MyCat主从切换架构与实现" class="headerlink" title="MyCat主从切换架构与实现"></a>MyCat主从切换架构与实现</h3><h4 id="MyCat主从切换概述"><a href="#MyCat主从切换概述" class="headerlink" title="MyCat主从切换概述"></a>MyCat主从切换概述</h4><p>MyCat实现MySQL读写分离的目的在于降低单节点数据库的访问压力,  原理就是让主数据库执行增删改操作，从数据库执行查询操作，利用MySQL数据库的复制机制将Master的数据同步到slave上。</p><p>当master宕机后，slave承载的业务如何切换到master继续提供服务，以及slave宕机后如何将master切换到slave上。手动切换数据源很简单， 但不是运维工作的首选，本节重点就是讲解如何实现自动切换。</p><p>MyCat的读写分离依赖于MySQL的主从同步，也就是说MyCat没有实现数据的主从同步功能，但是实现了自动切换功能。</p><p><strong>1). 自动切换</strong></p><p>自动切换是MyCat主从复制的默认配置，当主机或从机宕机后，MyCat自动切换到可用的服务器上。假设写服务器为M，读服务器为S， 则： </p><ul><li><p>正常时，写M读S； </p></li><li><p>当M宕机后，读写S；恢复M后，写S，读M；</p></li><li><p>当S宕机后，读写M；恢复S后，写M，读S 。</p></li></ul><p><strong>2). 基于MySQL主从同步状态的切换</strong></p><p>这种切换方式与自动切换不同，MyCat检测到主从数据同步延迟时，<strong>会自动切换到拥有最新数据的MySQL服务器上</strong>，防止读到很久以前的数据。</p><p>原理就是通过检查MySQL的主从同步状态（show slave status）中的Seconds_Behind_Master、Slave_IO_Running、Slave_SQL_Running三个字段，来确定当前主从同步的状态以及主从之间的数据延迟。 Seconds_Behind_Master为0表示没有延迟，数值越大，则说明延迟越高。</p><h4 id="MyCat主从切换实现"><a href="#MyCat主从切换实现" class="headerlink" title="MyCat主从切换实现"></a>MyCat主从切换实现</h4><p>基于延迟的切换，则判断结果集中的Slave_IO_Running、Slave_SQL_Running两个个字段是否都为yes，以及Seconds_Behind_Master 是否小于配置文件中配置的 slaveThreshold的值，如果有其中任何一个条件不满足，则切换。</p><p>主要流程如下：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200128005840029.png" alt="image-20200128005840029" style="zoom:80%;" /> <h3 id="MyCat核心技术"><a href="#MyCat核心技术" class="headerlink" title="MyCat核心技术"></a>MyCat核心技术</h3><h4 id="MyCat分布式事务实现"><a href="#MyCat分布式事务实现" class="headerlink" title="MyCat分布式事务实现"></a>MyCat分布式事务实现</h4><p>MyCat在1.6版本以后已经支持XA分布式事务类型了。具体的使用流程如下：</p><ol><li>在应用层需要设置事务不能自动提交：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>在SQL中设置XA为开启状态：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> xa <span class="operator">=</span> <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>执行SQL：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Rose&#x27;</span>,<span class="string">&#x27;2&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Leo&#x27;</span>,<span class="string">&#x27;1&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>对事务进行提交或回滚：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span><span class="operator">/</span><span class="keyword">rollback</span></span><br></pre></td></tr></table></figure><p>完整流程如下: </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200129223657058.png" alt="image-20200129223657058" style="zoom:80%;" /> <h4 id="MyCat-SQL路由实现"><a href="#MyCat-SQL路由实现" class="headerlink" title="MyCat SQL路由实现"></a>MyCat SQL路由实现</h4><p>MyCat的路由是和SQL解析组件息息相关的，SQL路由模块是MyCat数据库中间件最重要的模块之一，使用MyCat主要是为了分库分表，而分库分表的核心就是路由。</p><h5 id="路由的作用"><a href="#路由的作用" class="headerlink" title="路由的作用"></a>路由的作用</h5><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200113225535847.png" alt="image-20200113225535847" style="zoom:80%;" /> <p>如图所示，MyCat接收到应用系统发来的查询语句，要将其发送到后端连接的MySQL数据库去执行，但是后端有三个数据库服务器，具体要查询那一台数据库服务器呢，这就是路由需要实现的功能。SQL的路由既要保证数据的完整，也不能造成资源的浪费，还要保证路由的效率。</p><h5 id="SQL解析器"><a href="#SQL解析器" class="headerlink" title="SQL解析器"></a>SQL解析器</h5><p>Mycat1.3版本之前模式使用的是Fdbparser的foundationdb的开源SQL解析器，在2015年被apple收购后，从开源变为闭源了。</p><p>目前版本的MyCat采用的是Druid的SQL解析器，性能比采用Fdbparser整体性能提高20%以上。</p><h4 id="MyCat跨库Join"><a href="#MyCat跨库Join" class="headerlink" title="MyCat跨库Join"></a>MyCat跨库Join</h4><h5 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h5><p>每个企业级的系统中，都会存在一些系统的基础信息表，类似于字典表、省份、城市、区域、语言表等，这些表与业务表之间存在关系， 但不是业务主从关系，而是一种属性关系。当我们对业务表进行分片处理时，可以将这些基础信息表设置为全局表，也就是在每个节点中都存在该表。</p><p>全局表的特性如下： </p><ol><li><p>全局表的insert、update、delete操作会实时地在所有节点同步执行，保持各个节点数据的一致性；</p></li><li><p>全局表的查询操作会从任意节点执行，因为所有节点的数据都一致；</p></li><li><p>全局表可以和任意表进行join操作。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200128013501684.png" alt="image-20200128013501684" style="zoom:80%;" /> <h5 id="ER表"><a href="#ER表" class="headerlink" title="ER表"></a>ER表</h5><p>关系型数据库是基于实体关系模型(Entity Relationship Model)的，MyCat中的ER表便来源于此。MyCat提出了基于ER关系的数据分片策略，子表的记录与其所关联的父表的记录存放在同一个数据分片中，通过表分组(Table Group)保证数据关联查询不会跨库操作。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200129101108379.png" alt="image-20200129101108379" style="zoom:80%;" /> <h5 id="catlet"><a href="#catlet" class="headerlink" title="catlet"></a>catlet</h5><p>catlet是MyCat为了解决跨分片Join提出的一种创新思路，也叫做人工智能(HBT)。MyCat参考了数据库中存储过程的实现方式，提出类似的跨库解决方案，用户可以根据系统提供的API接口实现跨分片Join。采用这种方案开发时，必须要实现Catlet接口的两个方法：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200129104415975.png" alt="image-20200129104415975"> </p><p>route 方法：路由的方法，传递系统配置和schema配置等 ;</p><p>processSQL方法：EngineCtx执行SQL并给客户端返回结果集 。</p><p>当自定义Catlet完成之后，需要将Catlet的实现类进行编译，并将其字节码文件 XXXCatlet.class存放在mycat_home/catlet目录下，系统会加载相关Class，而且每隔1分钟扫描一次文件是否更新，若更新则自动重新加载，因此无需重启服务。</p><p><strong>ShareJoin</strong></p><p>ShareJoin 是Catlet的实现，是一个简单的跨分片Join，目前支持两个表的Join，原理就是解析SQL语句，拆分成单表的语句执行，单后把各个节点的数据进行汇集。要想使用Catlet完成join，还需要借助于MyCat中的注解，在执行SQL语句时，使用catlet注解：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!mycat:catlet=demo.catlets.ShareJoin */</span> <span class="keyword">select</span> a.id <span class="keyword">as</span> aid , a.id , b.id <span class="keyword">as</span> bid , b.name <span class="keyword">as</span> name <span class="keyword">from</span> customer a, company b <span class="keyword">where</span> a.company_id<span class="operator">=</span>b.id <span class="keyword">and</span> a.id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="MyCat数据汇聚与排序"><a href="#MyCat数据汇聚与排序" class="headerlink" title="MyCat数据汇聚与排序"></a>MyCat数据汇聚与排序</h4><p>通过MyCat实现数据汇聚和排序，不仅可以减少各分片与客户端之间的数据传输IO，也可以帮助开发者总复杂的数据处理中解放出来，从而专注于开发业务代码。</p><p>在MySQL中存在两种排序方式：一种利用有序索引获取有序数据，另一种通过相应的排序算法将获取到的数据在内存中进行排序。而MyCat中数据排序采用堆排序法对多个分片返回有序数据，并在合并、排序后再返回给客户端。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200129113055429.png" alt="image-20200129113055429" style="zoom:80%;" /> ]]></content>
      
      
      <categories>
          
          <category> MyCat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库中间件 </tag>
            
            <tag> MyCat </tag>
            
            <tag> 高可用集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyCat-分片、性能监控、读写分离</title>
      <link href="2021/07/11/MyCat%E2%80%94%E5%88%86%E7%89%87%E3%80%81%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>2021/07/11/MyCat%E2%80%94%E5%88%86%E7%89%87%E3%80%81%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="MyCat分片"><a href="#MyCat分片" class="headerlink" title="MyCat分片"></a>MyCat分片</h2><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210528141341546.png" alt="image-20210528141341546" style="zoom: 50%;" /> <p>一种是按照不同的表（或者Schema）来切分到不同的数据库（主机）之上，这种切分可以称之为数据的垂直（纵向）切分。</p><h4 id="案例场景"><a href="#案例场景" class="headerlink" title="案例场景"></a>案例场景</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1575725341210.png" alt="1575725341210" style="zoom:80%;" /> <p>在业务系统中，有以下表结构，但是由于用户与订单每天都会产生大量的数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分，原有的数据库表：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1575726526012.png" alt="1575726526012" style="zoom: 80%;" /> <h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>准备三台数据库实例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.192.157</span><br><span class="line">192.168.192.158</span><br><span class="line">192.168.192.159</span><br></pre></td></tr></table></figure><ol start="2"><li>在三台数据库实例中建库建表，即将准备好的三个SQL脚本, 分别导入到三台MySQL实例中 。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523093331110.png" alt="image-20210523093331110"  /><p>   首先上传文件：put ‘’ 上传文件路径 ‘’ ，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put D:/tmp/user.sql</span><br></pre></td></tr></table></figure><p>   之后登录MySQL数据库之后, 使用source命令导入 ：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1575730157557.png" alt="1575730157557" style="zoom:80%;" /> <h4 id="schema-xml的配置"><a href="#schema-xml的配置" class="headerlink" title="schema.xml的配置"></a>schema.xml的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITCAST_DB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_city&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_provinces&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_region&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user_address&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods_base&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods_desc&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;goods_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods_item_cat&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_order_item&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_order_master&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;order_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_order_pay_log&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;out_trade_no&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;user_db&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;goods_db&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;order_db&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.157:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.158:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.159:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="server-xml的配置"><a href="#server-xml的配置" class="headerlink" title="server.xml的配置"></a>server.xml的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST_DB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST_DB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST_DB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ol><li><p>查询数据（重新登录MyCat）</p><ul><li><p>首先查看MyCat逻辑库以及逻辑表是否创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line">use ITCAST_DB;</span><br><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523100857916.png"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523101000454.png" alt="image-20210523101000454"></p></li><li><p>之后在三个数据库节点上分别查询数据是否存在，经过查询可知，三台数据库节点上数据均存在。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_goods_base;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_order_master;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523100436778.png" alt="image-20210523100436778"></p></li></ul></li><li><p>插入数据（直接操作MyCat执行插入）</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> tb_user_address(id,user_id,province_id,city_id,town_id,mobile,address,contact,is_default,notes,create_date,alias) <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="string">&#x27;java00001&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;13900112222&#x27;</span>,<span class="string">&#x27;钟楼&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> tb_order_item(id,item_id,goods_id,order_id,title,price,num,total_fee,pic_path,seller_id) <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="number">19</span>,<span class="number">149187842867954</span>,<span class="number">3</span>,<span class="string">&#x27;3G 6&#x27;</span>,<span class="string">&#x27;1.00&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;5.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;qiandu&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523095853063.png" alt="image-20210523095853063"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523095946558.png" alt="image-20210523095946558"></p><ol start="3"><li>测试跨分片的查询</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id , payment ,receiver, province , city , area <span class="keyword">FROM</span> tb_order_master o , tb_areas_provinces p , tb_areas_city c , tb_areas_region r</span><br><span class="line"><span class="keyword">WHERE</span> o.receiver_province <span class="operator">=</span> p.provinceid <span class="keyword">AND</span> o.receiver_city <span class="operator">=</span> c.cityid <span class="keyword">AND</span> o.receiver_region <span class="operator">=</span> r.areaid ;</span><br></pre></td></tr></table></figure><p>当运行上述的SQL语句时，MyCat会报错，原因是因为当前SQL语句涉及到跨域的join操作，要解决跨库操作就需要将区域表定义为全局表。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523100155075.png" alt="image-20210523100155075"></p><h4 id="全局表配置"><a href="#全局表配置" class="headerlink" title="全局表配置"></a>全局表配置</h4><ol><li>将数据节点user_db中的关联的字典表 tb_areas_provinces，tb_areas_city , tb_areas_region中的数据备份 ：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pitcast user_db tb_areas_provinces  <span class="operator">&gt;</span> provinces;</span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pitcast user_db tb_areas_city <span class="operator">&gt;</span> city;</span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pitcast user_db tb_areas_region <span class="operator">&gt;</span> region;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523100742655.png" alt="image-20210523100742655"></p><ol start="2"><li>将备份的表结构及数据信息，远程同步到其他两个数据节点的数据库中：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scp city root@192.168.192.158:/root</span><br><span class="line">scp city root@192.168.192.159:/root</span><br><span class="line"></span><br><span class="line">scp provinces root@192.168.192.158:/root</span><br><span class="line">scp provinces root@192.168.192.159:/root</span><br><span class="line"></span><br><span class="line">scp region root@192.168.192.158:/root</span><br><span class="line">scp region root@192.168.192.159:/root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523101207804.png" alt="image-20210523101207804"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523101315455.png" alt="image-20210523101315455"></p><ol start="3"><li>在三台节点中分别导入到对应的数据库中：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p goods_db &lt; city</span><br><span class="line">mysql -uroot -p goods_db &lt; provinces </span><br><span class="line">mysql -uroot -p goods_db &lt; region </span><br></pre></td></tr></table></figure><ol start="4"><li>MyCat逻辑表中的配置：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_city&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_provinces&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_region&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>重启MyCat：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/mycat restart</span><br></pre></td></tr></table></figure><ol start="6"><li>测试：再次执行相同的连接查询，是可以正常查询出对应的数据的 ：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id , payment ,receiver, province , city , area <span class="keyword">FROM</span> tb_order_master o , tb_areas_provinces p , tb_areas_city c , tb_areas_region r</span><br><span class="line"><span class="keyword">WHERE</span> o.receiver_province <span class="operator">=</span> p.provinceid <span class="keyword">AND</span> o.receiver_city <span class="operator">=</span> c.cityid <span class="keyword">AND</span> o.receiver_region <span class="operator">=</span> r.areaid ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523101948201.png" alt="image-20210523101948201"></p><p>而当我们对Mycat全局表进行增删改的操作时，其他节点主机上的后端MySQL数据库中的数据是会同步变化的。</p><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称之为数据的水平（横向）切分。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577151764698.png" alt="1577151764698" style="zoom: 67%;" /> <h4 id="案例场景-1"><a href="#案例场景-1" class="headerlink" title="案例场景"></a>案例场景</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577152000136.png" alt="1577152000136" style="zoom: 67%;" /> <p>在业务系统中, 有一张表(日志表), 业务系统每天都会产生大量的日志数据 , 单台服务器的数据存储及处理能力是有限的, 可以对数据库表进行拆分, 原有的数据库表拆分成以下表 : </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577152168606.png" alt="1577152168606" style="zoom: 67%;" /> <h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>准备三台数据库实例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.192.157</span><br><span class="line">192.168.192.158</span><br><span class="line">192.168.192.159</span><br></pre></td></tr></table></figure><ol start="2"><li> 在三台数据库实例中创建数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database log_db <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8;</span><br></pre></td></tr></table></figure><h4 id="schema-xml的配置-1"><a href="#schema-xml的配置-1" class="headerlink" title="schema.xml的配置"></a>schema.xml的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;LOG_DB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_log&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>  <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;log_db&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;log_db&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;log_db&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.157:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.158:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.159:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="server-xml的配置-1"><a href="#server-xml的配置-1" class="headerlink" title="server.xml的配置"></a>server.xml的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>LOG_DB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>LOG_DB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>LOG_DB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><ol><li><p>重启MyCat，查看逻辑表与逻辑库：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523112335350.png" alt="image-20210523112335350"></p></li><li><p>在MyCat数据库中执行建表语句，之后可以在三台数据库节点看到已经生成的tb_log表；</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  `model_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;模块名&#x27;</span>,</span><br><span class="line">  `model_value` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;模块值&#x27;</span>,</span><br><span class="line">  `return_value` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;返回值&#x27;</span>,</span><br><span class="line">  `return_class` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;返回值类型&#x27;</span>,</span><br><span class="line">  `operate_user` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作用户&#x27;</span>,</span><br><span class="line">  `operate_time` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  `param_and_value` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;请求参数名及参数值&#x27;</span>,</span><br><span class="line">  `operate_class` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作类&#x27;</span>,</span><br><span class="line">  `operate_method` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作方法&#x27;</span>,</span><br><span class="line">  `cost_time` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;执行方法耗时, 单位 ms&#x27;</span>,</span><br><span class="line">  `source` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;来源 : 1 PC , 2 Android , 3 IOS&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><ol start="3"><li>MyCat中插入数据，并查询数据：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tb_log` (`id`, `model_name`, `model_value`, `return_value`, `return_class`, `operate_user`, `operate_time`, `param_and_value`, `operate_class`, `operate_method`, `cost_time`，`source`) <span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;insert&#x27;</span>,<span class="string">&#x27;success&#x27;</span>,<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;10001&#x27;</span>,<span class="string">&#x27;2020-02-26 18:12:28&#x27;</span>,<span class="string">&#x27;&#123;\&quot;age\&quot;:\&quot;20\&quot;,\&quot;name\&quot;:\&quot;Tom\&quot;,\&quot;gender\&quot;:\&quot;1\&quot;&#125;&#x27;</span>,<span class="string">&#x27;cn.itcast.controller.UserController&#x27;</span>,<span class="string">&#x27;insert&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tb_log` (`id`, `model_name`, `model_value`, `return_value`, `return_class`, `operate_user`, `operate_time`, `param_and_value`, `operate_class`, `operate_method`, `cost_time`，`source`) <span class="keyword">VALUES</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;insert&#x27;</span>,<span class="string">&#x27;success&#x27;</span>,<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;10001&#x27;</span>,<span class="string">&#x27;2020-02-26 18:12:27&#x27;</span>,<span class="string">&#x27;&#123;\&quot;age\&quot;:\&quot;20\&quot;,\&quot;name\&quot;:\&quot;Tom\&quot;,\&quot;gender\&quot;:\&quot;1\&quot;&#125;&#x27;</span>,<span class="string">&#x27;cn.itcast.controller.UserController&#x27;</span>,<span class="string">&#x27;insert&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tb_log` (`id`, `model_name`, `model_value`, `return_value`, `return_class`, `operate_user`, `operate_time`, `param_and_value`, `operate_class`, `operate_method`, `cost_time`，`source`) <span class="keyword">VALUES</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;update&#x27;</span>,<span class="string">&#x27;success&#x27;</span>,<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;10001&#x27;</span>,<span class="string">&#x27;2020-02-26 18:16:45&#x27;</span>,<span class="string">&#x27;&#123;\&quot;age\&quot;:\&quot;20\&quot;,\&quot;name\&quot;:\&quot;Tom\&quot;,\&quot;gender\&quot;:\&quot;1\&quot;&#125;&#x27;</span>,<span class="string">&#x27;cn.itcast.controller.UserController&#x27;</span>,<span class="string">&#x27;update&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tb_log` (`id`, `model_name`, `model_value`, `return_value`, `return_class`, `operate_user`, `operate_time`, `param_and_value`, `operate_class`, `operate_method`, `cost_time`，`source`) <span class="keyword">VALUES</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;update&#x27;</span>,<span class="string">&#x27;success&#x27;</span>,<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;10001&#x27;</span>,<span class="string">&#x27;2020-02-26 18:16:45&#x27;</span>,<span class="string">&#x27;&#123;\&quot;age\&quot;:\&quot;20\&quot;,\&quot;name\&quot;:\&quot;Tom\&quot;,\&quot;gender\&quot;:\&quot;1\&quot;&#125;&#x27;</span>,<span class="string">&#x27;cn.itcast.controller.UserController&#x27;</span>,<span class="string">&#x27;update&#x27;</span>,<span class="string">&#x27;13&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tb_log` (`id`, `model_name`, `model_value`, `return_value`, `return_class`, `operate_user`, `operate_time`, `param_and_value`, `operate_class`, `operate_method`, `cost_time`，`source`) <span class="keyword">VALUES</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;insert&#x27;</span>,<span class="string">&#x27;success&#x27;</span>,<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;10001&#x27;</span>,<span class="string">&#x27;2020-02-26 18:30:31&#x27;</span>,<span class="string">&#x27;&#123;\&quot;age\&quot;:\&quot;200\&quot;,\&quot;name\&quot;:\&quot;TomCat\&quot;,\&quot;gender\&quot;:\&quot;0\&quot;&#125;&#x27;</span>,<span class="string">&#x27;cn.itcast.controller.UserController&#x27;</span>,<span class="string">&#x27;insert&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tb_log` (`id`, `model_name`, `model_value`, `return_value`, `return_class`, `operate_user`, `operate_time`, `param_and_value`, `operate_class`, `operate_method`, `cost_time`，`source`) <span class="keyword">VALUES</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;find&#x27;</span>,<span class="string">&#x27;success&#x27;</span>,<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;10001&#x27;</span>,<span class="string">&#x27;2020-02-26 18:30:31&#x27;</span>,<span class="string">&#x27;&#123;\&quot;age\&quot;:\&quot;200\&quot;,\&quot;name\&quot;:\&quot;TomCat\&quot;,\&quot;gender\&quot;:\&quot;0\&quot;&#125;&#x27;</span>,<span class="string">&#x27;cn.itcast.controller.UserController&#x27;</span>,<span class="string">&#x27;find&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523112730316.png" alt="image-20210523112730316"></p><ol start="4"><li><p>根据分片规则rule=”mod-long”可知：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523113047041.png" alt="image-20210523113047041" style="zoom: 33%;" /></li></ol><p>在数据库节点157上进行查询：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523113219503.png" alt="image-20210523113219503"></p><h3 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h3><p>MyCat的分片规则配置在conf目录下的rule.xml文件中定义 。</p><p>环境准备 : </p><ol><li>schema.xml中的内容做好备份，并配置逻辑库：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;PARTITION_DB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;partition_db&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;partition_db&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;partition_db&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.157:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.158:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.159:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在MySQL的三个节点的数据库中，创建数据库partition_db：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database partition_db <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br></pre></td></tr></table></figure><blockquote><p>注意：下面对分片规则的测试，每次修改测试都需要重启 MyCat 服务器。</p></blockquote><h4 id="取模分片"><a href="#取模分片" class="headerlink" title="取模分片"></a>取模分片</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置说明 : </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>count</td><td>数据节点的数量</td></tr></tbody></table><h4 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h4><p>根据指定的字段及其配置的范围与数据节点的对应情况， 来决定该数据属于哪一个分片， 配置如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>autopartition-long.txt 配置如下： </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range start-end ,data node index</span></span><br><span class="line"><span class="comment"># K=1000,M=10000.</span></span><br><span class="line"><span class="meta">0-500M</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">500M-1000M</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">1000M-1500M</span>=<span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#含义为 ： 0 - 500 万之间的值 ， 存储在0号数据节点 ； 500万 - 1000万之间的数据存储在1号数据节点 ； 1000万 - 1500 万的数据节点存储在2号节点 。</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>mapFile</td><td>对应的外部配置文件</td></tr><tr><td>type</td><td>默认值为0 ，0 表示Integer , 1 表示String</td></tr><tr><td>defaultNode</td><td>默认节点 <br />默认节点的所用：枚举分片时,如果碰到不识别的枚举值, 就让它路由到默认节点 ; 如果没有默认值,碰到不识别的则报错 。</td></tr></tbody></table><p><strong>测试：</strong></p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_log&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_log` (</span><br><span class="line">  id <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  operateuser <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  operation <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;1: insert, 2: delete, 3: update , 4: select&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_log (id,operateuser ,operation) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_log (id,operateuser ,operation) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_log (id,operateuser ,operation) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Rose&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_log (id,operateuser ,operation) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Coco&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_log (id,operateuser ,operation) <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Lily&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">#上面数据会被插入到<span class="number">157</span>节点上</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_log (id,operateuser ,operation) <span class="keyword">values</span>(<span class="number">5000001</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">#这条数据被插入到<span class="number">158</span>节点上</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_log (id,operateuser ,operation) <span class="keyword">values</span>(<span class="number">10000001</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">#这条数据被插入到<span class="number">159</span>节点上</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_log (id,operateuser ,operation) <span class="keyword">values</span>(<span class="number">15000001</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">#这条数据被插入到<span class="number">157</span>节点上，因为在<span class="number">3</span>个节点上都没查到它的范围，因此默认插入到默认节点<span class="number">157</span>上</span><br></pre></td></tr></table></figure><h4 id="枚举分片"><a href="#枚举分片" class="headerlink" title="枚举分片"></a>枚举分片</h4><p>通过在配置文件中配置可能的枚举值，指定数据分布到不同数据节点上，本规则适用于按照省份或状态拆分数据等业务，配置如下: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-intfile&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>status<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;hash-int&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>partition-hash-int.txt ，内容如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x3D;0</span><br><span class="line">2&#x3D;1</span><br><span class="line">3&#x3D;2</span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>mapFile</td><td>对应的外部配置文件</td></tr><tr><td>type</td><td>默认值为0，0 表示Integer , 1 表示String</td></tr><tr><td>defaultNode</td><td>默认节点；小于0 标识不设置默认节点 , 大于等于0代表设置默认节点 ; <br />默认节点的所用：枚举分片时,如果碰到不识别的枚举值，就让它路由到默认节点；如果没有默认值,碰到不识别的则报错 。</td></tr></tbody></table><p><strong>测试：</strong> </p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-enum-status&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user` (</span><br><span class="line">  id <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  username <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  status <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;1: 未启用, 2: 已启用, 3: 已关闭&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user (id,username ,status) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user (id,username ,status) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user (id,username ,status) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Rose&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user (id,username ,status) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Coco&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user (id,username ,status) <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Lily&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">#status为<span class="number">1</span>插入到第一个节点上，status为<span class="number">2</span>插入到第二个节点上，status为<span class="number">3</span>插入到第三个节点上</span><br><span class="line">#当插入status为<span class="number">4</span>时，找不到对应节点，会被插入到默认节点中</span><br></pre></td></tr></table></figure><h4 id="范围求模算法"><a href="#范围求模算法" class="headerlink" title="范围求模算法"></a>范围求模算法</h4><p>该算法是先进行范围分片, 计算出分片组 , 再进行组内求模。 </p><p><strong>优点</strong>： 综合了范围分片和求模分片的优点。 分片组内使用求模可以保证组内的数据分布比较均匀， 分片组之间采用范围分片可以兼顾范围分片的特点。</p><p><strong>缺点</strong>： 在数据范围是固定值（非递增值）时，存在不方便扩展的情况，例如将 dataNode Group size 从 2 扩展为 4 时，需要进行数据迁移才能完成 ； 如图所示： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200110193319982.png" alt="image-20200110193319982" style="zoom:80%;" /> <p>配置如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-rang-mod&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-mod<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-mod&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByRangeMod&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>autopartition-range-mod.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>autopartition-range-mod.txt 配置格式 :</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#range  start-end , data node group size</span></span><br><span class="line"><span class="meta">0-500M</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">500M1-2000M</span>=<span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在上述配置文件中，等号前面的范围代表一个分片组，等号后面的数字代表该分片组所拥有的分片数量。</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段名</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>mapFile</td><td>对应的外部配置文件</td></tr><tr><td>defaultNode</td><td>默认节点 ; 未包含以上规则的数据存储在defaultNode节点中, 节点从0开</td></tr></tbody></table><p><strong>测试：</strong></p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_stu&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-rang-mod&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建表</span><br><span class="line">   <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_stu` (</span><br><span class="line">     id <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">     username <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">     status <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;1: 未启用, 2: 已启用, 3: 已关闭&#x27;</span>,</span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">   ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 插入数据</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_stu (id,username ,status) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_stu (id,username ,status) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_stu (id,username ,status) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Rose&#x27;</span>,<span class="number">3</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_stu (id,username ,status) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Coco&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_stu (id,username ,status) <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Lily&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">   #上面执行的语句数据存储在第一个节点上（<span class="number">192.168</span><span class="number">.192</span><span class="number">.157</span>）</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_stu (id,username ,status) <span class="keyword">values</span>(<span class="number">5000001</span>,<span class="string">&#x27;Roce&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_stu (id,username ,status) <span class="keyword">values</span>(<span class="number">5000002</span>,<span class="string">&#x27;Jexi&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_stu (id,username ,status) <span class="keyword">values</span>(<span class="number">5000003</span>,<span class="string">&#x27;Mini&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">   #上面的id为<span class="number">5000002</span>的数据由于<span class="number">5000002</span><span class="operator">%</span><span class="number">2</span><span class="operator">=</span><span class="number">0</span>，则存储在第二个节点上（<span class="number">158</span>），而id为<span class="number">5000001</span>和<span class="number">5000003</span>这两条数据（由于            <span class="number">5000001</span>\<span class="number">50000003</span><span class="operator">%</span><span class="number">2</span><span class="operator">=</span><span class="number">1</span>）存储在第三个节点上（<span class="number">159</span>）。</span><br></pre></td></tr></table></figure><h4 id="固定分片hash算法"><a href="#固定分片hash算法" class="headerlink" title="固定分片hash算法"></a>固定分片hash算法</h4><p>该算法类似于十进制的求模运算，但是为二进制的操作，例如，取 id 的二进制低 10 位 与 1111111111 进行位 &amp; 运算。</p><p>最小值：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200112180630348.png" alt="image-20200112180630348"> </p><p>最大值：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200112180643493.png" alt="image-20200112180643493"> </p><p><strong>优点</strong>： 这种策略比较灵活，可以均匀分配也可以非均匀分配，各节点的分配比例和容量大小由partitionCount和partitionLength两个参数决定。</p><p><strong>缺点</strong>：和取模分片类似。</p><p>配置如下 ： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-long-hash&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;func1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.opencloudb.route.function.PartitionByLong&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>2,1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>256,512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#在示例中配置的分片策略，希望将数据水平分成3份，前两份各占 25%，第三份占 50%。</span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段名</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>partitionCount</td><td>分片个数列表</td></tr><tr><td>partitionLength</td><td>分片范围列表</td></tr></tbody></table><p>约束 : </p><ol><li><p>分片长度 : 默认最大2^10 , 为 1024 ;</p></li><li><p>count、length的数组长度必须是一致的 ;</p></li><li><p>两组数据的对应情况: (partitionCount[0]partitionLength[0])=(partitionCount[1]partitionLength[1])；</p></li><li><p>以上分为三个分区：0-255，256-511，512-1023。</p></li></ol><p><strong>测试：</strong></p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_brand&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-long-hash&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建表</span><br><span class="line">   <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_brand` (</span><br><span class="line">     id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">     name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">     firstChar <span class="type">char</span>(<span class="number">1</span>)  COMMENT <span class="string">&#x27;首字母&#x27;</span>,      <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">   ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 插入数据</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_brand (id,name ,firstChar) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;七匹狼&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_brand (id,name ,firstChar) <span class="keyword">values</span>(<span class="number">529</span>,<span class="string">&#x27;八匹狼&#x27;</span>,<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_brand (id,name ,firstChar) <span class="keyword">values</span>(<span class="number">1203</span>,<span class="string">&#x27;九匹狼&#x27;</span>,<span class="string">&#x27;J&#x27;</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_brand (id,name ,firstChar) <span class="keyword">values</span>(<span class="number">1205</span>,<span class="string">&#x27;十匹狼&#x27;</span>,<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_brand (id,name ,firstChar) <span class="keyword">values</span>(<span class="number">1719</span>,<span class="string">&#x27;六匹狼&#x27;</span>,<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">   #通过上面数据的hash值的后十位与 <span class="number">1111111111</span> 进行位 <span class="operator">&amp;</span> 运可知，id为<span class="number">1</span>,<span class="number">1203</span>,<span class="number">1205</span>的数据存储在<span class="number">157</span>节点上，而id为<span class="number">529</span>,<span class="number">1719</span>的数据    存储在<span class="number">159</span>节点上，<span class="number">158</span>节点上没有数据。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="取模范围算法"><a href="#取模范围算法" class="headerlink" title="取模范围算法"></a>取模范围算法</h4><p>该算法先进行取模，然后根据取模值所属范围进行分片。</p><p><strong>优点</strong>：可以自主决定取模后数据的节点分布。</p><p><strong>缺点</strong>：dataNode 划分节点是事先建好的，需要扩展时比较麻烦。</p><p> 配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-pattern&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-pattern<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-pattern&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByPattern&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-pattern.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;patternValue&quot;</span>&gt;</span>96<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>partition-pattern.txt 配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">0-32</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">33-64</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">65-96</span>=<span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在mapFile配置文件中, 1-32即代表id%96后的分布情况。如果在1-32, 则在分片0上 ; 如果在33-64, 则在分片1上 ; 如果在65-96, 则在分片2上。</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>mapFile</td><td>对应的外部配置文件</td></tr><tr><td>defaultNode</td><td>默认节点 ; 如果id不是数字, 无法求模, 将分配在defaultNode上</td></tr><tr><td>patternValue</td><td>求模基数</td></tr></tbody></table><p><strong>测试：</strong></p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_mod_range&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-pattern&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建表</span><br><span class="line">   <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_mod_range` (</span><br><span class="line">     id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">     name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">   ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 插入数据</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_mod_range (id,name) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Test1&#x27;</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_mod_range (id,name) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Test2&#x27;</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_mod_range (id,name) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Test3&#x27;</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_mod_range (id,name) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Test4&#x27;</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_mod_range (id,name) <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Test5&#x27;</span>);</span><br><span class="line">   #上面的数据均存储在第一个节点上（<span class="number">157</span>）</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_mod_range (id,name) <span class="keyword">values</span>(<span class="number">34</span>,<span class="string">&#x27;Test34&#x27;</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_mod_range (id,name) <span class="keyword">values</span>(<span class="number">36</span>,<span class="string">&#x27;Test36&#x27;</span>);</span><br><span class="line">   #上面两条数据（<span class="number">34</span><span class="operator">/</span><span class="number">36</span><span class="operator">%</span><span class="number">96</span>在<span class="number">33</span><span class="number">-64</span>之间）存储在第二个节点上（<span class="number">158</span>）</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> tb_mod_range (id,name) <span class="keyword">values</span>(<span class="number">67</span>,<span class="string">&#x27;Test67&#x27;</span>);</span><br><span class="line">   #上面两条数据（<span class="number">67</span><span class="operator">/</span><span class="number">36</span><span class="operator">%</span><span class="number">96</span>在<span class="number">65</span><span class="number">-96</span>之间）存储在第三个节点上（<span class="number">159</span>）</span><br></pre></td></tr></table></figure><blockquote><p>注意 : 取模范围算法只能针对于数字类型进行取模运算；如果是字符串则无法进行取模分片。</p></blockquote><h4 id="字符串hash求模范围算法"><a href="#字符串hash求模范围算法" class="headerlink" title="字符串hash求模范围算法"></a>字符串hash求模范围算法</h4><p>与取模范围算法类似，该算法支持数值、符号、字母取模，首先截取长度为 prefixLength 的子串，在对子串中每一个字符的 ASCII 码求和，然后对求和值进行取模运算（sum%patternValue），就可以计算出子串的分片数。</p><p><strong>优点</strong>：可以自主决定取模后数据的节点分布。</p><p><strong>缺点</strong>：dataNode 划分节点是事先建好的，需要扩展时比较麻烦。</p><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-prefixpattern&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>username<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-prefixpattern<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-prefixpattern&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByPrefixPattern&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-prefixpattern.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefixLength&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;patternValue&quot;</span>&gt;</span>96<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>partition-prefixpattern.txt 配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range start-end ,data node index</span></span><br><span class="line"><span class="comment"># ASCII</span></span><br><span class="line"><span class="comment"># 48-57=0-9</span></span><br><span class="line"><span class="comment"># 64、65-90=@、A-Z</span></span><br><span class="line"><span class="comment"># 97-122=a-z</span></span><br><span class="line"><span class="comment">###### first host configuration</span></span><br><span class="line"><span class="meta">0-32</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">33-64</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">65-96</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>mapFile</td><td>对应的外部配置文件</td></tr><tr><td>prefixLength</td><td>截取的位数; 将该字段获取前prefixLength位所有ASCII码的和, 进行求模sum%patternValue ,获取的值，在通配范围内的即分片数 。</td></tr><tr><td>patternValue</td><td>求模基数</td></tr></tbody></table><p>如 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">字符串 :</span><br><span class="line">gf89f9a</span><br><span class="line"></span><br><span class="line">截取字符串的前5位进行ASCII的累加运算 : </span><br><span class="line">g - 103</span><br><span class="line">f - 102</span><br><span class="line">8 - 56</span><br><span class="line">9 - 57</span><br><span class="line">f - 102</span><br><span class="line"></span><br><span class="line">    sum求和 : 103 + 102 + + 56 + 57 + 102 &#x3D; 420</span><br><span class="line">    求模 : 420 % 96 &#x3D; 36</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>附录 ASCII码表 : </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577267028771.png" alt="1577267028771"> </p><p><strong>测试：</strong></p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_u&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-prefixpattern&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建表</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_u` (</span><br><span class="line">      username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">      age <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="number">0</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY (`username`)</span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 插入数据</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_u (username,age) <span class="keyword">values</span>(<span class="string">&#x27;Test100001&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_u (username,age) <span class="keyword">values</span>(<span class="string">&#x27;Test200001&#x27;</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_u (username,age) <span class="keyword">values</span>(<span class="string">&#x27;Test300001&#x27;</span>,<span class="number">19</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_u (username,age) <span class="keyword">values</span>(<span class="string">&#x27;Test400001&#x27;</span>,<span class="number">25</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_u (username,age) <span class="keyword">values</span>(<span class="string">&#x27;Test500001&#x27;</span>,<span class="number">22</span>);</span><br><span class="line">    #上面五条记录全部存储在第三个节点中（<span class="number">159</span>）。</span><br></pre></td></tr></table></figure><h4 id="应用指定算法"><a href="#应用指定算法" class="headerlink" title="应用指定算法"></a>应用指定算法</h4><p>由运行阶段由应用自主决定路由到那个分片，直接根据字符子串（必须是数字）计算分片号，配置如下 : </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-substring&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-substring<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-substring&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionDirectBySubString&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;startIndex&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="comment">&lt;!-- zero-based --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultPartition&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>startIndex</td><td>字符子串起始索引</td></tr><tr><td>size</td><td>字符长度</td></tr><tr><td>partitionCount</td><td>分区(分片)数量</td></tr><tr><td>defaultPartition</td><td>默认分片(在分片数量定义时, 字符标示的分片编号不在分片数量内时,使用默认分片)</td></tr></tbody></table><p>示例说明 : </p><p>id=05-100000002，在此配置中代表根据id中从 startIndex=0，开始，截取siz=2位数字即05，05就是获取的分区，如果没传默认分配到defaultPartition 。</p><p><strong>测试：</strong></p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_app&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-substring&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建表</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_app` (</span><br><span class="line">      id <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">      name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_app (id,name) <span class="keyword">values</span>(<span class="string">&#x27;00-00001&#x27;</span>,<span class="string">&#x27;Testx00001&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_app (id,name) <span class="keyword">values</span>(<span class="string">&#x27;01-00001&#x27;</span>,<span class="string">&#x27;Test100001&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_app (id,name) <span class="keyword">values</span>(<span class="string">&#x27;01-00002&#x27;</span>,<span class="string">&#x27;Test200001&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_app (id,name) <span class="keyword">values</span>(<span class="string">&#x27;02-00001&#x27;</span>,<span class="string">&#x27;Test300001&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_app (id,name) <span class="keyword">values</span>(<span class="string">&#x27;02-00002&#x27;</span>,<span class="string">&#x27;TesT400001&#x27;</span>);</span><br><span class="line">    #第一个数据存储在第一个节点（<span class="number">157</span>），第二、三个数据存储在第二个节点（<span class="number">158</span>），第四、五个数据存储在第三个节点（<span class="number">159</span>）。</span><br></pre></td></tr></table></figure><h4 id="字符串hash解析算法"><a href="#字符串hash解析算法" class="headerlink" title="字符串hash解析算法"></a>字符串hash解析算法</h4><p>截取字符串中的指定位置的子字符串, 进行hash算法， 算出分片 ， 配置如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-stringhash&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>name<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-stringhash<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-stringhash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByString&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="comment">&lt;!-- zero-based --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashSlice&quot;</span>&gt;</span>0:2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>partitionLength</td><td>hash求模基数 ; length*count=1024 (出于性能考虑)</td></tr><tr><td>partitionCount</td><td>分区数</td></tr><tr><td>hashSlice</td><td>hash运算位 , 根据子字符串的hash运算 ; 0 代表 str.length() , -1 代表 str.length()-1 , 大于0只代表数字自身 ; 可以理解为substring（start，end），start为0则只表示0。</td></tr></tbody></table><p><strong>测试：</strong></p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_strhash&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-stringhash&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_strhash(</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">primary</span> key,</span><br><span class="line">content <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">)engine<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_strhash (name,content) <span class="keyword">VALUES</span>(<span class="string">&#x27;T1001&#x27;</span>, UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_strhash (name,content) <span class="keyword">VALUES</span>(<span class="string">&#x27;ROSE&#x27;</span>, UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_strhash (name,content) <span class="keyword">VALUES</span>(<span class="string">&#x27;JERRY&#x27;</span>, UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_strhash (name,content) <span class="keyword">VALUES</span>(<span class="string">&#x27;CRISTINA&#x27;</span>, UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_strhash (name,content) <span class="keyword">VALUES</span>(<span class="string">&#x27;TOMCAT&#x27;</span>, UUID());</span><br><span class="line">#第三、四个数据存储在第一个节点，其他三条数据存储在第二个节点中。</span><br></pre></td></tr></table></figure><p>原理: </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200112234530612.png" alt="image-20200112234530612"> </p><h4 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h4><p>一致性hash算法有效的解决了分布式数据的扩容问题 , 配置如下: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-murmur&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>murmur<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;murmur&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMurmurHash&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;seed&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;virtualBucketTimes&quot;</span>&gt;</span>160<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name=&quot;weightMapFile&quot;&gt;weightMapFile&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name=&quot;bucketMapPath&quot;&gt;/etc/mycat/bucketMapPath&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>seed</td><td>创建murmur_hash对象的种子，默认0</td></tr><tr><td>count</td><td>要分片的数据库节点数量，必须指定，否则没法分片</td></tr><tr><td>virtualBucketTimes</td><td>一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍;virtualBucketTimes*count就是虚拟结点数量 ;</td></tr><tr><td>weightMapFile</td><td>节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替</td></tr><tr><td>bucketMapPath</td><td>用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西</td></tr></tbody></table><p><strong>测试：</strong></p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_order&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-murmur&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_order(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">primary</span> key,</span><br><span class="line">money <span class="type">int</span>(<span class="number">11</span>),</span><br><span class="line">content <span class="type">varchar</span>(<span class="number">200</span>)</span><br><span class="line">)engine<span class="operator">=</span>InnoDB ;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">212</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">312</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">412</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">534</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">621</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">754563</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">8123</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">91213</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">23232</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">112321</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">21221</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">112132</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">12132</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">124321</span>, <span class="number">100</span> , UUID());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_order (id,money,content) <span class="keyword">VALUES</span>(<span class="number">212132</span>, <span class="number">100</span> , UUID());</span><br><span class="line">#在大数据情况下，数据会被均匀的分配到各个节点。</span><br></pre></td></tr></table></figure><h4 id="日期分片算法"><a href="#日期分片算法" class="headerlink" title="日期分片算法"></a>日期分片算法</h4><p>按照日期来分片：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-date&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-date<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-date&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByDate&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2020-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sEndDate&quot;</span>&gt;</span>2021-12-31<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置说明： </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>dateFormat</td><td>日期格式</td></tr><tr><td>sBeginDate</td><td>开始日期</td></tr><tr><td>sEndDate</td><td>结束日期，如果配置了结束日期，则代码数据到达了这个日期的分片后，会重复从开始分片插入</td></tr><tr><td>sPartionDay</td><td>分区天数，默认值 10 ，从开始日期算起，每个10天一个分区</td></tr></tbody></table><p>注意：配置规则的表的 dataNode 的分片，必须和分片规则数量一致，例如 2021-01-01 到 2021-12-31 ，每10天一个分片，一共需要37个分片。</p><h4 id="单月小时算法"><a href="#单月小时算法" class="headerlink" title="单月小时算法"></a>单月小时算法</h4><p>单月内按照小时拆分，最小粒度是小时，一天最多可以有24个分片，最小1个分片，下个月从头开始循环，每个月末需要手动清理数据。</p><p>配置如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-hour&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-hour<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-hour&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.LatestMonthPartion&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;splitOneDay&quot;</span>&gt;</span>24<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置说明： </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段 ； 字符串类型（yyyymmddHH）， 需要符合JAVA标准</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>splitOneDay</td><td>一天切分的分片数</td></tr></tbody></table><h4 id="自然月分片算法"><a href="#自然月分片算法" class="headerlink" title="自然月分片算法"></a>自然月分片算法</h4><p>使用场景为按照月份列分区，每个自然月为一个分片，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-month&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-month<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-month&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMonth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2021-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sEndDate&quot;</span>&gt;</span>2021-12-31<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>dateFormat</td><td>日期格式</td></tr><tr><td>sBeginDate</td><td>开始日期</td></tr><tr><td>sEndDate</td><td>结束日期，如果配置了结束日期，则代码数据到达了这个日期的分片后，会重复从开始分片插入</td></tr></tbody></table><h4 id="日期范围hash算法"><a href="#日期范围hash算法" class="headerlink" title="日期范围hash算法"></a>日期范围hash算法</h4><p>其思想和范围求模分片一样，先根据日期进行范围分片求出分片组，再根据时间hash使得短期内数据分布的更均匀。</p><p><strong>优点</strong> : 可以避免扩容时的数据迁移，又可以一定程度上避免范围分片的热点问题。</p><p><strong>注意</strong> : 要求日期格式尽量精确些，不然达不到局部均匀的目的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;range-date-hash&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>range-date-hash<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;range-date-hash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByRangeDateHash&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2021-01-01 00:00:00<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;groupPartionSize&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>columns</td><td>标识将要分片的表字段</td></tr><tr><td>algorithm</td><td>指定分片函数与function的对应关系</td></tr><tr><td>class</td><td>指定该分片算法对应的类</td></tr><tr><td>dateFormat</td><td>日期格式 , 符合Java标准</td></tr><tr><td>sBeginDate</td><td>开始日期 , 与 dateFormat指定的格式一致</td></tr><tr><td>groupPartionSize</td><td>每组的分片数量</td></tr><tr><td>sPartionDay</td><td>代表多少天为一组</td></tr></tbody></table><h2 id="MyCat高级"><a href="#MyCat高级" class="headerlink" title="MyCat高级"></a>MyCat高级</h2><h3 id="MyCat-性能监控"><a href="#MyCat-性能监控" class="headerlink" title="MyCat 性能监控"></a>MyCat 性能监控</h3><h4 id="MyCat-web简介"><a href="#MyCat-web简介" class="headerlink" title="MyCat-web简介"></a>MyCat-web简介</h4><p>Mycat-web 是 Mycat 可视化运维的管理和监控平台，弥补了 Mycat 在监控上的空白，帮 Mycat 分担统计任务和配置管理任务。Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节点。Mycat-web 主要管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等。为优化 SQL 提供依据。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577358192118.png" alt="1577358192118" style="zoom:80%;" /> <h4 id="MyCat-web下载"><a href="#MyCat-web下载" class="headerlink" title="MyCat-web下载"></a>MyCat-web下载</h4><p>下载地址 : <a href="http://dl.mycat.io/">http://dl.mycat.io/</a></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577369790112.png" alt="1577369790112"> </p><h4 id="Mycat-web安装配置"><a href="#Mycat-web安装配置" class="headerlink" title="Mycat-web安装配置"></a>Mycat-web安装配置</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ol><li>安装Zookeeper</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A. 上传安装包 </span><br><span class="line">alt + p -----&gt; put D:\tmp\zookeeper-3.4.11.tar.gz</span><br><span class="line"></span><br><span class="line">B. 解压</span><br><span class="line">tar -zxvf zookeeper-3.4.11.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">C. 创建数据存放目录</span><br><span class="line">mkdir data</span><br><span class="line"></span><br><span class="line">D. 修改配置文件名称并配置</span><br><span class="line">mv zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line">E. 配置数据存放目录</span><br><span class="line">dataDir=/usr/local/zookeeper-3.4.11/data</span><br><span class="line"></span><br><span class="line">F. 启动Zookeeper</span><br><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure><ol start="2"><li>安装Mycat-web</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A. 上传安装包 </span><br><span class="line">alt + p --------&gt; put D:\tmp\Mycat-web-1.0-SNAPSHOT-20170102153329-linux.tar.gz</span><br><span class="line"></span><br><span class="line">B. 解压</span><br><span class="line">tar -zxvf Mycat-web-1.0-SNAPSHOT-20170102153329-linux.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"></span><br><span class="line">C. 目录介绍</span><br><span class="line">    drwxr-xr-x. 2 root root  4096 Oct 19  2015 etc         ----&gt; jetty配置文件</span><br><span class="line">    drwxr-xr-x. 3 root root  4096 Oct 19  2015 lib         ----&gt; 依赖jar包</span><br><span class="line">    drwxr-xr-x. 7 root root  4096 Jan  1  2017 mycat-web   ----&gt; mycat-web项目</span><br><span class="line">    -rwxr-xr-x. 1 root root   116 Oct 19  2015 readme.txt</span><br><span class="line">    -rwxr-xr-x. 1 root root 17125 Oct 19  2015 start.jar   ----&gt; 启动jar</span><br><span class="line">    -rwxr-xr-x. 1 root root   381 Oct 19  2015 start.sh    ----&gt; linux启动脚本</span><br><span class="line"></span><br><span class="line">D. 启动</span><br><span class="line">sh start.sh</span><br><span class="line"></span><br><span class="line">E. 访问</span><br><span class="line">http:&#x2F;&#x2F;192.168.192.147:8082&#x2F;mycat</span><br></pre></td></tr></table></figure><p>如果Zookeeper与Mycat-web不在同一台服务器上，需要设置Zookeeper的地址，在/usr/local/mycat-web/mycat-web/WEB-INF/classes/mycat.properties文件中配置：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577370960657.png" alt="1577370960657"> </p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529204135052.png" alt="image-20210529204135052" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529204251314.png" alt="image-20210529204251314"> </p><h4 id="Mycat-web之MyCat性能监控"><a href="#Mycat-web之MyCat性能监控" class="headerlink" title="Mycat-web之MyCat性能监控"></a>Mycat-web之MyCat性能监控</h4><p>在 Mycat-web 上可以进行 Mycat 性能监控，例如：内存分析、流量分析、连接分析、活动线程分析等等。 如下图：</p><ol><li>MyCat内存分析：MyCat的内存分析，反映了当前的内存使用情况与历史时间段的峰值、平均值。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529204428768.png" alt="image-20210529204428768">  </p><ol start="2"><li>MyCat流量分析：MyCat流量分析统计了历史时间段的流量峰值、当前值、平均值，是MyCat数据传输的重要指标， In代表输入， Out代表输出。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577373861622.png" alt="1577373861622"> </p><ol start="3"><li>MyCat连接分析：MyCat连接分析，反映了MyCat的连接数 。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577374030291.png" alt="1577374030291"> </p><ol start="4"><li>MyCat TPS分析：MyCat TPS 是并发性能的重要参数指标，指系统在每秒内能够处理的请求数量。 MyCat TPS的值越高，代表MyCat单位时间内能够处理的请求就越多，并发能力也就越高。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577374126073.png" alt="1577374126073"> </p><ol start="5"><li><p>MyCat活动线程分析反映了MyCat线程的活动情况。</p></li><li><p>MyCat缓存队列分析，反映了当前在缓存队列中的任务数量。</p></li></ol><h4 id="Mycat-web之MySQL性能监控指标"><a href="#Mycat-web之MySQL性能监控指标" class="headerlink" title="Mycat-web之MySQL性能监控指标"></a>Mycat-web之MySQL性能监控指标</h4><ol><li>MySQL配置</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529204711577.png" alt="image-20210529204711577"> </p><ol start="2"><li>MySQL监控指标：可以通过MySQL服务监控检测每一个MySQL节点的运行状态，包含缓存命中率 、增删改查比例、流量统计、慢查询比例、线程、临时表等相关性能数据。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577374588708.png" alt="1577374588708"> </p><h4 id="Mycat-web之SQL监控"><a href="#Mycat-web之SQL监控" class="headerlink" title="Mycat-web之SQL监控"></a>Mycat-web之SQL监控</h4><ol><li>SQL 统计</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577374982024.png" alt="1577374982024"> </p><ol start="2"><li>SQL表分析</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577375016852.png" alt="1577375016852"> </p><ol start="3"><li>SQL监控</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577375043787.png" alt="1577375043787">  </p><ol start="4"><li>高频SQL</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577375072881.png" alt="1577375072881"> </p><ol start="5"><li>慢SQL统计</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577375100383.png" alt="1577375100383"> </p><ol start="6"><li>SQL解析</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577375162928.png" alt="1577375162928"> </p><h3 id="MyCat-读写分离"><a href="#MyCat-读写分离" class="headerlink" title="MyCat 读写分离"></a>MyCat 读写分离</h3><h4 id="MySQL主从复制原理"><a href="#MySQL主从复制原理" class="headerlink" title="MySQL主从复制原理"></a>MySQL主从复制原理</h4><p>复制是指将主数据库的DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</p><p>MySQL主从复制的原理如下 : </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200103093716416.png" alt="image-20200103093716416"> </p><p>从上图来看，复制分成三步：</p><ul><li><p>Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中；</p></li><li><p>主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log ；</p></li><li><p>slave重做中继日志中的事件，将改变反映它自己的数据。</p></li></ul><p>MySQL 复制的优点：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库的服务。</li></ul><h4 id="MySQL一主一从搭建"><a href="#MySQL一主一从搭建" class="headerlink" title="MySQL一主一从搭建"></a>MySQL一主一从搭建</h4><p>准备的两台机器: </p><table><thead><tr><th>MySQL</th><th>IP</th><th>端口号</th></tr></thead><tbody><tr><td>Master</td><td>192.168.192.157</td><td>3306</td></tr><tr><td>Slave</td><td>192.168.192.158</td><td>3306</td></tr></tbody></table><h5 id="master"><a href="#master" class="headerlink" title="master"></a>master</h5><ol><li>在master 的配置文件（/usr/my.cnf）中，配置如下内容：</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql 服务ID,保证整个集群环境中唯一</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql binlog 日志的存储路径和文件名</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">/var/lib/mysql/mysqlbin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否只读,1 代表只读, 0 代表读写</span></span><br><span class="line"><span class="meta">read-only</span>=<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#忽略的数据, 指不需要同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-ignore-db=mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定同步的数据库</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db01</span></span><br></pre></td></tr></table></figure><ol start="2"><li>执行完毕之后，需要重启MySQL：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart ;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建同步数据的账户，因为MySQL进行主从复制的时候需要一个同步账户（Salve节点通过这个同步账户读取Master节点上的二进制日志），并且进行授权操作：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;192.168.192.158&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><ol start="4"><li>查看master状态：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200103102209631.png" alt="image-20200103102209631"> </p><p>字段含义:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File : 从哪个日志文件开始推送日志文件 </span><br><span class="line">Position ： 从哪个位置开始推送日志</span><br><span class="line">Binlog_Ignore_DB : 指定不需要同步的数据库</span><br></pre></td></tr></table></figure><h5 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h5><ol><li>在MySQL集群的slave节点配置文件/usr/my.cnf中，配置如下内容：</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql服务端ID,唯一</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定binlog日志</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">/var/lib/mysql/mysqlbin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line"><span class="meta">relay-log</span>=<span class="string">mysql-relay</span></span><br></pre></td></tr></table></figure><ol start="2"><li>执行完毕之后，需要重启MySQL：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart;</span><br></pre></td></tr></table></figure><ol start="3"><li>执行如下指令 ：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。</span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span> <span class="string">&#x27;192.168.192.157&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>, master_log_file<span class="operator">=</span><span class="string">&#x27;mysqlbin.000001&#x27;</span>, master_log_pos<span class="operator">=</span><span class="number">413</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>开启同步操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> slave status;</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200103144903105.png" alt="image-20200103144903105">  </p><ol start="5"><li>停止同步操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure><h5 id="验证主从同步"><a href="#验证主从同步" class="headerlink" title="验证主从同步"></a>验证主从同步</h5><ol><li>在主库中创建数据库，创建表，并插入数据 ：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">user</span> db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">primary</span> key (id)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>在从库中查询数据，进行验证 ：</p><ul><li><p>在从库中，可以查看到刚才创建的数据库：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200103103029311.png"></p></li><li><p>在该数据库中，查询user表中的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200103103049675.png" alt="image-20200103103049675"></p></li></ul></li></ol><h4 id="MyCat一主一从读写分离"><a href="#MyCat一主一从读写分离" class="headerlink" title="MyCat一主一从读写分离"></a>MyCat一主一从读写分离</h4><h5 id="读写分离原理"><a href="#读写分离原理" class="headerlink" title="读写分离原理"></a>读写分离原理</h5><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200103140249789.png" alt="image-20200103140249789"> </p><p>读写分离：简单地说是把对数据库的读和写操作分开，以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</p><p>通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。MyCat控制后台数据库的读写分离，负载均衡由schema.xml文件datahost标签的balance属性控制。</p><h5 id="读写分离配置"><a href="#读写分离配置" class="headerlink" title="读写分离配置"></a>读写分离配置</h5><p>配置如下： </p><ul><li><p>检查MySQL的主从复制是否运行正常 ；</p></li><li><p>修改MyCat 的conf/schema.xml 配置如下:</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.157:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.158:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改conf/server.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>配置完毕之后，重启MyCat服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/mycat start</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">属性含义说明:</span><br><span class="line"></span><br><span class="line">checkSQLschema</span><br><span class="line">当该值设置为true时, 如果我们执行语句&quot;select * from test01.user ;&quot; 语句时, MyCat则会把schema字符去掉 , 可以避免后端数据库执行时报错 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">balance</span><br><span class="line">负载均衡类型, 目前取值有4种:</span><br><span class="line"></span><br><span class="line">balance&#x3D;&quot;0&quot; : 不开启读写分离机制 , 所有读操作都发送到当前可用的writeHost上.</span><br><span class="line"></span><br><span class="line">balance&#x3D;&quot;1&quot; : 全部的readHost 与 stand by writeHost (备用的writeHost) 都参与select 语句的负载均衡,简而言之,就是采用双主双从模式(M1 --&gt; S1 , M2 --&gt; S2, 正常情况下，M2,S1,S2 都参与 select 语句的负载均衡。);</span><br><span class="line">    </span><br><span class="line">    balance&#x3D;&quot;2&quot; : 所有的读写操作都随机在writeHost , readHost上分发</span><br><span class="line">    </span><br><span class="line">    balance&#x3D;&quot;3&quot; : 所有的读请求随机分发到writeHost对应的readHost上执行, writeHost不负担读压力 ;balance&#x3D;3 只在MyCat1.4 之后生效 .</span><br></pre></td></tr></table></figure><h5 id="验证读写分离"><a href="#验证读写分离" class="headerlink" title="验证读写分离"></a>验证读写分离</h5><p>当balance的值为默认值0时，查询MyCat中的逻辑表的数据变化：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance=&quot;0&quot;</span><br></pre></td></tr></table></figure><p>在MyCat上执行下面查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>；</span><br></pre></td></tr></table></figure><p>通过日志信息发现，查询操作在主节点上执行：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529205519221.png" alt="image-20210529205519221"></p><p>将原来balance的默认值0修改为1，并重启MyCat，查询MyCat中的逻辑表的数据变化：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance=&quot;1&quot;</span><br></pre></td></tr></table></figure><p>在MyCat上执行查询操作，通过日志信息发现，查询操作在从节点上执行：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529205536395.png" alt="image-20210529205536395"></p><p>之后在MyCat上执行下面的插入操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Cat2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210529205549932.png" alt="image-20210529205549932"></p><blockquote><p>结论：当设置balance=1时，所有的读请求在从节点上，而插入、更新等操作走主节点。</p></blockquote><h4 id="MySQL双主双从搭建"><a href="#MySQL双主双从搭建" class="headerlink" title="MySQL双主双从搭建"></a>MySQL双主双从搭建</h4><h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><p>一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1 、Master2 互为备机。架构图如下: </p><p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200103170452653.png" alt="image-20200103170452653"> </p><h5 id="双主双从配置"><a href="#双主双从配置" class="headerlink" title="双主双从配置"></a>双主双从配置</h5><p>准备的机器如下：</p><table><thead><tr><th>编号</th><th>角色</th><th>IP地址</th><th>端口号</th></tr></thead><tbody><tr><td>1</td><td>Master1</td><td>192.168.192.157</td><td>3306</td></tr><tr><td>2</td><td>Slave1</td><td>192.168.192.158</td><td>3306</td></tr><tr><td>3</td><td>Master2</td><td>192.168.192.159</td><td>3306</td></tr><tr><td>4</td><td>Slave2</td><td>192.168.192.160</td><td>3306</td></tr></tbody></table><p>首先需要断掉之前的主从关系，执行下面两条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop salve;</span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure><p><strong>1. 双主机配置</strong></p><ul><li>Master1配置：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">mysql-bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line"><span class="comment"># binlog-ignore-db=mysql</span></span><br><span class="line"><span class="comment"># binlog-ignore-db=information_schema</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db02</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db03</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db04</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line"><span class="attr">log-slave-updates</span></span><br></pre></td></tr></table></figure><ul><li>Master2配置：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">mysql-bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line"><span class="comment">#binlog-ignore-db=mysql</span></span><br><span class="line"><span class="comment">#binlog-ignore-db=information_schema</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db02</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db03</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">db04</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line"><span class="attr">log-slave-updates</span></span><br></pre></td></tr></table></figure><p><strong>2. 双从机配置</strong></p><ul><li>Slave1配置：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line"><span class="meta">relay-log</span>=<span class="string">mysql-relay</span></span><br></pre></td></tr></table></figure><ul><li>Salve2配置：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line"><span class="meta">relay-log</span>=<span class="string">mysql-relay</span></span><br></pre></td></tr></table></figure><p><strong>3. 双主机、双从机重启 mysql 服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><p><strong>4. 主机从机都关闭防火墙</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><p><strong>5. 在两台主机上建立帐户并授权 slave</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在主机MySQL里执行授权命令</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>查询Master1的状态 : </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104090901765.png" alt="image-20200104090901765"> </p><p>查询Master2的状态 :</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104090922386.png" alt="image-20200104090922386"> </p><p><strong>6. 在从机上配置需要复制的主机：Slave1 复制 Master1，Slave2 复制 Master2。</strong></p><p>slave1 指令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.192.157&#x27;</span>,</span><br><span class="line">MASTER_USER<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>,</span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span><span class="number">399</span>;</span><br></pre></td></tr></table></figure><p>slave2 指令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.192.159&#x27;</span>,</span><br><span class="line">MASTER_USER<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>,</span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span><span class="number">399</span>;</span><br></pre></td></tr></table></figure><p><strong>7. 启动两台从服务器复制功能 , 查看主从复制的运行状态：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> slave status\G;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104091917814.png" alt="image-20200104091917814"> </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104091948213.png" alt="image-20200104091948213"> </p><p><strong>8. 两个主机互相复制：Master2 复制 Master1，Master1 复制 Master2。</strong></p><p>Master1 执行指令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.192.159&#x27;</span>,</span><br><span class="line">MASTER_USER<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>,</span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span><span class="number">399</span>;</span><br></pre></td></tr></table></figure><p>Master2 执行指令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.192.157&#x27;</span>,</span><br><span class="line">MASTER_USER<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>,</span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span><span class="number">399</span>;</span><br></pre></td></tr></table></figure><p><strong>9. 启动两台主服务器复制功能 , 查看主从复制的运行状态：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> slave status\G;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104092654432.png" alt="image-20200104092654432"> </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104092741892.png" alt="image-20200104092741892"> </p><p><strong>10. 验证</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db03;</span><br><span class="line"></span><br><span class="line">use db03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">primary</span> key (id)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">#上面三条语句在<span class="number">157</span>节点上执行，通过查询各个节点数据可知，上面的数据信息，全部同步到<span class="number">158</span><span class="operator">/</span><span class="number">159</span><span class="operator">/</span><span class="number">160</span>三个节点上。</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Jack Ma&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Coco&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">#而这里的上面三条的插入语句在<span class="number">159</span>节点上执行，通过查询各个节点数据可知，上面的数据信息，也全部同步到<span class="number">157</span><span class="operator">/</span><span class="number">158</span><span class="operator">/</span><span class="number">160</span>三个节点上。</span><br></pre></td></tr></table></figure><p>在Master1上创建数据库：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104095232047.png" alt="image-20200104095232047"> </p><p>在Master1上创建表 :</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104095521070.png" alt="image-20200104095521070"> </p><p><strong>11. 停止从服务复制功能</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure><p><strong>12. 重新配置主从关系</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure><h4 id="MyCat双主双从读写分离"><a href="#MyCat双主双从读写分离" class="headerlink" title="MyCat双主双从读写分离"></a>MyCat双主双从读写分离</h4><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><p>修改&lt;dataHost&gt;的 balance属性，通过此属性配置读写分离的类型 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db03&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.157:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;itcast&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.158:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.159:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;itcast&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.160:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>writeType：</p><ul><li><p>0 : 写操作都转发到第1台writeHost, writeHost1，挂了会切换到writeHost2上；</p></li><li><p>1 : 所有的写操作都随机地发送到配置的writeHost上 。</p></li></ul><p>switchType：</p><ul><li><p>1：不自动切换；</p></li><li><p>1：默认值，自动切换；</p></li><li><p>2：表示基于MySQL的主从同步状态决定是否切换，心跳语句 : show slave status。</p></li></ul><h5 id="读写分离验证"><a href="#读写分离验证" class="headerlink" title="读写分离验证"></a>读写分离验证</h5><p>查询数据 : select * from user;</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104101106144.png" alt="image-20200104101106144"> </p><p>插入数据 : insert into user(id,name,sex) values(null,’Dawn’,’1’);</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20200104100956216.png" alt="image-20200104100956216"> </p><h5 id="可用性验证"><a href="#可用性验证" class="headerlink" title="可用性验证"></a>可用性验证</h5><p>关闭Master1，然后再执行写入的SQL语句 , 通过日志查询当前写入操作可知，写操作切换到Master2节点上。</p>]]></content>
      
      
      <categories>
          
          <category> MyCat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库中间件 </tag>
            
            <tag> MyCat </tag>
            
            <tag> 读写分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyCat-简介、入门、配置文件详解</title>
      <link href="2021/07/05/MyCat%E2%80%94%E7%AE%80%E4%BB%8B%E3%80%81%E5%85%A5%E9%97%A8%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/07/05/MyCat%E2%80%94%E7%AE%80%E4%BB%8B%E3%80%81%E5%85%A5%E9%97%A8%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="MyCat简介"><a href="#MyCat简介" class="headerlink" title="MyCat简介"></a>MyCat简介</h2><h3 id="MyCat-引入"><a href="#MyCat-引入" class="headerlink" title="MyCat 引入"></a>MyCat 引入</h3><p> 如今随着互联网的发展，数据的量级也是成指数式的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系性数据库已经无法满足快速查询与插入数据的需求,这个时候NoSQL的出现暂时解决了这一危机。它通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升。但是，在有些场合时NoSQL一些折衷是无法满足使用场景的，就比如有些使用场景是绝对要有事务与安全指标的。这个时候NoSQL肯定是无法满足的，所以还是需要使用关系性数据库。如何使用关系型数据库解决海量存储的问题呢？此时就需要做数据库集群，为了提高查询性能将一个数据库的数据分散到不同的数据库中存储，为应对此问题就出现了—MyCat 。</p><p>MyCAT的目标是：低成本的将现有的单机数据库和应用平滑迁移到”云”端，解决海量数据存储和业务规模迅速增长情况下的数据存储和访问的瓶颈问题 。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1575902332595.png" alt="1575902332595" style="zoom:67%;" />   <h3 id="MyCat-历史"><a href="#MyCat-历史" class="headerlink" title="MyCat 历史"></a>MyCat 历史</h3><ol><li><p>MyCat背后是阿里曾经开源的知名产品—Cobar。Cobar的核心功能和优势是MySQL数据库分片，此产品曾经广为流传，据说最早的发起者对MySQL很精通，后来从阿里跳槽了，阿里随后开源的Cobar，并维持到 2013 年年初，然后，就没有然后了。 Cobar的思路和实现路径的确不错。基于java开发的，实现了MySQL公开的二进制传输协议，巧妙地将自己伪装成一个MySQL Server，目前市面上绝大多数MySQL客户端工具和应用都能兼容。比自己实现一个新的数据库协议要明智的多，因为生态环境在哪里摆着。 </p></li><li><p>MyCat是基于cobar演变而来，相对于cobar来说 , 有两个显著优势 : ①. 对cobar的代码进行了彻底的重构，MyCat在I/O方面进行了重大改进,将原来的BIO改成了NIO, 并发量有大幅提高 ;  ②. 增加了对Order By、Group By、limit等聚合功能的支持，同时兼容绝大多数数据库成为通用的数据库中间件 。</p></li><li><p>简单的说，MyCat就是：一个新颖的数据库中间件产品支持MySQL集群，或者MariaDB cluster，提供高可用性数据分片集群。你可以像使用MySQL一样使用Mycat。对于开发人员来说根本感觉不到MyCat的存在。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1571824365101.png" alt="1571824365101"></p><h3 id="MyCat-优势"><a href="#MyCat-优势" class="headerlink" title="MyCat 优势"></a>MyCat 优势</h3><p>MyCat是一个彻底开源的，面向企业应用数据库中间件 , 支持事务， 可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群, 在MyCat中融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server , 并结合传统数据库和新型分布式数据仓库的新一代企业级数据库中间件产品 。</p><p><strong>优势：</strong> </p><p><strong>1).  性能可靠稳定</strong></p><p>基于阿里开源的Cobar产品而研发，Cobar的稳定性、可靠性、优秀的架构和性能以及众多成熟的使用案例使得Mycat一开始就拥有一个很好的起点，站在巨人的肩膀上，能看到更远。业界优秀的开源项目和创新思路被广泛融入到Mycat的基因中，使得Mycat在很多方面都领先于目前其他一些同类的开源项目，甚至超越某些商业产品。</p><p><strong>2).  强大的技术团队</strong></p><p>MyCat现在由一支强大的技术团队维护 , 吸引和聚集了一大批业内大数据和云计算方面的资深工程师、架构师、DBA，优秀的团队保障了MyCat的稳定高效运行。而且MyCat不依托于任何商业公司，而且得到大批开源爱好者的支持。</p><p><strong>3).  体系完善</strong></p><p>MyCat已经形成了一系列的周边产品，比较有名的是 MyCat-web、MyCat-NIO、MyCat-Balance等，已经形成了一个比较完整的解决方案，而不仅仅是一个中间件。</p><p><strong>4).  社区活跃</strong></p><p>与MyCat数据库中间件类似的产品还有TDDL、Amoeba、Cobar 。</p><ol><li><p>TDDL（Taobao Distributed Data Layer）不同于其它几款产品，并非独立的中间件，只能算作中间层，是以jar包方式提供给应用调用 ，属于JDBC Shard的思想 。</p></li><li><p>Amoeba是作为一个真正的独立中间件提供服务,应用去连接Amoeba操作MySQL集群，就像操作单个MySQL一样。Amoeba算中间件中的早期产品,后端还在使用JDBC Driver。</p></li><li><p>Cobar是在Amoeba基础上进化的版本，一个显著变化是把后端JDBC Driver改为原生的MySQL通信协议层。</p></li><li><p>MyCat又是在Cobar基础上发展的版本, 性能优良, 功能强大, 社区活跃 。</p></li></ol><h3 id="MyCat-使用场合"><a href="#MyCat-使用场合" class="headerlink" title="MyCat 使用场合"></a>MyCat 使用场合</h3><p>要想用好MyCat，就需要了解其适用场景，以下几个场景适合适用MyCat：</p><p><strong>1).  高可用性与MySQL读写分离</strong></p><p>高可用：利用MyCat可以轻松实现热备份，当一台服务器停机时，可以由集群中的另一台服务器自动接管业务，无需人工干预，从而保证高可用。</p><p>读写分离：通过MySQL数据库的binlog日志完成主从复制，并可以通过MyCat轻松实现读写分离，实现insert、update、delete走主库，而在select时走从库，从而缓解单台服务器的访问压力。</p><p><strong>2).  业务数据分级存储保障</strong></p><p>企业的数据量总是无休止的增长，这些数据的格式不一样，访问效率不一样，重要性也不一样。可以针对不同级别的数据，采用不同的存储设备，通过分级存储管理软件实现数据客体在存储设备之间自动迁移及自动访问切换。</p><p><strong>3).  大表水平拆分，集群并行计算</strong></p><p>数据切分是MyCat的核心功能，是指通过某种特定的条件，将存放在同一个数据库的数据，分散存储在多个数据库中，以达到分散单台设备负载的效果。当数据库量超过800万行且需要做分片时，就可以考虑使用MyCat实现数据切分。</p><p><strong>4).  数据库路由器</strong></p><p>MyCat基于MySQL实例的连接池复用机制，可以让每个应用最大程度共享一个MySQL实例的所有连接池，让数据库的并发访问能力大大提升。</p><p><strong>5).  整合多种数据源</strong></p><p>当一个项目中使用了多个数据库（Oracle，MySQL，SQL Server,PostgreSQL），并配置了多个数据源，操作起来就比较烦锁，这时就可以使用MyCat进行整合，最终我们的应用程序只需要访问一个数据源即可。</p><h3 id="MyCat-下载"><a href="#MyCat-下载" class="headerlink" title="MyCat 下载"></a>MyCat 下载</h3><p>下载地址: <a href="https://github.com/MyCATApache/Mycat-download">https://github.com/MyCATApache/Mycat-download</a></p><p>最新下载地址: <a href="http://dl.mycat.io/">http://dl.mycat.io/</a></p><h2 id="MyCat-入门"><a href="#MyCat-入门" class="headerlink" title="MyCat 入门"></a>MyCat 入门</h2><p>本章节主要讲解MyCat的在Linux中的安装、基本概念和基本原理，这些是学习MyCat的基础。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>MyCat是采用java语言开发的开源的数据库中间件，支持Windows和Linux运行环境，下面介绍MyCat在Linux CentOS 6.5 中的环境搭建。</p><ul><li><p>MySQL</p></li><li><p>JDK</p></li><li><p>MyCat</p></li></ul><h4 id="安装配置-MySQL"><a href="#安装配置-MySQL" class="headerlink" title="安装配置 MySQL"></a>安装配置 MySQL</h4><h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">A. 卸载 centos 中预安装的 mysql</span><br><span class="line"></span><br><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"></span><br><span class="line">rpm -e mysql-libs-5.1.71-1.el6.x86_64 --nodeps</span><br><span class="line"></span><br><span class="line">B. 上传 mysql 的安装包</span><br><span class="line"></span><br><span class="line">alt + p -------&gt; put  E:/test/MySQL-5.6.22-1.el6.i686.rpm-bundle.tar</span><br><span class="line"></span><br><span class="line">C. 解压 mysql 的安装包 </span><br><span class="line"></span><br><span class="line">mkdir mysql</span><br><span class="line"></span><br><span class="line">tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /root/mysql</span><br><span class="line"></span><br><span class="line">D. 安装依赖包 </span><br><span class="line"></span><br><span class="line">yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 libncurses.so.5 --setopt=protected_multilib=false</span><br><span class="line"></span><br><span class="line">yum  update libstdc++-4.4.7-4.el6.x86_64</span><br><span class="line"></span><br><span class="line">E. 安装 mysql-client</span><br><span class="line"></span><br><span class="line">rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm</span><br><span class="line"></span><br><span class="line">F. 安装 mysql-server</span><br><span class="line"></span><br><span class="line">rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="启动停止MySQL"><a href="#启动停止MySQL" class="headerlink" title="启动停止MySQL"></a>启动停止MySQL</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br><span class="line"></span><br><span class="line">service mysql stop</span><br><span class="line"></span><br><span class="line">service mysql status</span><br><span class="line"></span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h5 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql 安装完成之后, 会自动生成一个随机的密码, 并且保存在一个密码文件中 : /root/.mysql_secret</span><br><span class="line"></span><br><span class="line">mysql -u root -p </span><br><span class="line"></span><br><span class="line">登录之后, 修改密码 :</span><br><span class="line"></span><br><span class="line">set password = password(&#x27;123456&#x27;);</span><br><span class="line"></span><br><span class="line">授权远程访问 : </span><br><span class="line"></span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>授权远程访问之后，就可以通过Navicat来连接Linux上的MySQL，但是记得关闭Linux上的防火墙(或者配置防火墙)：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1573536143760.png" alt="1573536143760"></p><h4 id="安装-JDK1-8"><a href="#安装-JDK1-8" class="headerlink" title="安装 JDK1.8"></a>安装 JDK1.8</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A. 上传JDK的安装包到Linux的root目录下</span><br><span class="line">alt + p -----------&gt; put D:/jdk-8u181-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">B. 解压压缩包 , 到 /usr/share 目录下</span><br><span class="line">tar -zxvf jdk-8u181-linux-x64.tar.gz -C /usr/share/</span><br><span class="line"></span><br><span class="line">C. 配置PATH环境变量 , 在该配置文件(/etc/profile)的最后加入如下配置</span><br><span class="line">export JAVA_HOME=/usr/share/jdk1.8.0_181</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">D. 配置生效</span><br><span class="line">    source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="安装-MyCat"><a href="#安装-MyCat" class="headerlink" title="安装 MyCat"></a>安装 MyCat</h4><ol><li><p>上传MyCat的压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + p --------&gt; put D:/Mycat-server-1.6.7.3-release-20190927161129-linux.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压MyCat的压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Mycat-server-1.6.7.3-release-20190927161129-linux.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure></li><li><p>MyCat的目录结构介绍</p></li></ol><p>​    <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1573556739880.png" alt="1573556739880">  </p><h3 id="MyCat核心概念"><a href="#MyCat核心概念" class="headerlink" title="MyCat核心概念"></a>MyCat核心概念</h3><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>简单来说，就是指通过某种特定的条件，将存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。 数据的切分（Sharding）根据其切分规则的类型，可以分为两种切分模式。</p><ol><li>一种是按照不同的表（或者Schema）来切分到不同的数据库（主机）之上，这种切分可以称之为数据的垂直（纵向）切分。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1573622314361.png" alt="1573622314361" style="zoom: 80%;" />  <ol start="2"><li>另外一种则是根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称之为数据的水平（横向）切分。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1573622358104.png" alt="1573622358104" style="zoom:80%;" />  <p><strong>MyCat 分片策略 :</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1573659631804.png" alt="1573659631804" style="zoom:80%;" />  <p>虚线以上是逻辑结构图, 虚线以下是物理结构图 。</p><h4 id="逻辑库-schema"><a href="#逻辑库-schema" class="headerlink" title="逻辑库(schema)"></a>逻辑库(schema)</h4><p>MyCat是一个数据库中间件，通常对实际应用来说，并不需要知道中间件的存在，业务开发人员只需要知道数据库的概念，所以数据库中间件可以被看做是一个或多个数据库集群构成的逻辑库。</p><h4 id="逻辑表（table）"><a href="#逻辑表（table）" class="headerlink" title="逻辑表（table）"></a>逻辑表（table）</h4><p>既然有逻辑库，那么就会有逻辑表。分布式数据库中，对应用来说，读写数据的表就是逻辑表。逻辑表，可以是数据切分后，分布在一个或多个分片库中，也可以不做数据切分，不分片，只有一个表构成。</p><ol><li><p>分片表：是指那些原有的很大数据的表，需要切分到多个数据库的表，这样，每个分片都有一部分数据，所有分片构成了完整的数据。 总而言之就是需要进行分片的表。如 ：tb_order 表是一个分片表, 数据按照规则被切分到dn1、dn2两个节点。</p></li><li><p>非分片表：一个数据库中并不是所有的表都很大，某些表是可以不用进行切分的，非分片是相对分片表来说的，就是那些不需要进行数据切分的表。如： tb_city是非分片表 , 数据只存于其中的一个节点 dn1 上。</p></li><li><p>ER表：关系型数据库是基于实体关系模型(Entity Relationship Model)的， MyCat中的ER表便来源于此。 MyCat提出了基于ER关系的数据分片策略 , 子表的记录与其所关联的父表的记录存放在同一个数据分片中, 通过表分组(Table Group)保证数据关联查询不会跨库操作。</p></li><li><p>全局表：在一个大型的项目中,会存在一部分字典表(码表) , 在其中存储的是项目中的一些基础的数据 , 而这些基础的数据 , 数据量都不大 , 在各个业务表中可能都存在关联 。当业务表由于数据量大而分片后 ， 业务表与附属的数据字典表之间的关联查询就变成了比较棘手的问题 ， 在MyCat中可以通过数据冗余来解决这类表的关联查询 ， 即所有分片都复制这一份数据（数据字典表），因此可以把这些冗余数据的表定义为全局表。</p></li></ol><h4 id="分片节点-dataNode"><a href="#分片节点-dataNode" class="headerlink" title="分片节点(dataNode)"></a>分片节点(dataNode)</h4><p>数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点（dataNode）。</p><h4 id="节点主机-dataHost"><a href="#节点主机-dataHost" class="headerlink" title="节点主机(dataHost)"></a>节点主机(dataHost)</h4><p>数据切分后，每个分片节点（dataNode）不一定都会独占一台机器，同一机器上面可以有多个分片数据库，这样一个或多个分片节点（dataNode）所在的机器就是节点主机（dataHost）,为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（dataNode）均衡的放在不同的节点主机（dataHost）。</p><h4 id="分片规则-rule"><a href="#分片规则-rule" class="headerlink" title="分片规则(rule)"></a>分片规则(rule)</h4><p>前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难度。</p><h3 id="分片配置测试"><a href="#分片配置测试" class="headerlink" title="分片配置测试"></a>分片配置测试</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>由于 TB_TEST 表中数据量很大, 现在需要对 TB_TEST 表进行数据分片, 分为三个数据节点 , 每一个节点主机位于不同的服务器上, 具体的结构，参考下图 : </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1575724614686.png" alt="1575724614686" style="zoom:80%;" />  <h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>准备三台虚拟机 , 且安装好MySQL , 并配置好 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IP 地址列表 : </span><br><span class="line">192.168.192.157</span><br><span class="line">192.168.192.158</span><br><span class="line">192.168.192.159</span><br></pre></td></tr></table></figure><h4 id="配置-schema-xml"><a href="#配置-schema-xml" class="headerlink" title="配置 schema.xml"></a>配置 schema.xml</h4><p>schema.xml 作为MyCat中重要的配置文件之一，管理着MyCat的逻辑库、逻辑表以及对应的分片规则、DataNode以及DataSource。弄懂这些配置，是正确使用MyCat的前提。这里就一层层对该文件进行解析。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>schema</td><td>标签用于定义MyCat实例中的逻辑库</td></tr><tr><td>table</td><td>标签定义了MyCat中的逻辑表, rule用于指定分片规则，auto-sharding-long的分片规则是按ID值的范围进行分片 1-5000000 为第1片  5000001-10000000 为第2片….  具体设置会在后面中讲解。</td></tr><tr><td>dataNode</td><td>标签定义了MyCat中的数据节点，也就是通常说所的数据分片。</td></tr><tr><td>dataHost</td><td>标签在MyCat逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。</td></tr></tbody></table><p>在服务器上创建3个数据库，命名为 db1。</p><p>修改schema.xml如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 逻辑库配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逻辑表配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_TEST&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 数据节点配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 节点主机配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.157:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.158:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.159:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置-server-xml"><a href="#配置-server-xml" class="headerlink" title="配置 server.xml"></a>配置 server.xml</h4><p>server.xml几乎保存了所有MyCat需要的系统配置信息。最常用的是在此配置用户名、密码及权限。在system中添加UTF-8字符集设置，否则存储中文会出现问号。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;charset&quot;</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改user的设置 ,  这里为 ITCAST 设置了两个用户，并且需要将原来的逻辑库的配置 , 替换为 ITCAST逻辑库 : </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启动MyCat"><a href="#启动MyCat" class="headerlink" title="启动MyCat"></a>启动MyCat</h4><p>启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/mycat start</span><br><span class="line">bin/mycat stop</span><br><span class="line">bin/mycat status</span><br></pre></td></tr></table></figure><p>查看MyCat：连接端口号  8066 。</p><ol><li>通过命令行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 8066 -u root -p</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1573916419746.png" alt="1573916419746"> </p><ol start="2"><li>通过sqlyog连接</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210521134349351.png" alt="image-20210521134349351" style="zoom:50%;" /> <h4 id="MyCat分片测试"><a href="#MyCat分片测试" class="headerlink" title="MyCat分片测试"></a>MyCat分片测试</h4><ol><li>进入mycat ，执行下列语句创建一个表：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TB_TEST (</span><br><span class="line">  id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br></pre></td></tr></table></figure><ol start="2"><li>查看MySQL的3个库，发现表都自动创建好啦。好神奇。接下来是插入表数据，注意，在写 INSERT 语句时一定要写把字段列表写出来，否则会出现下列错误提示：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误代码： 1064</span><br><span class="line"></span><br><span class="line">partition table, insert must provide ColumnList</span><br></pre></td></tr></table></figure><p>试着插入一些数据：我们会发现这些数据被写入到第一个节点中了，那什么时候数据会写到第二个节点中呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TB_TEST(ID,TITLE) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;goods1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TB_TEST(ID,TITLE) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;goods2&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TB_TEST(ID,TITLE) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;goods3&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>我们插入下面的数据就可以插入第二个节点了：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TB_TEST(ID,TITLE) <span class="keyword">VALUES</span>(<span class="number">5000001</span>,<span class="string">&#x27;goods5000001&#x27;</span>);</span><br></pre></td></tr></table></figure><p>因为我们采用的分片规则是每节点存储500万条数据，所以当ID大于5000000则会存储到第二个节点上。</p><h3 id="MyCat原理介绍"><a href="#MyCat原理介绍" class="headerlink" title="MyCat原理介绍"></a>MyCat原理介绍</h3><p>MyCat原理中最重要的一个动词就是 “拦截”, 它拦截了用户发送过来的SQL语句, 首先对SQL语句做一些特定的分析,如分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL语句发往后端的真实数据库，并将返回的结果做适当处理，最终再返回给用户，如图所示。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1577358066323.png" alt="1577358066323" style="zoom:80%;" /> <ul><li><p>在图中,user表被分为三个分片节点dn1、dn2、dn3, 它们分布式在三个MySQL Server(dataHost)上，因此可以使用1-N台服务器来分片,分片规则(sharding rule)为典型的字符串枚举分片规则, 一个规则的定义是分片字段+分片函数。这里的分片字段为 status，分片函数则为字符串枚举方式。</p></li><li><p>MyCat收到一条SQL语句时，首先解析SQL语句涉及到的表，接着查看此表的定义，如果该表存在分片规则，则获取SQL语句里分片字段的值，并匹配分片函数，得到该SQL语句对应的分片列表，然后将SQL语句发送到相应的分片去执行，最后处理所有分片返回的数据并返回给客户端。以”select * from user where status=’0’” 为例, 查找 status=’0’ ,按照分片函数, ‘0’ 值存放在dn1,于是SQL语句被发送到第一个节点中执行, 然后再将查询的结果返回给用户。</p></li><li><p>如果发送的SQL语句为 “select * from user where status in (‘0’,’1’)” , 那么SQL语句会被发送到dn1,dn2对应的主机上执行, 然后将结果集合并后输出给用户。</p></li></ul><h2 id="MyCat配置文件详解"><a href="#MyCat配置文件详解" class="headerlink" title="MyCat配置文件详解"></a>MyCat配置文件详解</h2><h3 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h3><h4 id="system-标签"><a href="#system-标签" class="headerlink" title="system 标签"></a>system 标签</h4><table><thead><tr><th>属性</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>charset</td><td>utf8</td><td>设置Mycat的字符集, 字符集需要与MySQL的字符集保持一致。</td></tr><tr><td>nonePasswordLogin</td><td>0,1</td><td>0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户。</td></tr><tr><td>useHandshakeV10</td><td>0,1</td><td>使用该选项主要的目的是为了能够兼容高版本的jdbc驱动, 是否采用HandshakeV10Packet来与client进行通信, 1:是, 0:否。</td></tr><tr><td>useSqlStat</td><td>0,1</td><td>开启SQL实时统计, 1 为开启 , 0 为关闭 ;<br />开启之后, MyCat会自动统计SQL语句的执行情况 ;<br />使用：mysql -h 127.0.0.1 -P 9066 -u root -p<br />查看MyCat执行的SQL、执行效率比较低的SQL 、SQL的整体执行情况、读写比例等 ;<br />show @@sql ; show @@sql.slow ; show @@sql.sum ;</td></tr><tr><td>useGlobleTableCheck</td><td>0,1</td><td>是否开启全局表的一致性检测。1为开启 ，0为关闭 。</td></tr><tr><td>sqlExecuteTimeout</td><td>1000</td><td>SQL语句执行的超时时间 , 单位为 s ;</td></tr><tr><td>sequnceHandlerType</td><td>0,1,2</td><td>用来指定MyCat全局序列类型，0 为本地文件，1 为数据库方式，2 为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试。</td></tr><tr><td>sequnceHandlerPattern</td><td>正则表达式</td><td>必须带有MYCATSEQ_或者 mycatseq_进入序列匹配流程，注意MYCATSEQ_有空格的情况。</td></tr><tr><td>subqueryRelationshipCheck</td><td>true,false</td><td>子查询中存在关联查询的情况下,检查关联字段中是否有分片字段，默认 false。</td></tr><tr><td>useCompression</td><td>0,1</td><td>开启mysql压缩协议 , 0 : 关闭, 1 : 开启。</td></tr><tr><td>fakeMySQLVersion</td><td>5.5,5.6</td><td>设置模拟的MySQL版本号。</td></tr><tr><td>defaultSqlParser</td><td></td><td>由于MyCat的最初版本使用了FoundationDB的SQL解析器，在MyCat1.3后增加了Druid解析器，所以要设置defaultSqlParser属性来指定默认的解析器；解析器有两个 : druidparser 和 fdbparser，在MyCat1.4之后，默认是druidparser，fdbparser已经废除了。</td></tr><tr><td>processors</td><td>1,2….</td><td>指定系统可用的线程数量, 默认值为CPU核心 x 每个核心运行线程数量; processors 会影响processorBufferPool, processorBufferLocalPercent, processorExecutor属性, 所有, 在性能调优时, 可以适当地修改processors值。</td></tr><tr><td>processorBufferChunk</td><td></td><td>指定每次分配Socket Direct Buffer默认值为4096字节, 也会影响BufferPool长度, 如果一次性获取字节过多而导致buffer不够用, 则会出现警告, 可以调大该值。</td></tr><tr><td>processorExecutor</td><td></td><td>指定NIOProcessor上共享 businessExecutor固定线程池的大小; MyCat把异步任务交给 businessExecutor线程池中, 在新版本的MyCat中这个连接池使用频次不高, 可以适当地把该值调小。</td></tr><tr><td>packetHeaderSize</td><td></td><td>指定MySQL协议中的报文头长度, 默认4个字节。</td></tr><tr><td>maxPacketSize</td><td></td><td>指定MySQL协议可以携带的数据最大大小, 默认值为16M。</td></tr><tr><td>idleTimeout</td><td>30</td><td>指定连接的空闲时间的超时长度;如果超时,将关闭资源并回收, 默认30分钟</td></tr><tr><td>txIsolation</td><td>1,2,3,4</td><td>初始化前端连接的事务隔离级别,默认为 REPEATED_READ , 对应数字为3<br />READ_UNCOMMITED=1;<br />READ_COMMITTED=2;<br />REPEATED_READ=3;<br />SERIALIZABLE=4;</td></tr><tr><td>sqlExecuteTimeout</td><td>300</td><td>执行SQL的超时时间, 如果SQL语句执行超时,将关闭连接; 默认300秒。</td></tr><tr><td>serverPort</td><td>8066</td><td>定义MyCat的使用端口, 默认8066。</td></tr><tr><td>managerPort</td><td>9066</td><td>定义MyCat的管理端口, 默认9066。</td></tr></tbody></table><h4 id="user-标签"><a href="#user-标签" class="headerlink" title="user 标签"></a>user 标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;benchmark&quot;</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;usingDecrypt&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 表级 DML 权限设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    &lt;privileges check=&quot;false&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;</span></span><br><span class="line"><span class="comment">            &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">            &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">        &lt;/schema&gt;</span></span><br><span class="line"><span class="comment">    &lt;/privileges&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>user标签主要用于定义登录MyCat的用户和权限 :</p><ol><li><p>&lt;user name=”root” defaultAccount=”true”&gt; : name 属性用于声明用户名 。</p></li><li><p>&lt;property name=”password”&gt;123456&lt;/property&gt; : 指定该用户名访问MyCat的密码 。</p></li><li><p>&lt;property name=”schemas”&gt;ITCAST&lt;/property&gt; : 能够访问的逻辑库, 多个的话, 使用 “,” 分割。</p></li><li><p>&lt;property name=”readOnly”&gt;true&lt;/property&gt; : 是否只读。</p></li><li><p>&lt;property name=”benchmark”&gt;11111&lt;/property&gt; : 指定前端的整体连接数量 , 0 或不设置表示不限制 。</p></li><li><p>&lt;property name=”usingDecrypt”&gt;0&lt;/property&gt; : 是否对密码加密默认 0 否 , 1 是。设置密码加密后需要使用如下命令获取加密后的密码，并修改配置文件的密码为加密后的密码，登录时照样使用”123456”进行登录。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp Mycat-server-1.6.7.3-release.jar io.mycat.util.DecryptUtil 0:root:123456</span><br></pre></td></tr></table></figure><ol start="7"><li>&lt;privileges check=”false”&gt;</li></ol><ul><li><p>对用户的 schema 及下级的 table 进行精细化的 DML 权限控制；</p></li><li><p> privileges 节点中的 check 属性是用于标识是否开启 DML 权限检查， 默认 false 标识不检查，当然 privileges 节点不配置，等同 check=false, 由于 Mycat 一个用户的 schemas 属性可配置多个 schema ，所以 privileges 的下级节点 schema 节点同样 可配置多个，对多库多表进行细粒度的 DML 权限控制；</p></li><li><p>权限修饰符四位数字(0000 - 1111)，对应的操作是 IUSD ( 增，改，查，删 )。同时配置了库跟表的权限，就近原则。以表权限为准。</p></li></ul><h4 id="firewall-标签"><a href="#firewall-标签" class="headerlink" title="firewall 标签"></a>firewall 标签</h4><p>firewall标签用来定义防火墙；firewall下whitehost标签用来定义 IP白名单 ，blacklist用来定义 SQL黑名单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">firewall</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 白名单配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">whitehost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">host</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 黑名单配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blacklist</span> <span class="attr">check</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;selelctAllow&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">blacklist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">firewall</span>&gt;</span></span><br></pre></td></tr></table></figure><p>黑名单拦截明细配置：</p><table><thead><tr><th>配置项</th><th>缺省值</th><th>描述</th></tr></thead><tbody><tr><td>selelctAllow</td><td>true</td><td>是否允许执行 SELECT 语句。</td></tr><tr><td>selectAllColumnAllow</td><td>true</td><td>是否允许执行 SELECT * FROM T 这样的语句。如果设置为 false，不允许执行 select * from t，但可以select * from (select id, name from t) a。这个选项是防御程序通过调用 select * 获得数据表的结构信息。</td></tr><tr><td>selectIntoAllow</td><td>true</td><td>SELECT 查询中是否允许 INTO 字句。</td></tr><tr><td>deleteAllow</td><td>true</td><td>是否允许执行 DELETE 语句。</td></tr><tr><td>updateAllow</td><td>true</td><td>是否允许执行 UPDATE 语句。</td></tr><tr><td>insertAllow</td><td>true</td><td>是否允许执行 INSERT 语句。</td></tr><tr><td>replaceAllow</td><td>true</td><td>是否允许执行 REPLACE 语句。</td></tr><tr><td>mergeAllow</td><td>true</td><td>是否允许执行 MERGE 语句，这个只在 Oracle 中有用。</td></tr><tr><td>callAllow</td><td>true</td><td>是否允许通过 jdbc 的 call 语法调用存储过程。</td></tr><tr><td>setAllow</td><td>true</td><td>是否允许使用 SET 语法。</td></tr><tr><td>truncateAllow</td><td>true</td><td>truncate 语句是危险，缺省打开，若需要自行关闭。</td></tr><tr><td>createTableAllow</td><td>true</td><td>是否允许创建表。</td></tr><tr><td>alterTableAllow</td><td>true</td><td>是否允许执行 Alter Table 语句。</td></tr><tr><td>dropTableAllow</td><td>true</td><td>是否允许修改表。</td></tr><tr><td>commentAllow</td><td>false</td><td>是否允许语句中存在注释，Oracle 的用户不用担心，Wall 能够识别 hints和注释的区别。</td></tr><tr><td>noneBaseStatementAllow</td><td>false</td><td>是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽 DDL。</td></tr><tr><td>multiStatementAllow</td><td>false</td><td>是否允许一次执行多条语句，缺省关闭。</td></tr><tr><td>useAllow</td><td>true</td><td>是否允许执行 mysql 的 use 语句，缺省打开。</td></tr><tr><td>describeAllow</td><td>true</td><td>是否允许执行 mysql 的 describe 语句，缺省打开。</td></tr><tr><td>showAllow</td><td>true</td><td>是否允许执行 mysql 的 show 语句，缺省打开。</td></tr><tr><td>commitAllow</td><td>true</td><td>是否允许执行 commit 操作。</td></tr><tr><td>rollbackAllow</td><td>true</td><td>是否允许执行 roll back 操作。</td></tr><tr><td>拦截配置－永真条件</td><td></td><td></td></tr><tr><td>selectWhereAlwayTrueCheck</td><td>true</td><td>检查 SELECT 语句的 WHERE 子句是否是一个永真条件。</td></tr><tr><td>selectHavingAlwayTrueCheck</td><td>true</td><td>检查 SELECT 语句的 HAVING 子句是否是一个永真条件。</td></tr><tr><td>deleteWhereAlwayTrueCheck</td><td>true</td><td>检查 DELETE 语句的 WHERE 子句是否是一个永真条件。</td></tr><tr><td>deleteWhereNoneCheck</td><td>false</td><td>检查 DELETE 语句是否无 where 条件，这是有风险的，但不是 SQL 注入类型的风险。</td></tr><tr><td>updateWhereAlayTrueCheck</td><td>true</td><td>检查 UPDATE 语句的 WHERE 子句是否是一个永真条件。</td></tr><tr><td>updateWhereNoneCheck</td><td>false</td><td>检查 UPDATE 语句是否无 where 条件，这是有风险的，但不是SQL 注入类型的风险。</td></tr><tr><td>conditionAndAlwayTrueAllow</td><td>false</td><td>检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永真条件。</td></tr><tr><td>conditionAndAlwayFalseAllow</td><td>false</td><td>检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永假条件。</td></tr><tr><td>conditionLikeTrueAllow</td><td>true</td><td>检查查询条件(WHERE/HAVING 子句)中是否包含 LIKE 永真条件。</td></tr><tr><td>其他拦截配置</td><td></td><td></td></tr><tr><td>selectIntoOutfileAllow</td><td>false</td><td>SELECT … INTO OUTFILE 是否允许，这个是 mysql 注入攻击的常见手段，缺省是禁止的。</td></tr><tr><td>selectUnionCheck</td><td>true</td><td>检测 SELECT UNION。</td></tr><tr><td>selectMinusCheck</td><td>true</td><td>检测 SELECT MINUS。</td></tr><tr><td>selectExceptCheck</td><td>true</td><td>检测 SELECT EXCEPT。</td></tr><tr><td>selectIntersectCheck</td><td>true</td><td>检测 SELECT INTERSECT。</td></tr><tr><td>mustParameterized</td><td>false</td><td>是否必须参数化，如果为 True，则不允许类似 WHERE ID = 1 这种不参数化的 SQL。</td></tr><tr><td>strictSyntaxCheck</td><td>true</td><td>是否进行严格的语法检测，Druid SQL Parser 在某些场景不能覆盖所有的SQL 语法，出现解析 SQL 出错，可以临时把这个选项设置为 false，同时把 SQL 反馈给 Druid 的开发者。</td></tr><tr><td>conditionOpXorAllow</td><td>false</td><td>查询条件中是否允许有 XOR 条件。XOR 不常用，很难判断永真或者永假，缺省不允许。</td></tr><tr><td>conditionOpBitwseAllow</td><td>true</td><td>查询条件中是否允许有”&amp;”、”~”、”|”、”^”运算符。</td></tr><tr><td>conditionDoubleConstAllow</td><td>false</td><td>查询条件中是否允许连续两个常量运算表达式。</td></tr><tr><td>minusAllow</td><td>true</td><td>是否允许 SELECT * FROM A MINUS SELECT * FROM B 这样的语句。</td></tr><tr><td>intersectAllow</td><td>true</td><td>是否允许 SELECT * FROM A INTERSECT SELECT * FROM B 这样的语句。</td></tr><tr><td>constArithmeticAllow</td><td>true</td><td>拦截常量运算的条件，比如说 WHERE FID = 3 - 1，其中”3 - 1”是常量运算表达式。</td></tr><tr><td>limitZeroAllow</td><td>false</td><td>是否允许 limit 0 这样的语句。</td></tr><tr><td>禁用对象检测配置</td><td></td><td></td></tr><tr><td>tableCheck</td><td>true</td><td>检测是否使用了禁用的表。</td></tr><tr><td>schemaCheck</td><td>true</td><td>检测是否使用了禁用的 Schema。</td></tr><tr><td>functionCheck</td><td>true</td><td>检测是否使用了禁用的函数。</td></tr><tr><td>objectCheck</td><td>true</td><td>检测是否使用了“禁用对对象”。</td></tr><tr><td>variantCheck</td><td>true</td><td>检测是否使用了“禁用的变量”。</td></tr><tr><td>readOnlyTables</td><td>空</td><td>指定的表只读，不能够在 SELECT INTO、DELETE、UPDATE、INSERT、MERGE 中作为”被修改表”出现。</td></tr></tbody></table><h3 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h3><p>schema.xml 作为MyCat中最重要的配置文件之一 , 涵盖了MyCat的逻辑库 、 表 、 分片规则、分片节点及数据源的配置。</p><h4 id="schema-标签"><a href="#schema-标签" class="headerlink" title="schema 标签"></a>schema 标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_TEST&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>schema 标签用于定义 MyCat实例中的逻辑库 , 一个MyCat实例中, 可以有多个逻辑库 , 可以通过 schema 标签来划分不同的逻辑库。MyCat中的逻辑库的概念 ， 等同于MySQL中的database概念 , 需要操作某个逻辑库下的表时, 也需要切换逻辑库:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use ITCAST;</span><br></pre></td></tr></table></figure><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>schema 标签的属性如下 : </p><ol><li><p>name：指定逻辑库的库名 , 可以自己定义任何字符串 。</p></li><li><p>checkSQLschema：取值为 true / false ；当设置为true时，如果执行的语句为 “select * from ITCAST.TB_TEST;” ，则MyCat会自动把schema字符去掉，把SQL语句修改为 “select * from TB_TEST;” ，可以避免SQL发送到后端数据库执行时，报table不存在的异常 。不过当我们在编写SQL语句时，指定了一个不存在schema， MyCat是不会帮我们自动去除的，这个时候数据库就会报错，所以在编写SQL语句时，最好不要加逻辑库的库名，直接查询表即可。</p></li><li><p>sqlMaxLimit：当该属性设置为某个数值时,每次执行的SQL语句如果没有加上limit语句，MyCat也会自动在limit语句后面加上对应的数值 。也就是说，如果设置了该值为100，则执行 “select * from TB_TEST 与 select * from TB_TEST limit 100;” 是相同的效果 。所以在正常的使用中, 建立设置该值 , 这样就可以避免每次有过多的数据返回。</p></li></ol><h5 id="子标签table"><a href="#子标签table" class="headerlink" title="子标签table"></a>子标签table</h5><p>table 标签定义了MyCat中逻辑库schema下的逻辑表 , 所有需要拆分的表都需要在table标签中定义 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_TEST&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>属性如下 ： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1574954845578.png" alt="1574954845578" style="zoom: 67%;" /> <ol><li><p>name ：定义逻辑表的表名，在该逻辑库下必须唯一。</p></li><li><p>dataNode：定义的逻辑表所属的dataNode，该属性需要与dataNode标签中的name属性的值对应。 如果一张表拆分的数据，存储在多个数据节点上，多个节点的名称使用”,”分隔 。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1574955059453.png" alt="1574955059453"> </p><ol start="3"><li>rule：该属性用于指定逻辑表的分片规则的名字，规则的名字是在rule.xml文件中定义的，必须与tableRule标签中name属性对应。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1574955534319.png" alt="1574955534319"> </p><ol start="4"><li><p>ruleRequired：该属性用于指定表是否绑定分片规则，如果配置为true, 但是没有具体的rule, 程序会报错。</p></li><li><p>primaryKey：逻辑表对应真实表的主键，如: 分片规则是使用主键进行分片，使用主键进行查询时，就会发送查询语句到配置的所有的datanode上；如果使用该属性配置真实表的主键，那么MyCat会缓存主键与具体datanode的信息，再次使用主键查询就不会进行广播式查询了，而是直接将SQL发送给具体的datanode。</p></li><li><p>type：该属性定义了逻辑表的类型，目前逻辑表只有全局表和普通表。全局表：type的值是 global，代表 全局表 。普通表：无。</p></li><li><p>autoIncrement：mysql对非自增长主键，使用last_insert_id() 是不会返回结果的，只会返回0。所以只有定义了自增长主键的表，才可以用last_insert_id()返回主键值。MyCat提供了自增长主键功能，但是对应的mysql节点上数据表，没有auto_increment，那么在MyCat层调用last_insert_id()也是不会返回结果的。如果使用这个功能， 则最好配合数据库模式的全局序列。使用 autoIncrement=”true” 指定该表使用自增长主键,这样MyCat才不会抛出 “分片键找不到” 的异常。 autoIncrement的默认值为 false。</p></li><li><p>needAddLimit：指定表是否需要自动在每个语句的后面加上limit限制, 默认为true。</p></li></ol><h4 id="dataNode-标签"><a href="#dataNode-标签" class="headerlink" title="dataNode 标签"></a>dataNode 标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>dataNode标签中定义了MyCat中的数据节点，也就是通常说的数据分片。一个dataNode标签就是一个独立的数据分片。具体的属性如下 ： </p><table><thead><tr><th>属性</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>数据节点的名称</td><td>需要唯一 ; 在table标签中会引用这个名字，标识表与分片的对应关系。</td></tr><tr><td>dataHost</td><td>数据库实例主机名称</td><td>引用自 dataHost 标签中name属性。</td></tr><tr><td>database</td><td>定义分片所属的数据库</td><td></td></tr></tbody></table><h4 id="dataHost-标签"><a href="#dataHost-标签" class="headerlink" title="dataHost 标签"></a>dataHost 标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.157:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该标签在MyCat逻辑库中作为底层标签存在，直接定义了具体的数据库实例、读写分离、心跳语句。</p><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><table><thead><tr><th>属性</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>数据节点名称</td><td>唯一标识， 供上层标签使用。</td></tr><tr><td>maxCon</td><td>最大连接数</td><td>内部的writeHost、readHost都会使用这个属性。</td></tr><tr><td>minCon</td><td>最小连接数</td><td>内部的writeHost、readHost初始化连接池的大小。</td></tr><tr><td>balance</td><td>负载均衡类型</td><td>取值0,1,2,3 ; 后面章节会详细介绍；</td></tr><tr><td>writeType</td><td>写操作分发方式</td><td>0 : 写操作都转发到第1台writeHost, writeHost1挂了，会切换到writeHost2上；<br />1 : 所有的写操作都随机地发送到配置的writeHost上 。</td></tr><tr><td>dbType</td><td>后端数据库类型</td><td>mysql, mongodb , oracle</td></tr><tr><td>dbDriver</td><td>数据库驱动</td><td>指定连接后端数据库的驱动，目前可选值有 native和JDBC。native执行的是二进制的MySQL协议，可以使用MySQL和MariaDB。其他类型数据库需要使用JDBC（需要在MyCat/lib目录下加入驱动jar）。</td></tr><tr><td>switchType</td><td>数据库切换策略</td><td>取值 -1,1,2,3 ; 后面章节会详细介绍;</td></tr></tbody></table><h5 id="子标签heartbeat"><a href="#子标签heartbeat" class="headerlink" title="子标签heartbeat"></a>子标签heartbeat</h5><p>配置MyCat与后端数据库的心跳，用于检测后端数据库的状态。heartbeat用于配置心跳检查语句。例如 ： MySQL中可以使用 select user(), Oracle中可以使用 select 1 from dual等。</p><h5 id="子标签-writeHost、readHost"><a href="#子标签-writeHost、readHost" class="headerlink" title="子标签 writeHost、readHost"></a>子标签 writeHost、readHost</h5><p>指定后端数据库的相关配置， 用于实例化后端连接池。 writeHost指定写实例， readHost指定读实例。在一个dataHost中可以定义多个writeHost和readHost。但是，如果writeHost指定的后端数据库宕机， 那么这个writeHost绑定的所有readHost也将不可用。</p><p>属性：</p><table><thead><tr><th>属性名</th><th>含义</th><th>取值</th></tr></thead><tbody><tr><td>host</td><td>实例主机标识</td><td>对于writeHost一般使用 *M1；对于readHost，一般使用 *S1；</td></tr><tr><td>url</td><td>后端数据库连接地址</td><td>如果是native，一般为 ip:port ; 如果是JDBC, 一般为jdbc:mysql://ip:port/</td></tr><tr><td>user</td><td>数据库用户名</td><td>root</td></tr><tr><td>password</td><td>数据库密码</td><td>itcast</td></tr><tr><td>weight</td><td>权重</td><td>在readHost中作为读节点权重</td></tr><tr><td>usingDecrypt</td><td>密码加密</td><td>默认 0 否 , 1 是</td></tr></tbody></table><h3 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h3><p>rule.xml中定义所有拆分表的规则，在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配置化。</p><h4 id="tableRule标签"><a href="#tableRule标签" class="headerlink" title="tableRule标签"></a>tableRule标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>name : 指定分片算法的名称。</p></li><li><p>rule : 定义分片算法的具体内容 。</p></li><li><p>columns : 指定对应的表中用于分片的列名。</p></li><li><p>algorithm : 对应function中指定的算法名称。</p></li></ol><h4 id="Function标签"><a href="#Function标签" class="headerlink" title="Function标签"></a>Function标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>name : 指定算法名称, 该文件中唯一 。</p></li><li><p>class : 指定算法的具体类。</p></li><li><p>property : 根据算法的要求执行 。</p></li></ol><h3 id="sequence-配置文件"><a href="#sequence-配置文件" class="headerlink" title="sequence 配置文件"></a>sequence 配置文件</h3><p>在分库分表的情况下，原有的自增主键已无法满足在集群中全局唯一的主键，因此，MyCat中提供了全局sequence来实现主键，并保证全局唯一。那么在MyCat的配置文件 sequence_conf.properties 中就配置的是序列的相关配置。</p><p>主要包含以下几种形式：</p><ol><li><p>本地文件方式</p></li><li><p>数据库方式</p></li><li><p>本地时间戳方式</p></li><li><p>其他方式</p></li><li><p>自增长主键</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> MyCat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库中间件 </tag>
            
            <tag> MyCat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper</title>
      <link href="2021/06/30/Zookeeper/"/>
      <url>2021/06/30/Zookeeper/</url>
      
        <content type="html"><![CDATA[<h3 id="Zookeeper是什么"><a href="#Zookeeper是什么" class="headerlink" title="Zookeeper是什么"></a>Zookeeper是什么</h3><ul><li><p>ZooKeeper 是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态。</p></li><li><p>根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p></li><li><p>分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p></li></ul><h3 id="Zookeeper-特性"><a href="#Zookeeper-特性" class="headerlink" title="Zookeeper 特性"></a><strong>Zookeeper 特性</strong></h3><p><strong>Zookeeper 保证了如下分布式一致性特性</strong>：</p><ol><li><p>顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</p></li><li><p>原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</p></li><li><p>单一视图：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</p></li><li><p>可靠性：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来。</p></li><li><p>实时性（最终一致性）： Zookeeper 仅仅能保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</p></li></ol><h3 id="ZooKeeper-提供了什么？"><a href="#ZooKeeper-提供了什么？" class="headerlink" title="ZooKeeper 提供了什么？"></a><strong>ZooKeeper 提供了什么？</strong></h3><ol><li><p>文件系统</p></li><li><p>通知机制</p></li></ol><h3 id="Zookeeper-文件系统"><a href="#Zookeeper-文件系统" class="headerlink" title="Zookeeper 文件系统"></a><strong>Zookeeper 文件系统</strong></h3><p>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</p><p>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，<strong>这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M</strong>。</p><h3 id="ZAB-协议？"><a href="#ZAB-协议？" class="headerlink" title="ZAB 协议？"></a><strong>ZAB 协议？</strong></h3><p>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。</p><p>ZAB 协议包括两种基本的模式：<strong>崩溃恢复和消息广播</strong>。</p><ul><li><p>当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader服务器完成数据同步之后，退出恢复模式。</p></li><li><p>接着进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。</p></li></ul><h3 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a><strong>四种类型的数据节点 Znode</strong></h3><ol><li><p>持久节点（PERSISTENT）：这类节点被创建后，就会一直存在于zk服务器上，直到手动删除。</p></li><li><p>持久顺序节点（PERSISTENT_SEQUENTIAL）：它的基本特性同持久节点，不同在于增加了顺序性。父节点会维护一个自增整性数字，用于子节点的创建的先后顺序。</p></li><li><p>临时节点（EPHEMERAL）：临时节点的生命周期与客户端的会话绑定，一旦客户端会话失效（非TCP连接断开），那么这个节点就会被自动清理掉。zk规定临时节点只能作为叶子节点。</p></li><li><p>临时顺序节点（EPHEMERAL_SEQUENTIAL）：基本特性同临时节点，添加了顺序的特性。</p></li></ol><h3 id="Zookeeper-Watcher-机制-–-数据变更通知"><a href="#Zookeeper-Watcher-机制-–-数据变更通知" class="headerlink" title="Zookeeper Watcher 机制 – 数据变更通知"></a><strong>Zookeeper Watcher 机制 – 数据变更通知</strong></h3><p><strong>Watcher监听机制</strong><br>Zookeeper 允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher通知状态和事件类型做出业务上的改变。</p><blockquote><p>可以把Watcher理解成客户端注册在某个Znode上的触发器，当这个Znode节点发生变化时（增删改查），就会触发Znode对应的注册事件，注册的客户端就会收到异步通知，然后做出业务的改变。</p></blockquote><h3 id="Chroot-特性"><a href="#Chroot-特性" class="headerlink" title="Chroot 特性"></a><strong>Chroot 特性</strong></h3><p>3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相互隔离非常有帮助。</p><h3 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a><strong>服务器角色</strong></h3><p><strong>Leader</strong></p><ol><li><p>事务请求的唯一调度和处理者，保证集群事务处理的顺序性。</p></li><li><p>集群内部各服务的调度者。</p></li></ol><p><strong>Follower</strong></p><ol><li><p>处理客户端的非事务请求，转发事务请求给 Leader 服务器。</p></li><li><p>参与事务请求 Proposal 的投票。</p></li><li><p>参与 Leader 选举投票。</p></li></ol><p><strong>Observer</strong></p><ol><li><p>3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力。</p></li><li><p>处理客户端的非事务请求，转发事务请求给 Leader 服务器。</p></li><li><p>不参与任何形式的投票。</p></li></ol><h3 id="Zookeeper-下-Server-工作状态"><a href="#Zookeeper-下-Server-工作状态" class="headerlink" title="Zookeeper 下 Server 工作状态"></a><strong>Zookeeper 下 Server 工作状态</strong></h3><p>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。</p><ol><li><p><strong>LOOKING</strong>：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</p></li><li><p><strong>FOLLOWING</strong>：跟随者状态。表明当前服务器角色是 Follower。</p></li><li><p><strong>LEADING</strong>：领导者状态。表明当前服务器角色是 Leader。</p></li><li><p><strong>OBSERVING</strong>：观察者状态。表明当前服务器角色是 Observer。</p></li></ol><h3 id="Znode节点里面存储的是什么"><a href="#Znode节点里面存储的是什么" class="headerlink" title="Znode节点里面存储的是什么"></a>Znode节点里面存储的是什么</h3><p>Znode数据节点的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataNode</span> <span class="keyword">implements</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> data[];                    </span><br><span class="line">    Long acl;                       </span><br><span class="line">    <span class="keyword">public</span> StatPersisted stat;       </span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; children = <span class="keyword">null</span>; </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>Znode包含了<strong>存储数据、访问权限、子节点引用、节点状态信息</strong>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621125805584.png" alt="image-20210621125805584"></p><ul><li><strong>data：</strong> znode存储的业务数据信息。</li><li><strong>ACL：</strong>记录客户端对znode节点的访问权限，如IP等。</li><li><strong>child：</strong> 当前节点的子节点引用。</li><li><strong>stat：</strong> 包含Znode节点的状态信息，比如<strong>事务id、版本号、时间戳</strong>等等。</li></ul><p>为了保证高吞吐和低延迟，以及数据的一致性，znode只适合存储非常小的数据，不能超过1M，最好都小于1K。</p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a><strong>数据同步</strong></h3><p>整个集群完成 Leader 选举之后，Learner（Follower 和 Observer 的统称）会向Leader 服务器进行注册。当 Learner 服务器向 Leader 服务器完成注册后，进入数据同步环节。</p><p>数据同步流程：（均以消息传递的方式进行）</p><ol><li><p>Learner 向 Learder 注册</p></li><li><p>数据同步</p></li><li><p>同步确认</p></li></ol><p><strong>Zookeeper 的数据同步通常分为四类</strong>：</p><ol><li><p>直接差异化同步（DIFF 同步）</p></li><li><p>先回滚再差异化同步（TRUNC+DIFF 同步）</p></li><li><p>仅回滚同步（TRUNC 同步）</p></li><li><p>全量同步（SNAP 同步）</p></li></ol><h3 id="Zookeeper-是如何保证事务的顺序一致性的"><a href="#Zookeeper-是如何保证事务的顺序一致性的" class="headerlink" title="Zookeeper 是如何保证事务的顺序一致性的"></a><strong>Zookeeper 是如何保证事务的顺序一致性的</strong></h3><p>zookeeper 采用了全局递增的事务 id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。</p><p>当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><h3 id="ZK-节点宕机如何处理"><a href="#ZK-节点宕机如何处理" class="headerlink" title="ZK 节点宕机如何处理"></a><strong>ZK 节点宕机如何处理</strong></h3><p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p><ul><li><p>如果是一个 Follower 宕机，那还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</p></li><li><p>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p></li></ul><p>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)，而2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;=1)。</p><h3 id="Zookeeper-负载均衡和-Nginx-负载均衡区别"><a href="#Zookeeper-负载均衡和-Nginx-负载均衡区别" class="headerlink" title="Zookeeper 负载均衡和 Nginx 负载均衡区别"></a><strong>Zookeeper 负载均衡和 Nginx 负载均衡区别</strong></h3><p>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。</p><h3 id="集群支持动态添加机器吗"><a href="#集群支持动态添加机器吗" class="headerlink" title="集群支持动态添加机器吗"></a><strong>集群支持动态添加机器吗</strong></h3><p>动态添加机器其实就是水平扩容，Zookeeper 在这方面不太好。两种方式：</p><ul><li><p><strong>全部重启</strong>：关闭所有 Zookeeper 服务，修改配置之后启动，不影响之前客户端的会话。</p></li><li><p><strong>逐个重启</strong>：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务，这是比较常用的方式。</p></li></ul><blockquote><p>3.5 版本开始支持动态扩容。</p></blockquote><h3 id="Zookeeper-对节点的-watch监听通知是永久的吗？为什么"><a href="#Zookeeper-对节点的-watch监听通知是永久的吗？为什么" class="headerlink" title="Zookeeper 对节点的 watch监听通知是永久的吗？为什么"></a><strong>Zookeeper 对节点的 watch监听通知是永久的吗？为什么</strong></h3><p>不是永久的。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</p><h3 id="dubbo和Zookeeper的关系，什么选择Zookeeper作为注册中心"><a href="#dubbo和Zookeeper的关系，什么选择Zookeeper作为注册中心" class="headerlink" title="dubbo和Zookeeper的关系，什么选择Zookeeper作为注册中心"></a>dubbo和Zookeeper的关系，什么选择Zookeeper作为注册中心</h3><p>dubbo的注册中心可以选Zookeeper，memcached，redis等。为什么选择Zookeeper，因为它的功能特性咯~</p><ul><li>命名服务：服务提供者向Zookeeper指定节点写入url，完成服务发布。</li><li>负载均衡：注册中心的承载能力有限，而Zookeeper集群配合web应用很容易达到负载均衡。</li><li>zk支持监听事件：特别适合发布/订阅的场景，dubbo的生产者和消费者就类似这场景。</li><li>数据模型简单，数据存在内存，可谓高性能。</li><li>Zookeeper其他特点都可以搬出来讲一下~</li></ul>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git、RESTful API</title>
      <link href="2021/06/24/Git-REST/"/>
      <url>2021/06/24/Git-REST/</url>
      
        <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h3><p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><p>下图展示了 Git 的工作流程：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630211311678.png" alt="image-20210630211311678"></p><h3 id="Git-工作区、暂存区和版本库"><a href="#Git-工作区、暂存区和版本库" class="headerlink" title="Git 工作区、暂存区和版本库"></a>Git 工作区、暂存区和版本库</h3><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li></ul><p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630211414031.png" alt="image-20210630211414031"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li><li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 <strong>git rm –cached <file></strong> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行 <strong>git checkout .</strong> 或者 <strong>git checkout – <file></strong> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li><li>当执行 <strong>git checkout HEAD .</strong> 或者 <strong>git checkout HEAD <file></strong> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li></ul><h3 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h3><ul><li><code>git init</code>：初始化仓库。</li><li><code>git clone</code>：拷贝一份远程仓库，也就是下载一个项目。</li><li><code>git remote（远程仓库操作）add origin ***.git</code>：添加文件到仓库。</li><li><code>git push -u origin master</code></li><li><code>git push origin dev</code>：推送到远程仓库的dev分支。</li><li><code>git log</code>：查看历史提交记录。</li><li><code>git log --graph --pretty=oneline --abbrev-commit</code></li><li><code>git status</code>：查看仓库当前的状态，显示有变更的文件。</li><li><code>git diff</code>： 比较文件的不同，即暂存区和工作区的差异。</li><li><code>git add *</code>：添加文件到仓库。</li><li><code>git commit -m &quot;message&quot;</code>：提交暂存区到本地仓库。</li><li>commit之后又改了一个小bug，但是又不想增加一个commit，可以用：<code>git commit --amend --no-edit</code>，直接将改动添加到上一次的commit中。</li><li><code>git push</code>：上传远程代码并合并。</li><li><code>git pull</code>：下载远程代码并合并。</li><li><code>touch .gitignore</code>：忽略git不必要提交的文件。</li><li><code>git mv</code>：移动或重命名工作区文件。</li><li><code>git rm</code>：删除工作区文件。</li></ul><h3 id="Git-标签管理"><a href="#Git-标签管理" class="headerlink" title="Git 标签管理"></a>Git 标签管理</h3><ul><li>首先切换到需要打标签的分支上，然后使用<code>git tag v1.0</code>就可以在当前commit打上v1.0的标签。</li><li><code>git tag v1.0 commitID</code> 对特定commit打标签。</li><li>打标签时加上message：<code>git tag -a &lt;tagname&gt; -m &quot;message&quot;</code>。</li><li><code>git tag</code> 查看所有标签。</li><li><code>git show [tagname]</code> 查看标签详细信息。</li><li><code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签到远程仓库。</li><li><code>git push origin --tags</code>可以推送全部未推送过的本地标签。</li><li><code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签。</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签（先从本地删除）。</li></ul><h3 id="Git-撤销与回滚"><a href="#Git-撤销与回滚" class="headerlink" title="Git 撤销与回滚"></a>Git 撤销与回滚</h3><ul><li><strong>暂存区</strong>：<code>git add</code>之后commit之前存在的区域；<strong>工作区</strong>：<code>git commit</code>之后存在的区域；<strong>远程仓库</strong>：<code>git push</code>之后；</li><li>作了修改，但还没<code>git add</code>，撤销到上一次提交：<code>git checkout -f -- filename</code>；<code>git checkout -f -- .</code></li><li>作了修改，并且已经<code>git add</code>，但还没<code>git commit</code>：<ul><li>先将暂存区的修改撤销：<code>git reset HEAD filename</code>/<code>git reset HEAD</code>；此时修改只存在于工作区，变为了 “unstaged changes”；</li><li>再利用上面的checkout命令从工作区撤销修改。</li></ul></li><li><code>git add</code>之后，作了修改，想丢弃这次修改：<code>git checkout -f --filename</code>会回到最近一次<code>git add</code>。</li><li>作了修改，并且已经<code>git commit</code>了，想撤销这次的修改：<ul><li><code>git revert commitID</code>. 其实，<code>git revert</code>可以用来撤销任意一次的修改，不一定要是最近一次。</li><li><code>git reset --hard commitID</code>/<code>git reset --hard HEAD^</code>（HEAD表示当前版本，几个^表示倒数第几个版本，倒数第100个版本可以用HEAD~100）；参数<code>--hard</code>：强制将暂存区和工作区都同步到指定的版本。</li><li><code>git reset</code>和<code>git revert</code>的区别是：reset是用来回滚的，将HEAD的指针指向了想要回滚的版本，作为最新的版本，而后面的版本也都没有了；而revert只是用来撤销某一次更改，对之后的更改并没有影响。</li><li>然后再用<code>git push -f</code>提交到远程仓库。</li></ul></li></ul><h3 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h3><ul><li>创建分支: <code>git branch test</code>。</li><li>切换分支: <code>git checkout test</code>。</li><li>创建并切换分支：<code>git checkout -b test。</code></li><li>将test分支的更改合并到master分支：先在test分支上commit、push，再：<code>git checkout master</code>; <code>git merge test。</code></li><li>如果合并时产生冲突：先手动解决冲突，再合并。</li><li>删除分支：<code>git branch -d test</code>。</li><li><code>git stash</code><ul><li>如果当前分支还有任务没有做完，也不想提交，但此时需要切换或者创建其它分支，就可以使用stash将当前分支的所有修改（包括暂存区）先储藏起来；然后就可以切换到其它分支。</li><li>在其它分支工作完成之后，首先切换回原来的分支，然后使用<code>git stash list</code>命令查看。</li><li>可以使用<code>git stash apply &lt;stash number&gt;</code>恢复之前储藏的工作现场，再使用<code>git stash drop &lt;stash number&gt;</code>删除掉储藏的内容。</li><li>也可以直接用<code>git stash pop</code>恢复并删除内容。</li></ul></li><li>如果在其它分支上做了一个修改（比如修复了一个bug，这次修改有一个commitID），想要将这次修改应用到当前分支上，可以使用：<code>git cherry-pick commitID</code>，可以复制一个特定的提交到当前分支。</li></ul><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>REST指Representational State Transfer，可以翻译为“表现层状态转化”。</p><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><ul><li>对网络上的所有资源，都有一个<strong>统一资源标识符</strong> URI(Uniform Resource Identifier)；</li><li>这些资源可以有多种表现形式，即REST中的“表现层”Representation，比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现。URI只代表资源的实体，不代表它的形式；</li><li>“无状态(Stateless)”思想：服务端不应该保存客户端状态，只需要处理当前的请求，不需了解请求的历史，客户端每一次请求中包含处理该请求所需的一切信息；</li><li>客户端使用HTTP协议中的 GET/POST/PUT/DELETE 方法对服务器的资源进行操作，即REST中的”状态转化“。</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li>URL设计<ul><li>最好只使用名词，而使用 GET/POST/PUT/DELETE 方法的不同表示不同的操作；比如使用<code>POST /user</code>代替<code>/user/create</code>。</li><li>GET：获取资源；POST：新建/更新资源；PUT：更新资源；DELETE：删除资源。</li><li>对于只支持GET/POST的客户端，使用<code>X-HTTP-Method-Override</code>属性，覆盖POST方法。</li><li>避免多级URL，比如使用<code>GET /authors/12?categories=2</code>代替<code>GET /authors/12/categories/2</code>。</li><li>避免在URI中带上版本号。不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI，版本号可以在HTTP请求头信息的Accept字段中进行区分。</li></ul></li><li>状态码：服务器应该返回尽可能精确的状态码，客户端只需查看状态码，就可以判断出发生了什么情况。见计算机网络部分 – <a href="Computer%20Network.md#HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81">HTTP请求有哪些常见状态码？</a>。</li><li>服务器回应：在响应中放上其它API的链接，方便用户寻找。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="2021/06/18/Spring/"/>
      <url>2021/06/18/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring知识点脑图"><a href="#Spring知识点脑图" class="headerlink" title="Spring知识点脑图"></a>Spring知识点脑图</h2><p><a href="https://www.processon.com/mindmap/6107abda7d9c082e3b11d73f">Spring思维脑图 ProcessOn Mind</a></p><h2 id="Spring基本概念"><a href="#Spring基本概念" class="headerlink" title="Spring基本概念"></a>Spring基本概念</h2><h3 id="Spring-IOC-的理解"><a href="#Spring-IOC-的理解" class="headerlink" title="Spring IOC 的理解"></a>Spring IOC 的理解</h3><p>IOC （Inverse of Control）控制反转。将之前程序中需要手动创建对象的操作，交由 Spring 框架来实现，创建对象的操作被反转到了 Spring 框架。对象的生命周期由 Spring 来管理，只需要直接从 Spring 那里去获取一个对象。</p><h3 id="Spring-DI-的理解"><a href="#Spring-DI-的理解" class="headerlink" title="Spring DI 的理解"></a>Spring DI 的理解</h3><p>DI（Dependency Injection）依赖注入。Spring 框架创建 Bean 对象时，动态的将依赖对象注入到 Bean 组件中，实现依赖对象的注入。</p><h3 id="BeanFactory-接口和-ApplicationContext-接口不同点"><a href="#BeanFactory-接口和-ApplicationContext-接口不同点" class="headerlink" title="BeanFactory 接口和 ApplicationContext 接口不同点"></a>BeanFactory 接口和 ApplicationContext 接口不同点</h3><ol><li>ApplicationContext 接口继承 BeanFactory 接口，Spring 核心工厂是 BeanFactory，BeanFactory 采取延迟加载，第一次 getBean 时才会初始化 Bean，而ApplicationContext 是会在加载配置文件时初始化 Bean。 </li><li>ApplicationContext 是对 BeanFactory 扩展，它可以进行国际化处理、 事件传递和 Bean 自动装配以及各种不同应用层的 Context 实现。</li></ol><p>开发中基本都在使用 ApplicationContext，Web 项目使 用 WebApplicationContext ，很少用到 BeanFactory。</p><h3 id="Spring-核心类以及作用"><a href="#Spring-核心类以及作用" class="headerlink" title="Spring 核心类以及作用"></a>Spring 核心类以及作用</h3><ul><li>BeanFactory：产生一个新的实例，可以实现单例模式；</li><li>BeanWrapper：提供统一的 get 及 set 方法；</li><li>ApplicationContext：提供框架的实现，包括 BeanFactory 的所有功能</li></ul><h3 id="Spring-的事务"><a href="#Spring-的事务" class="headerlink" title="Spring 的事务"></a>Spring 的事务</h3><p>事务是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作。这些操作作为一个整体一起向系统提交，要么都执行，要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）。 </p><p>事务特性：ACID </p><ul><li>原子性：事务不可分割 。</li><li>一致性：事务执行的前后，数据完整性保持一致 。</li><li> 隔离性：一个事务执行的时候，不应该受到其他事务的打扰。</li><li>持久性：事务一旦结束，数据就永久的保存到数据库。</li></ul><p>Spring 中有自己的事务管理机制，使用 TransactionMananger 进行管理，可以通过 Spring 的注入来完成此功能。Spring提供了以下几个事务处理的类： </p><ol><li>TransactionDefinition：事务属性定义，定义了事务传播行为类型（ 7 种），事务隔离类型（ 5 种），超时设置、事务隔离级别、只读、回滚规则)。 </li><li>TranscationStatus：代表了当前的事务，可以提交、回滚。</li><li>PlatformTransactionManager：这个是 Spring 提供的用于管理事务的基础接口。通过这个接口，Spring 可以为如 JDBC、Hibernate 等提供对应的事务管理器，具体的实现就是各个平台来实现。</li></ol><p>事务定义样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TransactionDefinition td = <span class="keyword">new</span> TransactionDefinition();</span><br><span class="line">TransactionStatus ts = transactionManager.getTransaction(td); <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//do sth</span></span><br><span class="line">transactionManager.commit(ts);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">transactionManager.rollback(ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-的事务实现方式"><a href="#Spring-的事务实现方式" class="headerlink" title="Spring 的事务实现方式"></a>Spring 的事务实现方式</h3><p>Spring 事务管理实现方式有两种：编程式事务管理和声明式事务。</p><p><strong>编程式事务</strong></p><p>使用 TransactionTemplate 或使用底层的 PlatformTransactionManager， 显式的方式调用 beginTransaction() 开启事务、commit() 提交事务、 rollback() 回滚事务，编写代码形式来声明事务，粒度较细，比较灵活，但开发起来比较繁琐： 每次都要开启、提交、回滚。</p><p><strong>声明式事务</strong></p><p>底层是建立在 Spring AOP 的基础上，在方法执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。</p><p>声明式事务的优点：不需要编程，减少了代码的耦合，在配置文件中配置并在目标方法上添加 @Transactional 注解来实现。</p><h3 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h3><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为?"></a>Spring 事务中哪几种事务传播行为?</h3><p><strong>支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><h3 id="Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor = Exception.class)注解了解吗？"></a>@Transactional(rollbackFor = Exception.class)注解了解吗？</h3><p>我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p><p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p><p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>AOP（Aspect Oriented Programming）面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的频率。即通过分离横切关注点来增加程序的模块化。AOP 在不修改现有代码的情况下对现有代码添加功能，这个是 AOP 最重要的能力。</p><p>AOP：面向切面编程，允许程序模块化横向切割关注点， 或横切典型的责任划分，如日志和事务管理。</p><h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h3 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h3><ol><li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ol><p> <strong>将一个类声明为Spring的 bean 的注解有哪些?</strong></p><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="RestController-vs-Controller"><a href="#RestController-vs-Controller" class="headerlink" title="@RestController vs @Controller"></a>@RestController vs @Controller</h3><h3 id="Spring-的通知类型"><a href="#Spring-的通知类型" class="headerlink" title="Spring 的通知类型"></a>Spring 的通知类型</h3><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过 Spring AOP 框架触发的代码段。</p><p>Spring 的通知类型总共有 5 种：前置通知、环绕通知、后置通知、异常通知、 最终通知。</p><ul><li>前置通知（Before advice）：在目标方法执行之前执行的通知。在某连接点（ join point ）之前执行的通知，但这个通知不能阻止连接点前的 执行（除非它抛出一个异常）。 </li><li>环绕通知（Around Advice）： 在目标方法执行之前和之后都可以执行额外代码的通知。也可以选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 </li><li>后置通知（After (finally) advice）：目标方法执行之后（某连接点退 出的时候）执行的通知（不论是正常返回还是异常退出）。 </li><li>异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。 </li><li>最终通知（After returning advice）： 在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li></ul><h3 id="Spring-通知类型使用场景分别有哪些"><a href="#Spring-通知类型使用场景分别有哪些" class="headerlink" title="Spring 通知类型使用场景分别有哪些"></a>Spring 通知类型使用场景分别有哪些</h3><table><thead><tr><th>通知类型</th><th>使用场景</th></tr></thead><tbody><tr><td>环绕通知</td><td>控制事务 权限控制</td></tr><tr><td>后置通知 记录日志（方法已经成功调用）</td><td>记录日志（方法已经成功调用</td></tr><tr><td>异常通知</td><td>异常处理 控制事务</td></tr><tr><td>最终通知</td><td>记录日志（方法已经调用，但不一定成功）</td></tr></tbody></table><h3 id="Spring-Beans-的理解"><a href="#Spring-Beans-的理解" class="headerlink" title="Spring Beans 的理解"></a>Spring Beans 的理解</h3><ul><li>Spring Beans 是被实例的，组装的及被 Spring 容器管理的 Java 对象； </li><li>Spring Beans 会被 Spring 容器自动完成 @bean 对象的实例化 ；</li><li>Spring 框架定义的 Beans 都是默认为单例，也可以配置为多例。</li></ul><h3 id="Spring-的优点"><a href="#Spring-的优点" class="headerlink" title="Spring 的优点"></a>Spring 的优点</h3><ul><li>提供控制反转能力，将对象的创建交给了 Spring，降低了代码耦合性、 侵入性。</li><li>Spring 是 POJO 编程，使得可持续构建和可测试能力提高 。</li><li>Spring 是开源免费的 。</li><li>方便集成各种优秀的框架。</li></ul><h3 id="Spring-和-Struts-的区别"><a href="#Spring-和-Struts-的区别" class="headerlink" title="Spring 和 Struts 的区别"></a>Spring 和 Struts 的区别</h3><p><strong>Spring</strong>： </p><ol><li>具备 IOC/DI、AOP 等通用能力，提高研发效率 ；</li><li>除了支持 Web 层建设以外，还提供了 J2EE 整体服务 ；</li><li>方便与其他不同技术结合使用，例如：Hibernate，Mybatis 等 ；</li><li>Spring 拦截机制是方法级别 。</li></ol><p><strong>Struts</strong>： </p><ol><li>是一个基于 MVC 模式的一个 Web 层的处理器；</li><li>Struts 拦截机制是类级别。</li></ol><h3 id="Spring-框架组成"><a href="#Spring-框架组成" class="headerlink" title="Spring 框架组成"></a>Spring 框架组成</h3><p>主要七大模块：</p><ol><li>Spring AOP 面向切面编程 </li><li>Spring ORM Hibernate|mybatis|JDO </li><li>Spring Core 提供 Bean 工厂 IOC </li><li>Spring Dao JDBC 支持 </li><li>Spring Context 提供了关于 UI 支持、邮件支持等 </li><li>Spring Web 提供了 Web 的一些工具类的支持 </li><li> Spring MVC 提供了 Web MVC、Webviews、JSP、PDF、Export</li></ol><h3 id="BeanFactory-的理解"><a href="#BeanFactory-的理解" class="headerlink" title="BeanFactory 的理解"></a>BeanFactory 的理解</h3><ul><li>BeanFactory 用于管理 Bean 的，通过 BeanFactory 可以从 Spring 中获取注册到其中的 Bean 来使用。 </li><li>BeanFactory 实现基于工厂模式，提供了控制反转功能，把应用的配置和依赖从真正的应用代码中分离。 </li><li>最 常 用 的 BeanFactory 实 现 是 XmlBeanFactory 、 XmlWebApplicationContext、ClassPathXmlApplicationContext 等。</li></ul><h3 id="Spring-中的-Web-模块"><a href="#Spring-中的-Web-模块" class="headerlink" title="Spring 中的 Web 模块"></a>Spring 中的 Web 模块</h3><p>Spring 的 Web 模块是构建在 application context 模块基础之上，提供一个适合 Web 应用的上下文。 </p><p>这个模块也包括支持多种面向 Web 的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。</p><h3 id="BeanFactory-和-Application-contexts-区别"><a href="#BeanFactory-和-Application-contexts-区别" class="headerlink" title="BeanFactory 和 Application contexts 区别"></a>BeanFactory 和 Application contexts 区别</h3><ol><li>BeanFactory 提供了最简单的容器功能，只提供了实例化对象和拿对象的功能。 </li><li>Application contexts 应用上下文，继承 BeanFactory 接口，它是 Spring 的一个更高级的容器，提供了更多有用的功能。</li></ol><h3 id="Spring-依赖注入的理解"><a href="#Spring-依赖注入的理解" class="headerlink" title="Spring 依赖注入的理解"></a>Spring 依赖注入的理解</h3><p>通常情况下，当需要调用一个其他对象的时候，采用 new 的方式进行对象的创 建，导致对象之间耦合性增强，后续代码维护比较困难。</p><p>Spring 框架提供了依赖注入的能力，对象统一由 Spring 容器创建，Spring 容器会负责程序之间的关系。这样控制权由应用代码转移到 Spring 容器，控制权发生了反转，就是 Spring 的控制反转。创建依赖对象的工作交由 Spring 容器来完成，然后注入调用者，这就是依赖注入。</p><h3 id="Bean-装配"><a href="#Bean-装配" class="headerlink" title="Bean 装配"></a>Bean 装配</h3><p>Spring 容器根据 Bean 之间的依赖关系，将 Bean 通过依赖注入进行组装在一起，这就是 Bean 装配。</p><h3 id="Bean-的自动装配"><a href="#Bean-的自动装配" class="headerlink" title="Bean 的自动装配"></a>Bean 的自动装配</h3><p>在 Spring 框架里面是使用 <constructor-arg>  和 <property> 配置方式进行依赖注入，如果 Bean 对象较多的情况下注入工作就比较麻烦，XML 文件会变得很难维护，所以为了简化 XML 配置文件，提高开发效率可以使用 @autowire（自动装配），能通过 Bean 工厂自动处理 Bean 之间的协作。</p><h3 id="自动装配有几种方式"><a href="#自动装配有几种方式" class="headerlink" title="自动装配有几种方式"></a>自动装配有几种方式</h3><p>有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。 </p><ol><li>no：默认设置，表示没有自动装配，通过显式设置 Bean 引用来进行装配。</li><li>byName：根据 Bean 的名称注入对象依赖项。</li><li>byType：根据类型注入对象依赖项。</li><li>constructor：通过调用类的构造函数来注入依赖项。</li><li>autodetect：先尝试 constructor 来自动装配，若不成功，则使用 byType 方式。</li></ol><h3 id="基于注解的容器配置"><a href="#基于注解的容器配置" class="headerlink" title="基于注解的容器配置"></a>基于注解的容器配置</h3><p>开发者通过在相应的类、方法或属性上使用注解的方式，直接在组件类中进行配置， 而不是使用 XML 表述 Bean 的装配关系。</p><h3 id="JdbcTemplate-类的作用"><a href="#JdbcTemplate-类的作用" class="headerlink" title="JdbcTemplate 类的作用"></a>JdbcTemplate 类的作用</h3><p>JDBCTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><h3 id="Aspect-切面"><a href="#Aspect-切面" class="headerlink" title="Aspect 切面"></a>Aspect 切面</h3><p>AOP 核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有 一组 API 提供横切功能。比如，一个日志模块可以被称作日志的 AOP 切面。 根据需求的不同，一个应用程序可以有若干切面。在 Spring AOP 中，切面通过带有 @Aspect 注解的类实现。</p><h3 id="Spring-AOP-中的织入的理解"><a href="#Spring-AOP-中的织入的理解" class="headerlink" title="Spring AOP 中的织入的理解"></a>Spring AOP 中的织入的理解</h3><p>织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。 织入可以在编译时，加载时，或运行时完成。</p><h3 id="说说自己对于-Spring-MVC-了解"><a href="#说说自己对于-Spring-MVC-了解" class="headerlink" title="说说自己对于 Spring MVC 了解?"></a>说说自己对于 Spring MVC 了解?</h3><ul><li><p><strong>Model1 时代</strong> : 很多学 Java 后端比较晚的朋友可能并没有接触过 Model1 模式下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低</p></li><li><p><strong>Model2 时代</strong> ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View,）+Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。Model:系统涉及的数据，也就是 dao 和 bean。View：展示模型中的数据，只是用来展示。Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</p></li></ul><p>Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。于是很多JavaWeb开发相关的 MVC 框架应运而生比如Struts2，但是 Struts2 比较笨重。随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p><p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p><h3 id="Spring-MVC-的流程"><a href="#Spring-MVC-的流程" class="headerlink" title="Spring MVC 的流程"></a>Spring MVC 的流程</h3><ol><li>用户发送请求至前端控制器 DispatcherServlet </li><li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。 </li><li>处理器映射器根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器（如果有则生成）一并返回给 DispatcherServlet。</li><li>DispatcherServlet 通过 HandlerAdapter 处理器适配器调用处理器 </li><li>执行处理器（Controller，也叫后端控制器）。 </li><li>Controller 执行完成返回 ModelAndView。 </li><li>HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。 </li><li>DispatcherServlet 将 ModelAndView 传给 View Reslover 视图解析器。 </li><li>View Reslover 解析后返回具体 View。 </li><li>DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）。 </li><li>DispatcherServlet 响应用户。</li></ol><h3 id="Spring-配置文件"><a href="#Spring-配置文件" class="headerlink" title="Spring 配置文件"></a>Spring 配置文件</h3><p>Spring 配置文件是个 XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><h3 id="RequestMapping-注解用在类上的作用"><a href="#RequestMapping-注解用在类上的作用" class="headerlink" title="@RequestMapping 注解用在类上的作用"></a>@RequestMapping 注解用在类上的作用</h3><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><h3 id="把某个请求映射到特定的方法上面"><a href="#把某个请求映射到特定的方法上面" class="headerlink" title="把某个请求映射到特定的方法上面"></a>把某个请求映射到特定的方法上面</h3><p> 在方法上面加上注解 @RequestMapping，并且在这个注解里面写上要拦截的路径。</p><h3 id="Spring-对-DAO-的支持"><a href="#Spring-对-DAO-的支持" class="headerlink" title="Spring 对 DAO 的支持"></a>Spring 对 DAO 的支持</h3><p>Spring 提供的 DAO （数据访问对象）支持主要的目的是便于以标准的方式使用不同的数据访问技术。 </p><ul><li>简化 DAO 组件的开发。Spring 提供了一套抽象 DAO 类供你扩展。这些抽象类提供了一些方法，用来简化代码开发。 </li><li>IOC 容器的使用，提供了 DAO 组件与业务逻辑组件之间的解耦。所有的 DAO 组件，都由容器负责注入到业务逻辑组件中，其业务组件无须关心 DAO 组件的实现。 </li><li>面向接口编程及 DAO 模式的使用，提高了系统组件之间的解耦，降低 了系统重构的成本。 </li><li>方便的事务管理：Spring 的声明式事务管理力度是方法级。 </li><li>异常包 装 ： Spring 能够包装 Hibernate 异 常 ， 把 它 们 从 CheckedException 变为 RuntimeException；开发者可选择在恰当的 层处理数据中不可恢复的异常，从而避免烦琐的 catch/throw 及异常声明。</li></ul><h3 id="Spring事务传播类型"><a href="#Spring事务传播类型" class="headerlink" title="Spring事务传播类型"></a>Spring事务传播类型</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210804195443771.png" alt="image-20210804195443771"></p><h2 id="Spring应用场景题"><a href="#Spring应用场景题" class="headerlink" title="Spring应用场景题"></a>Spring应用场景题</h2><h3 id="Spring-配置-Bean-实例化的方式"><a href="#Spring-配置-Bean-实例化的方式" class="headerlink" title="Spring 配置 Bean 实例化的方式"></a>Spring 配置 Bean 实例化的方式</h3><ol><li>使用类构造器实例化（默认无参数） </li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.spring.b_instance.Bean1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><ol start="2"><li>使用静态工厂方法实例化（简单工厂模式） </li></ol><p>下面这段配置的含义：调用 Bean2Factory 的 getBean2 方法得到 bean2 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.heu.spring.b_instance.Bean2Factory&quot;</span> </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">factorymethod</span>=<span class="string">&quot;getBean2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><ol start="3"><li>使用实例工厂方法实例化（工厂方法模式） </li></ol><p>创建工厂实例 bean3Facory，再通过工厂实例创建目标 bean 实例 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean3Factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.heu.spring.b_instance.Bean3Factory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">id=&quot;bean3&quot; factorybean=&quot;bean3Factory&quot; factorymethod=&quot;getBean3&quot;&gt;<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean-注入属性有哪几种方式"><a href="#Bean-注入属性有哪几种方式" class="headerlink" title="Bean 注入属性有哪几种方式"></a>Bean 注入属性有哪几种方式</h3><ol><li><p>属性注入方式，通过 setXXX() 方法注入 Bean 的属性值或者依赖对象。 </p></li><li><p>构造函数注入方式，使用的前提：Bean 必须提供带参的构造函数 。</p></li><li><p>工厂方法注入方式 。</p></li></ol><h3 id="Spring-中实现时间处理"><a href="#Spring-中实现时间处理" class="headerlink" title="Spring 中实现时间处理"></a>Spring 中实现时间处理</h3><p>在 applicationContext.xml 中配置事件源、监听器，先得到事件源，调用事件源的方法，通知监听器。 </p><h3 id="Spring-中更高效的使用-JDBC"><a href="#Spring-中更高效的使用-JDBC" class="headerlink" title="**Spring 中更高效的使用 JDBC **"></a>**Spring 中更高效的使用 JDBC **</h3><p>传统的 JDBC 实现有两个不足之处： </p><ul><li><p>连接需要自己管理操作</p></li><li><p>JDBC 操作代码封装与编写重复实现 </p></li></ul><p>JdbcTemplate 的优点有： </p><ol><li><p>配置基于模板化处理 </p></li><li><p>JdbcTemplate 是线程安全类 </p></li><li><p>实例化操作比较简单，仅需要传递 DataSource </p></li><li><p>自动完成资源的创建和释放工作 </p></li><li><p>对 JDBC 的核心流程进行了封装，简化了对 JDBC 的操作 </p></li><li><p>创建一次 JdbcTemplate，到处可用，避免重复开发</p></li></ol><h3 id="设计模式在-Spring-框架中的使用"><a href="#设计模式在-Spring-框架中的使用" class="headerlink" title="设计模式在 Spring 框架中的使用"></a><strong>设计模式在 Spring 框架中的使用</strong></h3><ol><li><p>工厂模式：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例。 </p></li><li><p>单例模式：Bean 默认为单例模式。</p></li><li><p>代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术。 </p></li><li><p>模板方法：用来解决代码重复的问题。比如：RestTemplate, JmsTemplate, JpaTemplate。 </p></li><li><p>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如 Spring 中 listener 的实现：ApplicationListener。 </p></li></ol><h3 id="Spring-框架的优点"><a href="#Spring-框架的优点" class="headerlink" title="Spring 框架的优点"></a><strong>Spring 框架的优点</strong></h3><ol><li><p>非侵入式设计：代码与框架的依赖性比较低。 </p></li><li><p>代码解耦：提供控制反转能力，对象的创建和依赖关系的维护工作都交给 Spring 容器的管理，大大的降低了对象之间的耦合性。 </p></li><li><p>可复用性提高：支持 AOP ，允许将一些通用能力（打印日志、事务处理、 安全操作等）进行集中式处理。 </p></li><li><p>MVC 框架：Spring 的 Web 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。 </p></li><li><p>事务支持方便：Spring 提供一个持续的事务管理接口，配置化完成对事务的管理，减少手动编程。 </p></li><li><p>异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC、Hibernate or JDO 抛出的）转化为一致的 unchecked 异常。 </p></li><li><p>方便程序测试：提供了对 Junit4 的支持，可以通过注解方便的测试 Spring 程序。</p></li></ol><h3 id="哪种依赖注入方式建议使用，构造器注入，还是-Setter-方法注-入"><a href="#哪种依赖注入方式建议使用，构造器注入，还是-Setter-方法注-入" class="headerlink" title="哪种依赖注入方式建议使用，构造器注入，还是 Setter 方法注 入"></a><strong>哪种依赖注入方式建议使用，构造器注入，还是 Setter 方法注</strong> <strong>入</strong></h3><p>两种依赖方式都可以使用，构造器注入和 setter 方法注入。最好的解决方案是用构造器参数实现强制依赖，setter 方法实现可选依赖。 </p><h3 id="定义类的作用域"><a href="#定义类的作用域" class="headerlink" title="定义类的作用域"></a><strong>定义类的作用域</strong></h3><p>可以通过 Bean 定义中的 scope 属性来定义。如，当 Spring 要在需要的时候每次生产一个新的 Bean 实例 ， Bean 的 scope 属性被指定 为 prototype。另一方面，一个 Bean 每次使用的时候必须返回同一个实例，这个 Bean 的 scope 属性必须设为 singleton。 </p><h3 id="Spring-支持的几种-Bean-的作用域"><a href="#Spring-支持的几种-Bean-的作用域" class="headerlink" title="Spring 支持的几种 Bean 的作用域"></a><strong>Spring 支持的几种 Bean 的作用域</strong></h3><p>Spring 框架支持以下五种 Bean 的作用域： </p><ol><li><p>singleton：Bean 在每个 Spring IOC 容器中只有一个实例。 </p></li><li><p>prototype：一个 Bean 的定义可以有多个实例。 </p></li><li><p>request：每次 http 请求都会创建一个 Bean，该作用域仅在基于 Web 的 Spring ApplicationContext 情形下有效。 </p></li><li><p>session：在一个 HTTP Session 中，一个 Bean 定义对应一个实例。 该作用域仅在基于 Web 的 Spring ApplicationContext 情形下有效。</p></li><li><p>global-session：在一个全局的 HTTP Session 中，一个 Bean 定义对 应一个实例。该作用域仅在基于 Web 的 Spring ApplicationContext 情形下有效。</p></li></ol><p>缺省的 Spring Bean 的作用域是 Singleton。</p><h3 id="可以在-Spring-中注入一个-null-和一个空字符串吗"><a href="#可以在-Spring-中注入一个-null-和一个空字符串吗" class="headerlink" title="可以在 Spring 中注入一个 null 和一个空字符串吗"></a><strong>可以在 Spring 中注入一个 null 和一个空字符串吗</strong></h3><p>可以</p><h3 id="Spring-中如何注入一个-Java-集合"><a href="#Spring-中如何注入一个-Java-集合" class="headerlink" title="Spring 中如何注入一个 Java 集合"></a><strong>Spring 中如何注入一个 Java 集合</strong></h3><p>Spring 提供以下几种集合的配置元素： </p><ol><li><p><list> 类型用于注入一列值，允许有相同的值。 </p></li><li><p><set> 类型用于注入一组值，不允许有相同的值。 </p></li><li><p><map> 类型用于注入一组键值对，键和值都可以为任意类型。 </p></li><li><p><props> 类型用于注入一组键值对，键和值都只能为 String 类型。</p></li></ol><h3 id="什么是基于-Java-的-Spring-注解配置-给一些注解的例子"><a href="#什么是基于-Java-的-Spring-注解配置-给一些注解的例子" class="headerlink" title="什么是基于 Java 的 Spring 注解配置? 给一些注解的例子"></a><strong>什么是基于 Java 的 Spring 注解配置? 给一些注解的例子</strong></h3><p>基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring 配置而非通过 XML 文件.</p><p>以 @Configuration 注解为例，它用来标记类可以当做一个 Bean 的定义，被 Spring IOC 容器使用。另一个例子是 @Bean 注解，它表示此方法将要返回一 个对象，作为一个 Bean 注册进 Spring 应用上下文。</p><h3 id="你更倾向用那种事务管理类型"><a href="#你更倾向用那种事务管理类型" class="headerlink" title="你更倾向用那种事务管理类型"></a><strong>你更倾向用那种事务管理类型</strong></h3><p>声明式事务管理，因为它对应用代码侵入性很少，更符合一个无侵入的轻量级容器的思想。 声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许 你通过代码控制事务）少了一点灵活性。</p><h3 id="Bean-的调用方式有哪些"><a href="#Bean-的调用方式有哪些" class="headerlink" title="Bean 的调用方式有哪些"></a><strong>Bean 的调用方式有哪些</strong></h3><p>有三种方式可以得到 Bean 并进行调用。</p><p><strong>1. 使用 BeanWrapper</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld hw=<span class="keyword">new</span> HelloWorld(); </span><br><span class="line"></span><br><span class="line">BeanWrapper bw=<span class="keyword">new</span> BeanWrapperImpl(hw); </span><br><span class="line"></span><br><span class="line">bw.setPropertyvalue(”msg”,”HelloWorld”); </span><br><span class="line"></span><br><span class="line">system.out.println(bw.getPropertyCalue(”msg”)); </span><br></pre></td></tr></table></figure><p><strong>2. 使用 BeanFactory</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InputStream is=<span class="keyword">new</span> FileInputStream(”config.xml”);</span><br><span class="line"></span><br><span class="line">XmlBeanFactory factory=<span class="keyword">new</span> XmlBeanFactory(**is**); </span><br><span class="line"></span><br><span class="line">HelloWorld hw=(HelloWorld) factory.getBean(”HelloWorld”); </span><br><span class="line"></span><br><span class="line">system.out.println(hw.getMsg()); </span><br></pre></td></tr></table></figure><p><strong>3. 使用 ApplicationConttext</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext actx=<span class="keyword">new</span> FleSystemXmlApplicationContext(”config.xml”); </span><br><span class="line"></span><br><span class="line">HelloWorld hw=(HelloWorld) actx.getBean(”HelloWorld”); </span><br><span class="line"></span><br><span class="line">System.out.println(hw.getMsg()); </span><br></pre></td></tr></table></figure><p>使用 @ResponseBody 注解。</p><h3 id="Spring-MVC-里面拦截器是怎么写的"><a href="#Spring-MVC-里面拦截器是怎么写的" class="headerlink" title="Spring MVC 里面拦截器是怎么写的"></a><strong>Spring MVC 里面拦截器是怎么写的</strong></h3><p>有两种写法，一种是实现接口，另外一种是继承适配器类，然后在 Spring MVC 的配置文件中配置拦截器即可.</p><h3 id="当一个方法向-AJAX-返回特殊对象，譬如-Object、List-等，需要做什么处理"><a href="#当一个方法向-AJAX-返回特殊对象，譬如-Object、List-等，需要做什么处理" class="headerlink" title="当一个方法向 AJAX 返回特殊对象，譬如 Object、List 等，需要做什么处理"></a><strong>当一个方法向 AJAX 返回特殊对象，譬如 Object、List 等，需要</strong>做什么处理</h3><p>加上 @ResponseBody 注解。</p><h3 id="如何使用-Spring-MVC-完成-JSON-操作"><a href="#如何使用-Spring-MVC-完成-JSON-操作" class="headerlink" title="如何使用 Spring MVC 完成 JSON 操作"></a><strong>如何使用 Spring MVC 完成 JSON 操作</strong></h3><ol><li><p>配置 MappingJacksonHttpMessageConverter </p></li><li><p>使用 @RequestBody 注解或 ResponseEntity 作为返回值</p></li></ol><h3 id="Spring-MVC-常用的一些注解"><a href="#Spring-MVC-常用的一些注解" class="headerlink" title="Spring MVC 常用的一些注解"></a><strong>Spring MVC 常用的一些注解</strong></h3><ol><li><p>@RequestMapping：处理请求地址映射的注解，可用于类或方法上。 </p></li><li><p>@PathVariable：绑定 URI 模板变量值是用来获得请求 url 中的动态参数。 </p></li><li><p>@RequestParam：用于将指定的请求参数赋值给方法中的形参。</p></li><li><p>@RequestBody：读取 Request 请求的 body 部分数据。 </p></li><li><p>@ResponseBody：用于将 Controller 的方法返回的对象，通过适当的 HttpMessageConverter 转换为指定格式后，写入到 Response 对象的 body 数据区。</p></li></ol><h2 id="Spring-深度理解"><a href="#Spring-深度理解" class="headerlink" title="Spring 深度理解"></a>Spring 深度理解</h2><h3 id="Spring-的生命周期"><a href="#Spring-的生命周期" class="headerlink" title="Spring 的生命周期"></a><strong>Spring 的生命周期</strong></h3><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li><li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><ol><li>实例化对象；</li><li>填充属性值及引用；</li><li>调用 <code>BeanNameAware</code> 的 <code>setBeanName(String name)</code> 设置 bean 的 id；</li><li>调用 <code>BeanFactoryAware</code> 的 <code>setBeanFactory(BeanFactory beanFactory)</code> 设置 <code>BeanFactory</code> Bean工厂；</li><li>同上：<code>ApplicationContextAware``setApplicationContext(ApplicationContext applicationContext)</code>；</li><li>如果实现 <code>BeanPostProcessor</code>，则 调用 postProcessBeforeInitialization() 初始化前的后置处理方法；</li><li>如果实现了 <code>InitializingBean</code> 接口，则使用 <code>afterPropertiesSet()</code> 来初始化属性；</li><li>如果实现 <code>BeanPostProcessor</code>，则 调用 postProcessAfterInitialization() 初始化后的后置处理方法；</li><li>此时，bean 就可以使用了；</li><li><code>DisposableBean</code>接口 <code>destroy()</code> 销毁bean。不过在Spring5.0开始，DisposableBean.destroy() 已经是过时的方法了，可直接使用 close()。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210807163127693.png" alt="image-20210807163127693" style="zoom:150%;" /><h3 id="Spring-如何处理线程并发问题"><a href="#Spring-如何处理线程并发问题" class="headerlink" title="Spring 如何处理线程并发问题"></a><strong>Spring 如何处理线程并发问题</strong></h3><p>Spring 使用 ThreadLocal 解决线程安全问题。</p><p>ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程 序设计和编写难度相对较大。</p><p>而 ThreadLocal 则从另一个角度来解决多线程的并发访问。 ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。 ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而 ThreadLocal 采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p><h3 id="核心容器（应用上下文）模块的理解"><a href="#核心容器（应用上下文）模块的理解" class="headerlink" title="核心容器（应用上下文）模块的理解"></a><strong>核心容器（应用上下文）模块的理解</strong></h3><p>这是基本的 Spring 模块，提供 Spring 框架的基础功能，BeanFactory 是任何以 Spring 为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring 成为一个容器。</p><h3 id="为什么说-Spring-是一个容器"><a href="#为什么说-Spring-是一个容器" class="headerlink" title="为什么说 Spring 是一个容器"></a><strong>为什么说 Spring 是一个容器</strong></h3><p>Spring 容器是整个 Spring 框架的核心，通常我们说的 Spring 容器就是 Bean 工厂，Bean 工厂负责创建和初始化 Bean、装配 Bean 并且管理应用程序中 的 bean.spring 中 提供了两个核心接 口 — BeanFactory 和 ApplicationContext，ApplicationContext 是 BeanFactory 子接口，它提供了比 BeanFactory 更完善的功能。</p><h3 id="Spring-框架中的单例-Beans-是线程安全的么"><a href="#Spring-框架中的单例-Beans-是线程安全的么" class="headerlink" title="Spring 框架中的单例 Beans 是线程安全的么"></a><strong>Spring 框架中的单例 Beans 是线程安全的么</strong></h3><p>Spring 框架并没有对单例 Bean 进行任何多线程的封装处理。关于单例 Bean 的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring Bean 并没有可变的状态(比如 Service 类和 DAO 类)，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。如果你的 Bean 有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多 态 Bean 的作用域由“singleton”变为“prototype”。</p><h3 id="什么是-Spring-的内部-Bean"><a href="#什么是-Spring-的内部-Bean" class="headerlink" title="什么是 Spring 的内部 Bean"></a><strong>什么是 Spring 的内部 Bean</strong></h3><p>当一个 Bean 仅被用作另一个 Bean 的属性时，它能被声明为一个内部 Bean， 为了定义 inner Bean，在 Spring 的基于 XML 的配置元数据中，可以 在 <property/> 或 <constructor-arg/> 元素内使用 <bean/> 元素，内部 Bean 通常是匿名的，它们的 Scope 一般是 prototype。</p><h3 id="自动装配有哪些局限性"><a href="#自动装配有哪些局限性" class="headerlink" title="自动装配有哪些局限性"></a><strong>自动装配有哪些局限性</strong></h3><ol><li><p>重写： 你仍需用 <constructor-arg> 和 <property> 配置来定义依赖，意味着总要重写自动装配。 </p></li><li><p>基本数据类型：不能自动装配简单的属性，如基本数据类型、String 字符串和类。 </p></li><li><p>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。 </p></li></ol><h3 id="IOC-的优点是什么"><a href="#IOC-的优点是什么" class="headerlink" title="IOC 的优点是什么"></a>IOC 的优点是什么</h3><p>IOC 或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和 JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器支持加载服务时的饿汉式初始化和懒加载。 </p><h3 id="Spring-框架的事务管理有哪些优点"><a href="#Spring-框架的事务管理有哪些优点" class="headerlink" title="Spring 框架的事务管理有哪些优点"></a><strong>Spring 框架的事务管理有哪些优点</strong></h3><ol><li><p>它为不同的事务 API 如 JTA、JDBC、Hibernate、JPA 和 JDO，提供一个不变的编程模式。 </p></li><li><p>它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API。 </p></li><li><p>它支持声明式事务管理。 </p></li><li><p>它和 Spring 各种数据访问抽象层很好得集成。</p></li></ol><h3 id="在-Spring-AOP-中，关注点和横切关注的区别是什么"><a href="#在-Spring-AOP-中，关注点和横切关注的区别是什么" class="headerlink" title="在 Spring AOP 中，关注点和横切关注的区别是什么"></a>在 Spring AOP 中，关注点和横切关注的区别是什么</h3><ol><li><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 </p></li><li><p>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响 整个应用，比如日志、安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。 </p></li></ol><h3 id="Spring-AOP-的底层实现原理"><a href="#Spring-AOP-的底层实现原理" class="headerlink" title="Spring AOP 的底层实现原理"></a><strong>Spring AOP 的底层实现原理</strong></h3><p>Spring AOP 中的动态代理主要有两种方式， JDK 动态代理和 CGLIB 动态代理 。</p><ul><li>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类。<ol><li>创建代理类proxy实现Invocation接口，重写invoke()方法；</li><li>将被代理类作为构造函数的参数传入代理类proxy；</li><li>调用Proxy.newProxyInsatnce(classloader,interfaces,handler)方法生成代理类。</li></ol></li><li>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。CGLIB（ Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通 过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的 。</li></ul><h3 id="如何给-Spring-容器提供配置元数据"><a href="#如何给-Spring-容器提供配置元数据" class="headerlink" title="如何给 Spring 容器提供配置元数据"></a><strong>如何给 Spring 容器提供配置元数据</strong></h3><ul><li><p>XML 配置文件 </p></li><li><p>基于注解的配置 </p></li><li><p>基于 Java 的配置</p></li></ul><h3 id="哪些是重要的-Bean-生命周期方法，能重载它们吗"><a href="#哪些是重要的-Bean-生命周期方法，能重载它们吗" class="headerlink" title="哪些是重要的 Bean 生命周期方法，能重载它们吗"></a><strong>哪些是重要的 Bean 生命周期方法，能重载它们吗</strong></h3><p>有两个重要的 Bean 生命周期方法，第一个是 setup， 它是在容器加载 Bean 的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p><p>Bean 标签有两个重要的属性（ init-method 和 destroy-method ）， 用它们你可以自己定制初始化和注销方法 。</p><h3 id="Spring-MVC-的控制器是不是单例模式-如果是-有什么问题-怎么解决"><a href="#Spring-MVC-的控制器是不是单例模式-如果是-有什么问题-怎么解决" class="headerlink" title="Spring MVC 的控制器是不是单例模式,如果是,有什么问题,怎么解决"></a><strong>Spring MVC 的控制器是不是单例模式,如果是,有什么问题,怎么解</strong>决</h3><p>是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的，解决方案是在控制器里面不能写字段。</p><h3 id="Spring-中循环注入的方式"><a href="#Spring-中循环注入的方式" class="headerlink" title="Spring 中循环注入的方式"></a><strong>Spring 中循环注入的方式</strong></h3><p>举个列子我有一个类 A，A 有一个构造器里面的参数是类 B，然后类 B 里面有个构造器参数是类 C，类 C 里面有个构造器参数是类 A，就 </p><p>是我们会发现其实引用循环了 A 里面有 B 的引用，B 里面有 C 的引用，C 里面又有 A 的引用。 </p><p>当我们用 Spring 来加载 A 的时候 Spring 的流程是这样的（构造器注入）：</p><ol><li><p>Spring 创建 A 首先去当前创建池中去查找当前 A 是否在创建，如果发明没有创建则准备其构造器需要的参数 B，然后把创建 A 的标识放入当前创建池中。 </p></li><li><p>Spring 创建 B 首先去当前创建池中去查找当前 B 是否在创建，如果发现没有创建则准备其构造器需要的参数 C，然后把创建 B 的标识放入当前创建池中。 </p></li><li><p>Spring 创建 C 首先去当前创建池中去查找当前 C 是否在创建，如果发现没有创建则准备其构造器需要的参数 A，然后把创建 C 的标识放入当前创建池中。 </p></li><li><p>Spring 创建 C 需要的 A，这个时候会发现在当前创建池中已经有 A 的标识，A 正在创建中则抛出BeanCurrentlyInCreationException。</p></li></ol><p>构造器的循环注入是没有办法解决的，所以只能我们避免。</p><p>set 方式的循环注入：</p><ol><li><p>Spring 创建 A，首先根据其无参构造器创建一个对象 A，然后提前暴露出创建出来的这个 A 对象，然后再当前的创建池中放入创建 A 的标识，然后进行 set 方法注入 B。 </p></li><li><p>Spring 创建 B，首先根据其无参构造器创建一个对象 B，然后提前暴露出创建出来的这个 B 对象，然后在当前的创建池中放入创建 B 的标识，然后进行 set 方法的注入 C。 </p></li><li><p>Spring 创建 C，首先根据其无参构造器创建一个对象 C，然后提前暴露出创建处理的这个 C 对象，然后在当前的创建池中放入创建 C 的标识，然后进行 set 方法的注入 A。 </p></li><li><p>在第三步注入 A 的时候由于提前暴露出来了创建出来的 A 对象所以不会报 BeanCurrentlyInCreationException 的错误。</p></li></ol><h3 id="Spring-Boot-相关"><a href="#Spring-Boot-相关" class="headerlink" title="Spring Boot 相关"></a><strong>Spring Boot 相关</strong></h3><h3 id="什么是-Spring-Boot"><a href="#什么是-Spring-Boot" class="headerlink" title="什么是 Spring Boot"></a><strong>什么是 Spring Boot</strong></h3><p>能够简化 Spring 应用的初始搭建以及开发过程，使用特定的方式来进行配置（ properties 或 yml 文件），如：创建独立的 Spring 引用程序 main 方法运行、嵌入的 Tomcat 无需部署 war 文件、 简化 Maven 配置、自动配置 Spring 添加对应功能 starter 自动化配置等。</p><h3 id="Spring-Boot-自动配置的原理"><a href="#Spring-Boot-自动配置的原理" class="headerlink" title="Spring Boot 自动配置的原理"></a><strong>Spring Boot 自动配置的原理</strong></h3><p>Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。</p><h3 id="为什么要用-Spring-Boot"><a href="#为什么要用-Spring-Boot" class="headerlink" title="为什么要用 Spring Boot"></a><strong>为什么要用 Spring Boot</strong></h3><p>独立运行、简化配置、自动配置、代码生成和 XML 配置、应用监控、上手容易等</p><h3 id="理解-Spring-Boot-中的-Starters"><a href="#理解-Spring-Boot-中的-Starters" class="headerlink" title="理解 Spring Boot 中的 Starters"></a><strong>理解 Spring Boot 中的 Starters</strong></h3><p>Starters 理解为启动器，它包含了一系列可以集成到应用里面的依赖包，方便开发者快速集成 Spring 及其他技术，避免投入很多精力寻找依赖包或者代码的工作。Spring 的官方启动器都是以 spring-boot-starter- 命名的，代表了一个特定的应用类型。 </p><h3 id="Spring-Boot-有哪几种读取配置的方式"><a href="#Spring-Boot-有哪几种读取配置的方式" class="headerlink" title="Spring Boot 有哪几种读取配置的方式"></a><strong>Spring Boot 有哪几种读取配置的方式</strong></h3><p>Spring Boot 可以通过 @PropertySource、@Value、@Environment、 @ConfigurationProperties 来绑定变量。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring概念 </tag>
            
            <tag> IOC </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发—JUC之AQS、ReentrantLock、读写锁原理等</title>
      <link href="2021/06/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94AQS%E3%80%81ReentrantLock%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86/"/>
      <url>2021/06/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94AQS%E3%80%81ReentrantLock%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><strong>AQS</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁：</p><ul><li>getState：获取 state 状态。</li><li>setState：设置 state 状态。</li><li>compareAndSetState：cas 机制设置 state 状态。</li><li>独占模式只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源。</li></ul></li><li><p>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList。</p></li><li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet。</p></li></ul><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）：</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁的姿势</span></span><br><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁的姿势</span></span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h3><p>下面实现一个不可重入的阻塞式锁：使用 AbstractQueuedSynchronizer 自定义一个同步器来实现自定义锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnRepeatLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock myLock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            log.info(<span class="string">&quot;lock ... &quot;</span>);</span><br><span class="line">            <span class="comment">// 测试是否不可重入</span></span><br><span class="line">            myLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;starting...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;unlock ... &quot;</span>);</span><br><span class="line">                myLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">                setState(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync mySync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mySync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可中断的锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        mySync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只会尝试一次加锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mySync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">35</span>:<span class="number">34.374</span> [t1] INFO com.heu.test.UnRepeatLock - lock ... </span><br><span class="line">一直等待。。。</span><br></pre></td></tr></table></figure><h3 id="AQS-目标"><a href="#AQS-目标" class="headerlink" title="AQS 目标"></a>AQS 目标</h3><p><strong>AQS 要实现的功能目标</strong></p><ul><li><p>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire</p></li><li><p>获取锁超时机制</p></li><li><p>通过打断取消机制</p></li><li><p>独占机制及共享机制</p></li><li><p>条件不满足时的等待机制</p></li></ul><p><strong>要实现的性能目标</strong></p><ul><li>Instead, the primary performance goal here is scalability: to predictably maintain effiffifficiency even, orespecially, when synchronizers are contended.</li></ul><h3 id="AQS设计"><a href="#AQS设计" class="headerlink" title="AQS设计"></a>AQS<strong>设计</strong></h3><p><strong>获取锁的逻辑：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(state 状态不允许获取) &#123;</span><br><span class="line"> <span class="keyword">if</span>(队列中还没有此线程) &#123;</span><br><span class="line"> 入队并阻塞</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">当前线程出队</span><br></pre></td></tr></table></figure><p><strong>释放锁的逻辑：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(state 状态允许了) &#123;</span><br><span class="line"> 恢复阻塞的线程(s) </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ul><li><p>原子维护 state 状态</p></li><li><p>阻塞及恢复线程</p></li><li><p>维护队列</p></li></ul><p><strong>state</strong> <strong>设计</strong></p><ul><li>state 使用 volatile 配合 cas 保证其修改时的原子性。</li><li>state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想。</li></ul><p><strong>阻塞恢复设计</strong></p><ul><li><p>早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume ，那么 suspend 将感知不到。</p></li><li><p>解决方法是使用 park &amp; unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没问题。</p></li><li><p>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细。</p></li><li><p>park 线程还可以通过 interrupt 打断。</p></li></ul><p>**** <strong>队列设计</strong></p><ul><li><p>使用了 FIFO 先入先出队列，并不支持优先级队列。</p></li><li><p>设计时借鉴了 CLH 队列，它是一种单向无锁队列。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616201035669.png" alt="image-20210616201035669" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616201054697.png" alt="image-20210616201054697" style="zoom:67%;" /><p>队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态。</p><h3 id="主要用到-AQS的并发工具类"><a href="#主要用到-AQS的并发工具类" class="headerlink" title="主要用到 AQS的并发工具类"></a>主要用到 AQS的并发工具类</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616202126371.png" alt="image-20210616202126371"></p><h2 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a>ReentrantLock 原理</h2><p>可以看到 ReentrantLock 提供了两个同步器，实现公平锁和非公平锁，默认是非公平锁！</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616194522522.png" alt="image-20210616194522522" style="zoom: 67%;" /><h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><h4 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h4><p>先从构造器开始看，默认为非公平锁实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NonfairSync 继承自 AQS，在没有线程竞争时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 没有竞争时, 直接加锁 (CAS)</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 设置持有锁的线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 有竞争, 会调用这个方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616195628434.png" alt="image-20210616195628434"></p><p>第一个竞争出现时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 再次尝试加锁失败，则创建一个 Node 节点对象加入到等待队列中去.</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616200052450.png" alt="image-20210616200052450"></p><p>Thread-1 执行了：</p><ol><li>lock方法中CAS，尝试将 state 由 0 改为 1，结果失败；</li><li>lock方法中进一步调用acquire方法，进入 tryAcquire 逻辑，这里认为此时 state 已经是1，结果仍然失败；</li><li>接下来进入 acquire方法的addWaiter 逻辑，构造 Node 队列：<ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态；</li><li>Node 的创建是懒惰的；</li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616202800247.png" alt="image-20210616202800247"></p><p>之后当前线程进入acquire方法的 acquireQueued 逻辑：</p><ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞;</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，这里设置此时 state 仍为 1，失败;</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false；</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616203601530.png" alt="image-20210616203601530" style="zoom:80%;" /><ol start="4"><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败；</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true；</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示已经阻塞）。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616204249004.png" alt="image-20210616204249004" style="zoom:100%;" /><p>如果再次有多个线程经历上述过程竞争失败，变成这个样子：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616204842320.png" alt="image-20210616204842320" style="zoom:150%;" /><p><strong>加锁源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 加锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果尝试失败，进入 ㈠</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ㈡ tryAcquire</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ 进入 ㈢</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果还没有获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取失败, 回到调用处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式，新建的Node的waitstatus默认为0，因为waitstatus是成员变量，默认被初始化为0</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">// 双向链表</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果tail为null，尝试将 Node 加入 AQS, 进入 ㈥</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) &#123;</span><br><span class="line">                    tail = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// 上一个节点 help GC</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 返回中断标记 false</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 判断是否应当 park, 进入 ㈦</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取上一个节点的状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt; 0 表示取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这次还没有阻塞</span></span><br><span class="line">            <span class="comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈧ 阻塞当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解锁流程"><a href="#解锁流程" class="headerlink" title="解锁流程"></a>解锁流程</h4><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功：</p><ul><li>设置 exclusiveOwnerThread 为 null</li><li>state = 0</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616205036686.png" alt="image-20210616205036686"></p><p>如果当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程：</p><p>unparkSuccessor 中会找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1.</p><p>回到 Thread-1 的 acquireQueued 流程：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616205303644.png" alt="image-20210616205303644"></p><p>如果加锁成功（没有竞争），会设置 （acquireQueued 方法中）：</p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1；</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread；</li><li>原本的 head 因为从链表断开，而可被垃圾回收。</li></ul><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210616205711587.png" alt="image-20210616205711587"></p><p>如果不巧又被 Thread-4 占了先：</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1；</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞。</li></ul><p><strong>解锁源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试释放锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// 队列头节点 unpark</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 队列不为 null</span></span><br><span class="line">                h != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                <span class="comment">// waitStatus == Node.SIGNAL 才需要 unpark</span></span><br><span class="line">                h.waitStatus != <span class="number">0</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// unpark AQS 中等待的线程, 进入 ㈡</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0, 如果线程获取到了锁那么后来头结点会被抛弃掉</span></span><br><span class="line">        <span class="comment">// 不成功也可以</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁重入原理"><a href="#锁重入原理" class="headerlink" title="锁重入原理"></a>锁重入原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p><strong>不可打断模式：</strong>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                                parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可打断模式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁原理"><a href="#公平锁原理" class="headerlink" title="公平锁原理"></a>公平锁原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;(</span><br><span class="line">                    <span class="comment">// (s = h.next) == null 表示队列中还有没有老二或者队列中老二线程不是此线程</span></span><br><span class="line">                    (s = h.next) == <span class="keyword">null</span> || </span><br><span class="line">                    s.thread != Thread.currentThread()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject。</p><h4 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a><strong>await流程</strong></h4><p>开始时 Thread-0 持有锁，调用 await方法，进入 ConditionObject 的 addConditionWaiter 流程，创建新的 Node 节点，状态为-2（Node.CONDITION），关联 Thread-0，加入等待队列尾部。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617095324574.png" alt="image-20210617095324574" style="zoom: 50%;" /><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617095417259.png" alt="image-20210617095417259" style="zoom:50%;" /><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程竞争，那么 Thread-1 竞争成功：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617095612679.png" alt="image-20210617095612679" style="zoom:50%;" /><p>park 阻塞 Thread-0：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617095650506.png" alt="image-20210617095650506" style="zoom:50%;" /><h4 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a><strong>signal 流程</strong></h4><p>假设 Thread-1 要来唤醒 Thread-0：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617095807467.png" alt="image-20210617095807467" style="zoom: 40%;" /><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617100008910.png" alt="image-20210617100008910" style="zoom: 40%;" /><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617100149481.png" alt="image-20210617100149481" style="zoom:40%;" /><p>之后Thread-1 释放锁，进入 unlock 流程。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// ㈠ 添加一个 Node 至等待队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = lastWaiter;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 已经是尾节点了</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (</span><br><span class="line">            <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span></span><br><span class="line">                !transferForSignal(first) &amp;&amp;</span><br><span class="line">                        <span class="comment">// 队列还有节点</span></span><br><span class="line">                        (first = firstWaiter) != <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置当前node状态为0（因为处在队列末尾），如果状态已经不是 Node.CONDITION, 说明被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 加入 AQS 队列尾部</span></span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 插入节点的上一个节点被取消</span></span><br><span class="line">                ws &gt; <span class="number">0</span> ||</span><br><span class="line">                        <span class="comment">// 插入节点的上一个节点不能设置状态为 Node.SIGNAL</span></span><br><span class="line">                        !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// unpark 取消阻塞, 让线程重新同步状态</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果没有持有锁，会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可打断等待 - 直到被唤醒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁, 见 ㈣</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 仅设置打断状态</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放，获取state，然后把它全部减掉，以全部释放</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line">            <span class="comment">// 唤醒等待队列队列中的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时重新设置打断状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断打断模式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ㈤ 应用打断模式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞              </span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="comment">// 获得最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 已超时, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工具方法 省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁原理"><a href="#读写锁原理" class="headerlink" title="读写锁原理"></a>读写锁原理</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。读-写，写-写都是相互互斥的！提供一个数据容器类，内部分别使用读锁保护数据的read()方法，写锁保护数据的write()方法 。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read();</span><br><span class="line">            dataContainer.write();</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.write();</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        log.info(<span class="string">&quot;拿到读锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;读取操作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            log.info(<span class="string">&quot;释放读锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        log.info(<span class="string">&quot;拿到写锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;写操作&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">            log.info(<span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：读读并发，读写阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">47.856</span> [t1] INFO com.heu.test.DataContainer - 拿到读锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">47.865</span> [t1] INFO com.heu.test.DataContainer - 读取操作</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">47.856</span> [t2] INFO com.heu.test.DataContainer - 拿到读锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">47.867</span> [t2] INFO com.heu.test.DataContainer - 读取操作</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t1] INFO com.heu.test.DataContainer - 释放读锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t2] INFO com.heu.test.DataContainer - 释放读锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t1] INFO com.heu.test.DataContainer - 拿到写锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t1] INFO com.heu.test.DataContainer - 写操作</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t1] INFO com.heu.test.DataContainer - 释放写锁</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li>读锁不支持条件变量。</li><li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">     w.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">     &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">         w.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">     r.unlock();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//写锁永久等待</span></span><br></pre></td></tr></table></figure><ol start="3"><li>重入时降级支持：即持有写锁的情况下去获取读锁：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="comment">// 是否有效，如果失效，需要重新计算 data</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自己用完数据, 释放读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁原理-1"><a href="#读写锁原理-1" class="headerlink" title="读写锁原理"></a>读写锁原理</h3><p>读写锁用的是同一个 Sync 同步器，因此等待队列、state 等也是同一个。</p><p><strong>下面执行：t1 w.lock，t2 r.lock 情况</strong>：</p><ol><li>t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，读锁使用的是 state 的高 16 位。</li></ol><p>​               <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617141553828.png" alt="image-20210617141553828" style="zoom:80%;" />  </p><ol start="2"><li><p>t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败。tryAcquireShared 返回值表示：</p><ul><li>-1 表示失败。</li><li>0 表示成功，但后继节点不会继续唤醒。</li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒，这里的读写锁返回 1。<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617141820347.png" alt="image-20210617141820347" style="zoom:80%;" /></li></ul></li><li><p>这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态。<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617142341800.png" alt="image-20210617142341800" style="zoom:80%;" /></p></li><li><p>t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁。</p></li><li><p>如果没有成功，在 doAcquireShared 内 for 循环一次，把前驱节点的 waitStatus 改为 -1，再 for 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617142418723.png" alt="image-20210617142418723" style="zoom:80%;" /></li></ol><p><strong>又继续执行</strong> <strong>：t3 r.lock，t4 w.lock。</strong>在这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617144002185.png" alt="image-20210617144002185"></p><p><strong>继续执行 t1 w.unlock，</strong>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617144632809.png" alt="image-20210617144632809"></p><p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行。这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，图中的t2从黑色变成了蓝色（注意这里只是恢复运行而已，并没有获取到锁！） 这回再来一次 for (;; ) 执行 tryAcquireShared 成功，让读锁计数加一。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617144832160.png" alt="image-20210617144832160"></p><p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617144926677.png" alt="image-20210617144926677" style="zoom: 67%;" /><p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是，则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行。<br><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617145201826.png" alt="image-20210617145201826"></p><p>这回再来一次 for (;; ) ，执行 tryAcquireShared 成功则让读锁计数加一。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617145259018.png" alt="image-20210617145259018"></p><p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点。<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617145411846.png" alt="image-20210617145411846" style="zoom: 43%;" /></p><p><strong>再继续执行t2 r.unlock，t3 r.unlock t2，</strong>进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一。<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617145742494.png" alt="image-20210617145742494" style="zoom:40%;" /></p><p>但由于计数还不为零，t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即：<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617150145779.png" alt="image-20210617150145779" style="zoom:40%;" /></p><p>之后 t4线程 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 执行for (;; )循环， 这次自己是老二，并且没有其他线程竞争，tryAcquire(1) 成功，修改头结点，流程结束。<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617150310448.png" alt="image-20210617150310448" style="zoom:40%;" /></p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="写锁源码分析"><a href="#写锁源码分析" class="headerlink" title="写锁源码分析"></a>写锁源码分析</h4><p><strong>写锁上锁流程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 尝试获得写锁失败</span></span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">                        <span class="comment">// 进入 AQS 队列阻塞</span></span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得低 16 位, 代表写锁的 state 计数</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// c != 0 and w == 0 表示有读锁返回错误，读锁不支持锁升级, 或者</span></span><br><span class="line">                    w == <span class="number">0</span> ||</span><br><span class="line">                            <span class="comment">// c != 0 and w == 0 表示有写，如果 exclusiveOwnerThread 不是自己</span></span><br><span class="line">                            current != getExclusiveOwnerThread()</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// 获得锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写锁计数超过低 16 位, 报异常</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 写锁重入, 获得锁成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 判断写锁是否该阻塞这里返回false, 或者</span></span><br><span class="line">                writerShouldBlock() ||</span><br><span class="line">                        <span class="comment">// 尝试更改计数失败</span></span><br><span class="line">                        !compareAndSetState(c, c + acquires)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 获得锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁成功</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写锁释放流程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试释放写锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// unpark AQS 中等待的线程</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">        <span class="comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span></span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free) &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读锁源码分析"><a href="#读锁源码分析" class="headerlink" title="读锁源码分析"></a>读锁源码分析</h4><p><strong>读锁上锁流程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果是其它线程持有写锁, 获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        getExclusiveOwnerThread() != current</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span></span><br><span class="line">                !readerShouldBlock() &amp;&amp;</span><br><span class="line">                        <span class="comment">// 小于读锁计数, 并且</span></span><br><span class="line">                        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                        <span class="comment">// 尝试增加计数成功</span></span><br><span class="line">                        compareAndSetState(c, c + SHARED_UNIT)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span></span><br><span class="line">    <span class="comment">// true 则该阻塞, false 则不阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">        HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再一次尝试获取读锁</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">// 成功</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ㈠</span></span><br><span class="line"><span class="comment">// r 表示可用资源数, 在这里总是 1 允许传播</span></span><br><span class="line">                        <span class="comment">//（唤醒 AQS 中下一个 Share 节点）</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span></span><br><span class="line">                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                                <span class="comment">// park 当前线程</span></span><br><span class="line">                                parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 设置自己为 head</span></span><br><span class="line">        setHead(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">        <span class="comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">                (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) &#123;</span><br><span class="line">                <span class="comment">// 进入 ㈡</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">// 下一个节点 unpark 如果成功获取读锁</span></span><br><span class="line">                    <span class="comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读锁释放流程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                <span class="comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span></span><br><span class="line">                <span class="comment">// 计数为 0 才是真正释放</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span></span><br><span class="line">                <span class="comment">// 防止 unparkSuccessor 被多次执行</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用。</p><p><strong>加解读锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure><p><strong>加解写锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure><p>StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次戳校验，如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line"> <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：提供一个数据容器类内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法。代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StampedLockDataContainer dataContainer = <span class="keyword">new</span> StampedLockDataContainer(<span class="number">1</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(dataContainer.read(<span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.write(<span class="number">10</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StampedLockDataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StampedLockDataContainer</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> readTime)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        log.info(<span class="string">&quot;optimistic read locking ...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        Thread.sleep(readTime * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (stampedLock.validate(stamp)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;read finish... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">        log.info(<span class="string">&quot;update to read lock ...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            log.info(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            Thread.sleep(readTime * <span class="number">1000</span>);</span><br><span class="line">            log.info(<span class="string">&quot;read finish ... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> newData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            <span class="keyword">this</span>.data = newData;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;write finish ... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            log.info(<span class="string">&quot;write newData ... &#123;&#125;&quot;</span>, <span class="keyword">this</span>.data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">13.011</span> [t1] INFO com.heu.test.StampedLockDataContainer - optimistic read locking ..<span class="number">.256</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">13.519</span> [t2] INFO com.heu.test.StampedLockDataContainer - write lock <span class="number">384</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">14.031</span> [t1] INFO com.heu.test.StampedLockDataContainer - update to read lock ...</span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">14.523</span> [t2] INFO com.heu.test.StampedLockDataContainer - write finish ... <span class="number">384</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">14.524</span> [t2] INFO com.heu.test.StampedLockDataContainer - write newData ... <span class="number">10</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">14.525</span> [t1] INFO com.heu.test.StampedLockDataContainer - read lock <span class="number">513</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">15.533</span> [t1] INFO com.heu.test.StampedLockDataContainer - read finish ... <span class="number">513</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>StampedLock 不支持条件变量</li><li>StampedLock 不支持可重入</li></ol></blockquote><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>信号量，用来限制能同时访问共享资源的线程上限。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个对象</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//获取一个许可</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;t&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">36.143</span> [t2] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">36.143</span> [t3] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">36.143</span> [t1] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.154</span> [t1] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.154</span> [t3] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.155</span> [t2] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.156</span> [t4] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.155</span> [t10] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.156</span> [t6] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.162</span> [t4] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.162</span> [t6] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.162</span> [t10] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.162</span> [t9] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.163</span> [t7] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.163</span> [t8] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">39.174</span> [t9] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">39.174</span> [t7] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">39.174</span> [t5] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">39.174</span> [t8] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">40.181</span> [t5] INFO com.heu.test.SemaphoreTest - end...</span><br></pre></td></tr></table></figure><h3 id="Semaphore原理"><a href="#Semaphore原理" class="headerlink" title="Semaphore原理"></a>Semaphore原理</h3><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一。如下示例：刚开始 permits（state）为 3，这时 5 个线程来获取资源：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617164935238.png" alt="image-20210617164935238" style="zoom:45%;" /><p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617165100987.png" alt="image-20210617165100987"></p><p>这时 Thread-4 释放了 permits，状态如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617165142832.png" alt="image-20210617165142832"></p><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210617165256132.png" alt="image-20210617165256132"></p><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="comment">// permits 即 state</span></span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Semaphore 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获得共享锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                   <span class="comment">// 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly</span></span><br><span class="line">                    remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                            <span class="comment">// 如果 cas 重试成功, 返回正数, 表示获取成功</span></span><br><span class="line">                            compareAndSetState(available, remaining)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再次尝试获取许可</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head</span></span><br><span class="line">                        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">                        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">  <span class="comment">// r 表示可用资源数, 为 0 则不会继续传播</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Semaphore 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p>CountDownLatch 允许多线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保很好的理解了它。</p><ul><li>CountDownLatch 是共享锁的一种实现，它默认构造 AQS 的 state 值为 count。当线程使用 countDown方法时，其实使用了 tryReleaseShared 方法以CAS 的操作来减少 state，当 state 为 0， 就代表所有的线程都调用了countDown方法。</li><li>当调用 await 方法的时候，如果 state 不为0，就代表仍然有线程没有调用 countDown0 方法，那么就把已经调用过 countDown 的线程都放入阻塞队列 Park ，并自旋 CAS 判断 state == 0，直至最后一个线程调用了 countDown ，使得 state == 0，于是阻塞的线程便判断成功，全部往下执行。</li></ul><p>用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         method3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;t1 start ...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;t1 end ...&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;t2 start ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;t2 end ...&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;t3 start ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;t3 end ...&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;main wait ...&quot;</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        log.info(<span class="string">&quot;main wait end ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;t1 start ...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            log.info(<span class="string">&quot;t1 end ...&#123;&#125;&quot;</span>, countDownLatch.getCount());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;t2 start ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;t2 end ...&#123;&#125;&quot;</span>, countDownLatch.getCount());</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;t3 start ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;t3 end ...&#123;&#125;&quot;</span>, countDownLatch.getCount());</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;main wait...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;main wait end ...&quot;</span>);</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        String[] all = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(random.nextInt(<span class="number">100</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    all[id] = j + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">                    System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏开始&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>method1 输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">12.575</span> [main] INFO com.heu.test.CountDownLatchTest - main wait ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">12.575</span> [t2] INFO com.heu.test.CountDownLatchTest - t2 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">12.575</span> [t1] INFO com.heu.test.CountDownLatchTest - t1 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">12.575</span> [t3] INFO com.heu.test.CountDownLatchTest - t3 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">13.592</span> [t1] INFO com.heu.test.CountDownLatchTest - t1 end ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">14.098</span> [t3] INFO com.heu.test.CountDownLatchTest - t3 end ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">14.590</span> [t2] INFO com.heu.test.CountDownLatchTest - t2 end ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">14.590</span> [main] INFO com.heu.test.CountDownLatchTest - main wait end ...</span><br></pre></td></tr></table></figure><p>method2 输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">07.829</span> [pool-<span class="number">1</span>-thread-<span class="number">4</span>] INFO com.heu.test.CountDownLatchTest - main wait...</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">07.829</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com.heu.test.CountDownLatchTest - t2 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">07.829</span> [pool-<span class="number">1</span>-thread-<span class="number">3</span>] INFO com.heu.test.CountDownLatchTest - t3 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">07.829</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.heu.test.CountDownLatchTest - t1 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">08.854</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.heu.test.CountDownLatchTest - t1 end ..<span class="number">.2</span></span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">09.344</span> [pool-<span class="number">1</span>-thread-<span class="number">3</span>] INFO com.heu.test.CountDownLatchTest - t3 end ..<span class="number">.2</span></span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">09.851</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com.heu.test.CountDownLatchTest - t2 end ..<span class="number">.1</span></span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">09.851</span> [pool-<span class="number">1</span>-thread-<span class="number">4</span>] INFO com.heu.test.CountDownLatchTest - main wait end ...</span><br></pre></td></tr></table></figure><p>method3 输出：当所有线程全部加载完毕，输出游戏开始，类似王者荣耀！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%]</span><br><span class="line">游戏开始</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarri[ˈsaɪklɪk ˈbæriɚ]：循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。跟 CountdownLatch 一样，但这个可以重用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">       CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line">           log.info(<span class="string">&quot;task2 finish ...&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">           executorService.submit(() -&gt; &#123;</span><br><span class="line">               log.info(<span class="string">&quot;task1 begin ...&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                   cyclicBarrier.await();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           executorService.submit(() -&gt; &#123;</span><br><span class="line">               log.info(<span class="string">&quot;task2 begin ...&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                   cyclicBarrier.await();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       executorService.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReentrantLock原理 </tag>
            
            <tag> AQS原理 </tag>
            
            <tag> 读写锁原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/06/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/06/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h2><p>设计模式是一个通过定义、使用、测试去解决特定问题的方法，是针对软件设计中在给定条件下会重复性发生的问题而提出的一种通用性的可重用解决方案，设计模式不是可以直接转化为代码的完整设计，它是用于描述在不同情况下解决问题的通用方案。</p><p>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><h2 id="设计模式的作用"><a href="#设计模式的作用" class="headerlink" title="设计模式的作用"></a>设计模式的作用</h2><p>设计模式通过提供经过验证的行之有效的开发范式加快开发过程，预防重大的隐患问题，提高代码可读性。</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p><strong>这里主要讨论GoF所提出的23种设计模式，可将其分为三种类型：</strong></p><ol><li><p>创造型设计模式</p></li><li><p>结构型设计模式</p></li><li><p>行为型设计模式</p><h3 id="创造型设计模式"><a href="#创造型设计模式" class="headerlink" title="创造型设计模式"></a>创造型设计模式</h3><p>注重完成对象的实例化，相比于直接实例化对象，根据实际情况选择合适的设计模式完成对象的实例化，可以为复杂的业务场景带来更高的灵活性。创造型设计模式主要包括以下几种：</p></li><li><p>抽象工厂设计模式</p></li><li><p>生成器设计模式</p></li><li><p>工厂方法设计模式</p></li><li><p>原型设计模式</p></li><li><p>单例设计模式</p><h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><p>结构型设计模式用于指导我们完成对代码的结构划分，如此，代码结构会更加清晰，更易理解，也提高了软件的可维护性。结构型设计模式主要包括以下几种：</p></li><li><p>适配器设计模式</p></li><li><p>桥接设计模式</p></li><li><p>组合设计模式</p></li><li><p>装饰设计模式</p></li><li><p>门面设计模式</p></li><li><p>享元设计模式</p></li><li><p>代理设计模式</p><h3 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h3><p>行为型设计模式主要用于定义对象之间的通信与流程控制，主要的设计模式都非常注重优化对象之间的数据交互方式。行为型设计模式主要包括以下几种：</p></li><li><p>职责链设计模式</p></li><li><p>命令设计模式</p></li><li><p>解释器设计模式</p></li><li><p>迭代器设计模式</p></li><li><p>中介者设计模式</p></li><li><p>备忘录设计模式</p></li><li><p>观察者设计模式</p></li><li><p>策略设计模式</p></li><li><p>状态设计模式</p></li><li><p>模板方法设计模式</p></li><li><p>访问者设计模式</p><h2 id="如何学习设计模式"><a href="#如何学习设计模式" class="headerlink" title="如何学习设计模式"></a>如何学习设计模式</h2></li></ol><ul><li>模式名称是什么？</li><li>模式类型是什么？是创造型，结构型，还是行为型？</li><li>模式的目的是什么？（作用是什么？解决了什么问题？）</li><li>模式的别名是什么？</li><li>什么情况下使用该模式？</li><li>该模式的基本示例</li><li>该模式的UML图是什么样的？是类图还是交互图？</li><li>都有哪些对象在模式中参与活动？列出设计模式中使用的类和对象，并说明他们各自的角色</li><li>模式中的类和对象是怎么进行交互的？</li><li>通过应用设计模式能获取什么好处，有哪些坏处？如何权衡？</li><li>如何实现该模式</li><li>与该模式相近的设计模式是什么？这几种相近的模式有哪些异同点？<h2 id="正确看待设计模式"><a href="#正确看待设计模式" class="headerlink" title="正确看待设计模式"></a>正确看待设计模式</h2>恰当使用设计模式能够提高代码的复用性，但是由于复用性往往会引入封装与间接调用，这些会降低系统性能，增加代码复杂程度。因此，除非设计模式能够帮助我们完成代码的实现或者后续的维护工作，否则没有必要去引入设计模式。</li></ul><p>学习设计模式的关键并不在于学习设计模式本身，而是在于识别应用场景与潜在的风险，并将设计模式用之有道，这般，设计模式才能算作得心应手的工具。</p><p>在没有必要的情况大可不必去使用设计模式，因为设计模式有可能会牺牲代码的简洁性，而且滥用设计模式多会引入新的问题却没有解决原来的问题。</p><p><strong>保持代码的整洁，模块化和可读性，同时不要让各类之间过度耦合。</strong></p><h2 id="创造型设计模式-1"><a href="#创造型设计模式-1" class="headerlink" title="创造型设计模式"></a>创造型设计模式</h2><p>创造型设计模式主要关注的是类的实例化，也就是说体现的是对象的创建方法，利用这些模式，我们可以在适当的情况下以适当的形式创建对象，创造型设计模式通过控制对象的创建来解决设计中的问题。</p><p>创造型设计模式主要包含以下子类别：</p><ol><li><p>对象创造型设计模式：主要完成对象创建，并将对象中部分内容放到其他对象中创建。</p></li><li><p>类创造型设计模式：主要完成类的实例化，并将类中的部分对象放到子类中创建，此类模式在实例化过程中高效地利用了继承机制<br>创造型设计模式主要包含以下5种具体的设计模式：</p><ul><li>抽象工厂设计模式：提供一个用于创建相关对象或相互依赖对象的接口，无需指定对象的具体类。</li><li>生成器设计模式：将复杂对象的构建与其表示相互分离，使得同样的构建过程可以创建不同的表示。</li><li>工厂方法设计模式：允许在子类中实现本类的实例化类。</li><li>原型设计模式：使用一个原型实例来指定创建对象的种类，然后通过拷贝这些原型实现新对象的创建。</li><li>单例模式：确保某个类在系统中仅有一个实例，并提供一个访问它的全局访问点。</li></ul></li></ol><table><thead><tr><th align="center">对象创造型设计模式</th><th align="center">类创造型设计模式</th></tr></thead><tbody><tr><td align="center">抽象工厂设计模式</td><td align="center">工厂方法设计模式</td></tr><tr><td align="center">生成器设计模式</td><td align="center"></td></tr><tr><td align="center">原型设计模式</td><td align="center"></td></tr><tr><td align="center">单例设计模式</td><td align="center"></td></tr></tbody></table><h3 id="工厂方法设计模式"><a href="#工厂方法设计模式" class="headerlink" title="工厂方法设计模式"></a>工厂方法设计模式</h3><p>工厂方法的作用是创建对象，用来从一组实现特定逻辑的类中实例化某个对象。</p><h4 id="模式中包括的类"><a href="#模式中包括的类" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li><p>产品类（Product）中定义了工厂方法创建的对象接口。</p></li><li><p>具体产品类（ Concrete Product）实现产品类接口。</p></li><li><p>工厂类（ Creator，因为由它来创建产品类，所以叫作工厂类）声明工厂方法，返回一个产品类对象。可用于调用创建产品类对象的生成方法。</p></li><li><p>具体工厂类（ Concrete Creator）重写用于创建具体产品类对象的方法。</p><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630141241582.png" alt="image-20210630141241582"></p><h4 id="功能及应用场景"><a href="#功能及应用场景" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li><li><p>当需要创建一个类，而在编程时不能确定这个类的类型时（需要运行时确定）。</p></li><li><p>当一个类希望由其子类来指定所创建对象的具体类型时。</p></li><li><p>当我们想要定位被创建类，并获取相关信息时。</p></li></ul><h3 id="抽象工厂设计模式"><a href="#抽象工厂设计模式" class="headerlink" title="抽象工厂设计模式"></a>抽象工厂设计模式</h3><p>抽象工厂模式相比于工厂方法模式的抽象层次更高。这意味着抽象工厂返回的是一组类的工厂。与工厂方法模式类似（返回多个子类中的一个），此方法会返回一个工厂，而这个工厂会返回多个子类中的一个。简单来说，抽象工厂是一个工厂对象，该对象又会返回若干工厂中的一个。</p><p>工厂模式是创造型模式的典型示例。抽象工厂设计模式是工厂方法模式的扩展，从而使我们无须担心所创建对象的实际类就能够创建对象。抽象工厂模式扩展了工厂方法模式，允许创建更多类型的对象。</p><h4 id="模式中包括的类-1"><a href="#模式中包括的类-1" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>抽象工厂（AbstractFactory）声明一个用于完成抽象产品对象创建操作的接口。</li><li>具体工厂（ConcreteFactory）实现创建具体产品对象的操作。</li><li>抽象产品（AbstractProduct）声明一个用于一类产品对象的接口。</li><li>具体产品（ConcreteProduct）定义由相应的具体工厂来创建的产品对象。</li><li>客户端（Client）使用由抽象工厂和抽象产品类声明的唯一接口。</li></ul><h4 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630141413150.png" alt="image-20210630141413150"></p><h4 id="功能及应用场景-1"><a href="#功能及应用场景-1" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>抽象工厂模式的主要优点之一是它屏蔽了这些具体类的创建方法。实际应用的类名称不需要再让客户端（将客户端与具体类解耦）知道。由于具体类是屏蔽的，因此我们可以在不同的工厂（实现方法）之间进行切换。</p><h3 id="生成器设计模式"><a href="#生成器设计模式" class="headerlink" title="生成器设计模式"></a>生成器设计模式</h3><p>生成器模式，能够从简单的对象一步一步生成复杂的对象。生成器模式是一种用来逐步构建复杂对象并在最后一步返回对象的创造型模式。</p><p>构造一个对象的过程是通过泛型实现的，以便它能够用于对同一对象创建不同的表示形式。</p><h4 id="模式中包括的类-2"><a href="#模式中包括的类-2" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>生成器类（ Builder）提供一个接口用于创建产品的各个组成部件。具体生成器（Concrete Builder）提供此接口的实现。</li><li>具体生成器（ ConcreteBuilder）会跟踪其所创建对象的表现形式，并在创建对象的同时提供一个接口获取产品（Product）。</li><li>导演类（ Director）通过生成器提供的接口构造对象。产品类用于表示被构造的复杂对象。这包括对我们构建的所有类进行定义。<h4 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630142835827.png" alt="image-20210630142835827"><h4 id="功能及应用场景-2"><a href="#功能及应用场景-2" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4>生成器模式隐藏了产品构建过程中的内部细节。各个生成器之间都是相互独立的。这提高了代码的模块化，并使其他的生成器更方便地创建对象。因为每个生成器都能够逐步创建对象，这让我们能够很好地对最终产品进行掌控。</li></ul><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>在应用程序的整个生命周期中，对象只有一个实例的时候，就会使用单例设计模式。单例类总是在第一次被访问时完成实例化，直至应用程序退出之前，都只会使用同一个实例。单一实例创建策略：我们通过限制构造函数（通过设置其为私有）从而限制单例类的实例化。之后在定义类时包含一个该类的静态私有对象，以便创建单例类的实例。在单例模式中，最棘手的部分是对单一实例的实现和管理。在单例模式的定义过程中，有两点需要注意的地方：</p><ul><li>该类仅允许存在一个实例。</li><li>需要为该单一实例提供一个全局访问点。</li></ul><p>单例模式中的主动实例化和被动实例化（饿汉、懒汉），线程安全的单例：双重同步锁、静态变量、枚举。</p><h4 id="模式中包括的类-3"><a href="#模式中包括的类-3" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>单例类<h4 id="UML图-3"><a href="#UML图-3" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630201404401.png" alt="image-20210630201404401" style="zoom: 67%;" /></li></ul><h4 id="功能及应用场景-3"><a href="#功能及应用场景-3" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>在应用程序的整个生命周期中，对象只有一个实例的时候，就会使用单例设计模式。</p><h3 id="原型设计模式"><a href="#原型设计模式" class="headerlink" title="原型设计模式"></a>原型设计模式</h3><p>相比于以往创建一个复杂对象总是费时费力，原型模式只需要复制现有的相似对象，并根据需要做适当修改。原型意味着使用克隆方法。克隆方法是一种复制对象的操作。克隆出的对象副本被初始化为调用克隆方法时原始对象的当前状态。这意味着对象的克隆避免了创建新对象。如果创建一个新对象的开销很大，而且有可能引起资源紧张时，我们就克隆对象。</p><ul><li>浅层复制：当原始对象变化时，新对象也跟着改变。这主要是因为浅层复制并没有实际复制新的对象，而只是对原有对象的一个引用。</li><li>深层复制：当原始对象变化时，新对象不受影响，因为原始对象所包含的所有参数、对象和引用在复制新对象的过程中都建立了新的拷贝。</li></ul><p>使用克隆方法来复制对象时，具体是使用浅层复制还是深层复制是由业务需求来决定的。在使用原型模式时，使用克隆方法来复制对象仅仅是一个设计上的决策。克隆方法对于原型模式来说并不是强制性的最佳选择。</p><h4 id="模式中包括的类-4"><a href="#模式中包括的类-4" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>客户端（Client）：通过调用原型类的克隆操作创建一个新对象。</li><li>原型类（ Prototype）：声明一个接口用于克隆自己。</li><li>具体原型类（ Concrete Prototype）：实现克隆自己的操作。</li></ul><h4 id="UML图-4"><a href="#UML图-4" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630143348935.png" alt="image-20210630143348935" style="zoom:80%;" /><h4 id="功能及应用场景-4"><a href="#功能及应用场景-4" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ol><li>当一个系统应该独立于其产品的创建、组合和表示。</li><li>当需要实例化的类是在运行时定义的，例如动态加载，或避免建立一个平行于产品类继承层次的工厂类继承层次时。</li><li>当一个类的实例仅可以拥有若干不同的状态组合中的一个时。使用原型模式建立相应数量的原型和克隆方法，会比每次都手动实例化类并配置相应状态更加方便。</li></ol><p><strong>主要难点：</strong></p><ul><li>每个原型类的子类都必须实现克隆操作。这实现起来可能有难度。例如，当类已经存在的时候添加克隆方法可能比较困难。</li><li>对象内部包含其他不支持克隆的对象或具有循环引用的对象时，实现克隆方法会比较困难。</li></ul><p><strong>优点：</strong></p><ul><li>原型模式意味着使用克隆方法。克隆方法是一种复制对象的操作。相比于耗时的复制对象创建过程，原型模式仅复制类似的现有对象，再根据需要对复制出的副本进行修改。</li><li>客户端可以在运行时添加或移除原型对象。</li><li>通过各种参数来定义新对象：高度动态的系统允许我们通过使用对象组合来定义新的特征，例如为对象变量指定相应的参数值，而不是重新定义一个类。我们通过实例化现有类可以有效地定义新类型的对象，并为客户端对象注册原型实例。客户端可以通过向原型类委派某个责任而使其具有新的特征。这种设计允许用户无须大量编程就能轻松定义新的类。事实上，克隆一个原型本质上是类似于类的实例化的。但原型模式能够大大降低系统所需的类的数量。</li></ul><p><strong>副作用：</strong></p><ul><li>使用原型模式，我们可以根据需要通过对象克隆来实现运行时对象的添加和删除。我们可以根据程序运行情况在运行时修改类的内部数据表示形式。</li><li>在Java中实现原型模式的一大困难是如果这些类已经存在，我们未必能够通过添加所需要的克隆方法或深层克隆方法对类进行修改。此外，那些与其他类具有循环引用关系的类并不能真正实现克隆。</li><li>需要在这些类中具有足够的数据访问权限或方法，以便在克隆完成后对相应的数据进行修改。这可能需要在这些原型类中添加相应的数据访问方法，以便我们对类完成克隆之后可以修改数据。</li></ul><h2 id="结构型设计模式-1"><a href="#结构型设计模式-1" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p>结构型模式主要描述如何将对象和类组合在一起以组成更复杂的结构。在软件工程中结构型模式是用于帮助设计人员通过简单的方式来识别和实现对象之间关系的设计模式。结构型模式会以组的形式组织程序。这种划分形式使代码更加清晰，维护更加简便。结构型模式用于代码和对象的结构组织。结构型模式会以组的形式组织程序。这种划分形式使代码更加清晰，维护更加简便。</p><p><strong>结构型模式又分为以下子类别：</strong></p><ol><li>对象结构型模式：用于对象之间相互关联与组织，以便形成更大、更复杂的结构。</li><li>类结构型模式：用于实现基于继承的代码抽象，并且会介绍如何通过该模式提供更有用的程序接口。</li></ol><p><strong>具体包括：</strong></p><table><thead><tr><th align="center">对象结构型模式</th><th align="center">类结构型模式</th></tr></thead><tbody><tr><td align="center">桥接模式</td><td align="center">类适配器模式</td></tr><tr><td align="center">组合模式</td><td align="center"></td></tr><tr><td align="center">装饰模式</td><td align="center"></td></tr><tr><td align="center">门面模式</td><td align="center"></td></tr><tr><td align="center">享元模式</td><td align="center"></td></tr><tr><td align="center">对象适配器模式</td><td align="center"></td></tr><tr><td align="center">代理模式</td><td align="center"></td></tr></tbody></table><ol><li>组合模式：它能够为客户端处理各种复杂和灵活的树状结构。这些树结构可以由各种不同类型的容器和叶节点组成，其深度或组合形式能够在运行时调整或确定。</li><li>装饰模式：允许我们通过附加新的功能或修改现有功能，在运行时动态地修改对象。</li><li>门面模式：允许我们为客户端创建一个统一的接口以访问不同子系统的不同接口，从而简化客户端。</li><li>享元模式：客户端调用类时会在运行时创建大量对象，该模式会重新设计类以优化内存开销。</li><li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。这种模式的目的是一个对象不适合或者不能直接引用另一个对象，简化客户端并实现对象访问，同时避免任何副作用。</li><li>适配器模式：允许我们为一个已有的类提供一个新的接口，并在客户端请求不同接口时实现类的重用。</li><li>桥接模式：允许我们将类与其接口相互解耦。允许类及其接口随着时间相互独立变化，增加类重用的次数，提高后续可扩展性。它也允许运行时对接口的不同实现方式动态切换，使代码更加灵活。</li></ol><h3 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h3><p>软件适配器的工作原理也和插座适配器完全一样。我们也经常需要在程序中使用到不同的类或模块。假设有一段代码写得很烂，如果我们直接将这些代码集成到程序中，会将现有的代码搞乱。但是我们又不得不调用这段代码，因为我们需要实现相关的功能，而从头写起会耽误很多宝贵的时间。这时的最佳实践就是编写适配器，并将所需要的代码包装进去。这样我们就能够使用自定义的接口，从而降低对外部代码的依赖。</p><p>适配器模式会将现有接口转换为新的接口，已实现对应用程序中不相关的类的兼容性和可重用性的目标。适配器模式也被称为包装模式。适配器模式能够帮助那些因为接口不兼容而无法一起工作的类，以便它们能够一同工作。</p><p>适配器模式也负责将数据转换成适当的形式。当客户端在接口中指定了其对数据格式的要求时，我们通常可以创建新的类以实现现有类的接口和子类。这种实现方式也会通过创建类适配器，实现对客户端调用命和现有类中被调用方法之间接口的转换。</p><h4 id="模式中包括的类-5"><a href="#模式中包括的类-5" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>客户端（Client）调用目标类的类或程序。</li><li>目标类（Target）客户端想要使用的接口。</li><li>适配对象类（Adapetee）需要进行适配的类或对象。</li><li>适配器类（ Adapter）按照目标类接口的要求对适配对象接口实现接口形式的适配转换。</li><li>request方法：客户端想要执行的操作。</li><li>specificRequest方法：适配对象中能够完成 request方法功能的实现。<h4 id="UML图-5"><a href="#UML图-5" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630163942385.png" alt="image-20210630163942385"></li></ul><h4 id="功能及应用场景-5"><a href="#功能及应用场景-5" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>在具体实践上，有两种实际应用适配器模式的方法：</p><ol><li>使用继承［类适配器］</li><li>使用关联［对象适配器］</li></ol><p><strong>应用场景：</strong></p><ul><li>我们想要使用现有的类，但它的接口不符合我们的需要。</li><li>我们想要创建一个可重用的类，能够与一些无关的类或不可预见的类进行协作，同时这个类无须具有兼容的接口。</li><li>（仅适用于对象适配器）我们需要使用多个已经存在的子类，而我们为每一个子类都做接口适配显然是不切实际的。使用对象适配器可以直接适配其父类的接口。</li></ul><h3 id="桥接设计模式"><a href="#桥接设计模式" class="headerlink" title="桥接设计模式"></a>桥接设计模式</h3><p>桥接模式是结构型模式中的另一个典型模式。桥接模式用于将类的接口与接口的实现相互解耦。这样做提高了系统的灵活性使得接口和实现两者均可独立变化。</p><p>举一个例子，让我们想一下家用电器及其开关。例如，风扇的开关。开关是电器的控制接口，而一旦闭合开关，实际让风扇运转的是风扇电机。</p><p>所以，在这个示例中，开关和风扇之间是彼此独立的。如果我们将开关接到电灯泡的供电线路上，那么我们还可以选用其他开关来控制风扇。</p><h4 id="模式中包括的类-6"><a href="#模式中包括的类-6" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>抽象化对象（Abstraction）桥接设计模式的核心，并定义了关键症结所在，包含对实现化对象的引用。</li><li>扩充抽象化对象（RefinedAbstraction）扩展抽象化对象，并将抽象化对象细化到新的层次。对实现化对象隐藏细节元素。</li><li>实现化对象（Implementor）该接口比抽象化对象的层次更高。只对基本操作进行定义。</li><li>具体实现化对象（Concretelmplementor）通过提供具体实现来执行实现化对象的具体功能。<h4 id="UML图-6"><a href="#UML图-6" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630164156773.png" alt="image-20210630164156773"><h4 id="功能及应用场景-6"><a href="#功能及应用场景-6" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4>桥接模式主要适用于系统的多个维度上都经常发生变化的情况。桥接模式能够将不同的抽象维度进行衔接。通过桥接模式，抽象化对象和实现化对象不会在编译时进行绑定，而能够在各自的类被调用时独立扩展。当你经常需要在运行时在多个实现之间进行切换时，桥接模式也非常有用。</li></ul><h3 id="组合设计模式"><a href="#组合设计模式" class="headerlink" title="组合设计模式"></a>组合设计模式</h3><p>在大部分系统开发过程中，程序员都会遇到某个组件既可以是独立的个体对象，也能够作为对象集合的情况。组合模式就用于此类情况的设计。简单来说，组合模式是一组对象的集合，而这组对象中的每一个对象本身也是一个组合模式构成的对象，或者只是一个原始对象。</p><p>组合模式中存在着一个树形结构，并且在该结构中的分支节点和叶节点上都能够执行相同的操作。树形结构中每一个分支节点都包含子节点的类（能继承出叶节点和分支节点），这样的分支节点本身就是一个组合模式构成的节点。树形结构中的叶子节点仅是一个原始对象，其没有子节点（不能继承出叶节点和分支节点）。组合模式的子类（下一级节点）可以是叶子节点或其他组合模式。</p><h4 id="模式中包括的类-7"><a href="#模式中包括的类-7" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li><p>组件对象：（Component，结构）</p><ul><li>组件对象在整个继承结构的最顶端。它是对组合模式的抽象。</li><li>它声明了组合模式中的对象接口。</li><li>可以选择性地定义一个接口，以便对递归结构中组件的父类进行访问，并在需要的时候实现该接口。</li></ul></li><li><p>叶子节点：（Leaf，原始对象）</p><ul><li>树形结构的末端且不会再有子节点。</li><li>定义了组合结构中单个对象的行为。</li></ul></li><li><p>分支节点类：（Composite，组）</p><ul><li>包含了子组件并为它们定义行为。</li><li>实现子节点的相关操作。<h4 id="UML图-7"><a href="#UML图-7" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630164419373.png" alt="image-20210630164419373"><h4 id="功能及应用场景-7"><a href="#功能及应用场景-7" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li></ul></li><li><p>当对象的集合需要采用与单个对象相同的处理方式时。</p></li><li><p>操纵单个对象的方式与操纵一组对象的方式类似时。</p></li><li><p>注意存在能够组合的递归结构或树形结构。</p></li><li><p>客户端能够通过组件对象访问整个继承结构，而它们却不会知道自己所处理的是叶子节点还是分支节点。</p></li></ul><p>组合模式的目的是能够使独立对象（单个分支节点或叶子节点）和对象集合（子树）都能够以同样的方式组织起来。组合模式中所有的对象都来自于其本身（成为一种嵌套结构）。组合模式允许我们使用递归的方式将类似的对象组合成一种树形结构，来实现复杂结构对象的构建。</p><h3 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h3><p>装饰设计模式用来在运行时扩展或修改一个实例的功能。一般来说，继承可以扩展类的功能（用于类的所有实例）。但与继承不同的是，通过装饰模式，我们可以选择一个类的某个对象，并对其进行修改，而不会影响这个类中其他的实例。继承会直接为类增加功能，而装饰模式则会通过将对象与其他对象进行包装的方式将功能添加到类。</p><h4 id="模式中包括的类-8"><a href="#模式中包括的类-8" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>抽象组件（Component）给出一个抽象接口，用于能够动态添加功能的对象。</li><li>具体组件（Concrete Component）定义一个实现组件接口的对象。这是实际需要加以装饰的对象，但其对装饰的过程一无所知。<h4 id="UML图-8"><a href="#UML图-8" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630164820760.png" alt="image-20210630164820760" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-8"><a href="#功能及应用场景-8" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>装饰设计模式用来在运行时扩展或修改一个实例的功能。一般来说，继承可以扩展类的功能（用于类的所有实例）。但与继承不同的是，通过装饰模式，我们可以选择一个类的某个对象，并对其进行修改，而不会影响这个类中其他的实例。</p><h3 id="门面设计模式"><a href="#门面设计模式" class="headerlink" title="门面设计模式"></a>门面设计模式</h3><p>许多业务流程都会涉及复杂的业务类操作。由于流程很复杂，所以其涉及了多个业务对象，这往往会导致各个类之间的紧密耦合，从而降低系统的灵活性和设计的清晰度。底层业务组件间的复杂关系会使客户端的代码编写变得很困难。</p><p>门面模式简化了到复杂系统的外部接口，为此它会对所有的类进行整合，并构建一个复杂系统的子系统。</p><p>门面模式能够将用户与系统内部复杂的细节相互屏蔽，并只为用户提供简化后的更容易使用的外部接口。同时它也将系统内部代码与接口子系统的代码相互解耦，以便修改和升级系统代码。</p><p>相比于其他设计模式，门面模式更注重实现代码的解耦。它所强调的是代码设计中很重要的一点，即代码抽象。通过提供一个简单的接口并隐藏其后的复杂性，从而实现抽象。</p><p>在这种方式下，代码的实现完全交由门面层处理。客户端只会与一个接口交互，同时也只有和这个接口交互的权限。这样就能隐藏全部系统的复杂性。总而言之，门面模式通过提供一个简单的接口为客户端简化了与复杂系统的交互。从另一方面看，门面模式也保证了能够在不修改客户端代码的情况下对具体实现方法进行修改。</p><h4 id="模式中包括的类-9"><a href="#模式中包括的类-9" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>门面层（ Facade）：它知道子系统内各个类的具体功能，并将客户端请求转换成对系统内部对象的调用。</li><li>系统内部类（ ComplicatedClass）：这些类会实现系统功能，处理门面层对象分配的各项工作任务。它们本身并不知道门面层的存在，也没有对其进行任何的引用。</li></ul><h4 id="UML图-9"><a href="#UML图-9" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630165235034.png" alt="image-20210630165235034" style="zoom:50%;" /><h4 id="功能及应用场景-9"><a href="#功能及应用场景-9" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul><li>想要为一个复杂的子系统提供一个简单接口。子系统随着其自身的发展往往变得越来越复杂。它们应用的大多数的设计模式会导致类的数量更多、代码段更小。这使得该子系统可重用更好，也更容易进行自定义。而对于某些无法自定义的客户端来说，它也变得难以使用，门面层可以提供对大多数客户端来说足够好的简化的调用接口，只有极少数高度定制化的客户端需要直接调用门面层之后的底层代码。</li><li>在客户端和抽象层的实现类之间存在大量的依赖关系。引入一个门面层能够将客户端的子系统与其他子系统进行解耦，从而促进子系统的独立性和可移植性。</li><li>你想要为你的子系统增加层级。使用一个门面层对每个子系统级别分别定义一个入口点。如果子系统之间存在依赖关系，那么你可以通过令这些子系统之间的交互全部需要经由门面层来简化彼此的依赖关系。</li></ul><h3 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h3><p>根据目的不同，有各种不同类型的代理。例如，有保护性代理，控制对某个对象的访问权限；有虚拟代理，处理开销过大而难以创建的对象，并通过远程访问控制来访问远程对象。</p><h4 id="模式中包括的类-10"><a href="#模式中包括的类-10" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><h4 id="UML图-10"><a href="#UML图-10" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630165416954.png" alt="image-20210630165416954" style="zoom:50%;" /><h4 id="功能及应用场景-10"><a href="#功能及应用场景-10" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>代理模式主要用于当我们需要用一个简单对象来表示一个复杂对象的情形。如果创建对象的开销很大，那么可以推迟其创建，并使用一个简单对象来代理其功能直到必须立即创建的时候。这个简单对象就可以称为复杂对象的代理。</p><h3 id="享元设计模式"><a href="#享元设计模式" class="headerlink" title="享元设计模式"></a>享元设计模式</h3><p>享元模式能够减少用于创建和操作大量相似的细碎对象所花费的成本。享元模式主要用在需要创建大量类似性质的对象时。大量的对象会消耗高内存，享元模式给出了一个解决方案，即通过共享对象来减少内存负载它的具体实现则是根据对象属性将对象分成两种类型：内蕴状态和外蕴状态。<strong>共享</strong>是享元模式的关键。</p><h4 id="模式中包括的类-11"><a href="#模式中包括的类-11" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>抽象享元角色（ Flyweight）声明一个为具体享元角色规定了必须实现的接口，而外蕴状态就是以参数的形式通过此方法传入。</li><li>具体享元角色（ Concrete Flyweight）实现享元模式接口，并存储内蕴状态。具体享元角色必须是共享的。具体享元角色必须保持其内蕴状态不变，并且能够操纵外蕴状态。</li><li>享元工厂角色（FlyweightFactory）负责创建和管理享元角色。此外，该工厂确保了享元角色的共享。工厂维护了不同的享元对象池，并负责在对象创建完成时从对象池返回对象，以及向对象池添加对象。</li><li>客户端（Client）维护对所有享元对象的引用，而且需要存储和计算对应的外蕴状态。<h4 id="UML图-11"><a href="#UML图-11" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630165644153.png" alt="image-20210630165644153" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-11"><a href="#功能及应用场景-11" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>当我们选择享元模式的时候，需要考虑以下因素：</p><ul><li>需要创建大量的对象时。</li><li>由于对象众多，内存的开销是一个制约因素。</li><li>大多数对象属性可以分为内蕴状态和外蕴状态。</li><li>应用程序需要使用多种对象，且创建对象后需要多次重复使用。</li><li>外蕴状态最好是通过计算得到的，而不需要进行存储。</li></ul><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式是一类主要关注对象间相互通信（交互）的设计模式。这些对象之间的相互作用既能保证对象间能够交换数据，同时对象间仍然能够保持松耦合。</p><p>紧耦合一般会发生在一组紧密关联（相互依赖）的类之间。在面向对象的设计过程中，耦合引用的数量和设计过程中类与类之间的相互依赖是成正比的。用通俗的话讲，就是当一个类变化的时候，有多少可能需要同时修改其他类呢？而松耦合是软件架构设计的关键。在行为型模式中，功能实现与调用该实现的客户端之间应该是松耦合的，以避免硬编码和依赖性。</p><p>行为型模式处理不同的对象之间的通信关系，为其提供基本的通信方式，并提供实现这种通信方式的最常用、最灵活的解决方案。行为型模式描述的不仅是类或对象的模式，同时也包括了它们之间的通信模式。行为型模式能够用来避免硬编码和依赖性。</p><p><strong>行为型模式又分为以下子类别：</strong></p><ol><li>对象行为型模式：对象行为型模式使用对象组合而非继承。描述一组对象如何合作执行部分任务，而单个对象无法执行这些任务。</li><li>类行为型模式：类行为型模式使用继承而不是对象组合来描述算法和流程控制。</li></ol><p><strong>具体包括：</strong></p><ul><li>职责链模式（COR）：在一系列对象链之间传递请求的方法。</li><li>命令模式：命令模式主要用于在需要向对象发出请求的情况，发出请求的对象无须了解请求的操作内容，也无须了解请求的实际接收对象。</li><li>解释器模式：解释器提供了在代码中使用特定语言的一种方法。解释器模式就是一种用于在程序中解析特定语言的设计模式。</li><li>迭代器模式：迭代器用于顺序访问集合（组合）对象中的元素，而无须了解其内部结构。</li><li>中介者模式：定义简单的类间通信。</li><li>备忘录模式：捕获和恢复对象的内部状态。</li><li>观察者模式：一种通知多个类进行改变的方式。</li><li>状态模式：当一个对象状态改变时改变其功能。</li><li>策略模式：在类中进行算法封装。</li><li>模板方法模式：将算法中的部分步骤延迟到子类中进行计算。</li><li>访问者模式：在不改变类的条件下为该类定义一个新的操作。</li></ul><table><thead><tr><th align="center"><strong>对象行为型模式</strong></th><th align="center"><strong>类行为型模式</strong></th></tr></thead><tbody><tr><td align="center">职责链模式</td><td align="center"></td></tr><tr><td align="center">解释器模式</td><td align="center"></td></tr><tr><td align="center">命令模式</td><td align="center">模板方法模式</td></tr><tr><td align="center">迭代器模式</td><td align="center"></td></tr><tr><td align="center">中介者模式</td><td align="center"></td></tr><tr><td align="center">备忘录模式</td><td align="center"></td></tr><tr><td align="center">观察者模式</td><td align="center"></td></tr><tr><td align="center">状态模式</td><td align="center"></td></tr><tr><td align="center">策略模式</td><td align="center"></td></tr><tr><td align="center">访问者模式</td><td align="center"></td></tr></tbody></table><h3 id="职责链设计模式"><a href="#职责链设计模式" class="headerlink" title="职责链设计模式"></a>职责链设计模式</h3><p>在职责链模式中，由发送端发送一个请求到一个对象链中，链中的对象自行处理请求。如果链中的对象决定不响应请求，它会将请求转发给链中的下一个对象。</p><p>职责链的目的是通过特定设计对请求的发送者和接收者之间进行解耦。解耦是软件设计中很重要的一个方面。通过该设计模式能够使我们彻底地将发送者和接收者之间完全解耦。发送者是用于调用操作的对象，接收者是接收请求并执行相关操作的对象。通过解耦，发送者不需要关心接收者的接口。</p><p>在职责链模式中，职责是前后传递的。对于链中的对象，决定谁来响应请求的责任由整个链中左侧的对象来承担。这就像问答测验的时候传递问题一样。当提问者向一个人提问，如果他不知道答案，他就把问题传给下一个人，以此类推。当一个人回答了问题，问题就会停止向下传递。有时，也可能到达最后一个人时，还是没有人能回答问题。</p><p>我们能举出若干个职责链模式的例子：硬币分拣机、ATM取款机、Servlet过滤器和Java的异常处理机制。在Java中，我们可以在catch语句中列出的异常序列时就抛出一个异常，catch列表从上到下逐条扫描。如果赶上第一个进行异常处理就可以立刻完成任务，否则责任转移到下一行，直到最后一行。</p><h4 id="模式中包括的类-12"><a href="#模式中包括的类-12" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>抽象处理者（Handler）：定义用于处理请求的接口。</li><li>具体处理者（ Concrete Handler）：它负责处理请求。如果它能够处理这样的要求就会自行处理，否则会将请求发送到下一个处理者。</li><li>客户端（Client）：将命令发送到职责链中第一个能够处理该请求的对象。<h4 id="UML图-12"><a href="#UML图-12" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630194840468.png" alt="image-20210630194840468" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-12"><a href="#功能及应用场景-12" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul><li>发送者并不知道在链中的哪个对象会响应请求。</li><li>职责链中的每一个对象都有责任决定是否对请求进行响应，如果这些对象有能力响应请求就会响应请求。</li><li>如果对象（或节点）决定向后传递请求它需要具有选择下一个节点和继续传递的能力。</li><li>也有可能没有任何一个节点能够响应请求（有些请求可能无法得到处理）</li><li>会在运行时确定哪些对象能够响应请求。</li></ul><h3 id="命令设计模式"><a href="#命令设计模式" class="headerlink" title="命令设计模式"></a>命令设计模式</h3><p>命令模式（也称为行动模式、业务模式）是一个对象行为型模式。</p><p>这使我们能够实现发送者和接收者之间完全解耦。通过解耦，发送者无须了解接收者的接口。在这里，请求的含义是需要被执行的命令。</p><h4 id="模式中包括的类-13"><a href="#模式中包括的类-13" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>抽象命令类（Command）：在类中对需要执行的命令接口进行声明。</li><li>具体命令类（ ConcreteCommand）：将接收者对象和行为之间进行绑定。它通过调用接收者中相应的操作实现 execute方法。</li><li>客户端（ Client）：客户端完成对命令对象的实例化并提供随后需要调用的方法的信息。</li><li>调用者（Invoker）：调用者决定合适的调用方法。</li><li>接收者（Receiver）：接收者是包含方法代码的类的一个实例。这意味着它知道如何处理一个请求并执行相应的操作。任何一个类都可以作为接收者。<h4 id="UML图-13"><a href="#UML图-13" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630195039276.png" alt="image-20210630195039276" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-13"><a href="#功能及应用场景-13" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul><li>通过参数化对象实现功能执行。命令是面向对象式的，而不是回调函数式的。</li><li>指定消息队列并在不同的时间执行请求一个命令对象可以有独立于原始请求的生命周期。如果一个请求的接收者可以由一个独立地址空间的方式来表示，那么你可以将请求对应的命令对象转换到不同的进程并在其中完成请求。</li><li>支持撤销。命令的执行操作可以作为状态进行存储，并在需要时实现命令撤销。命令接口必须增加一个unexecute操作，支持撤销之前命令调用的执行效果。执行的命令存储在命令的历史列表中。无限次数的撤销和重做是通过遍历这个列表并分别调用 unexecute和 execute来实现的。</li><li>支持日志记录变化，在系统崩溃的情况下使命令可以重新应用。通过增加load和 store操作命令接口参数，你可以保存一个持续变化的日志。从系统崩溃中恢复需要从磁盘重新加载日志命令和使用 Execute作重新执行这些命令。</li><li>通过在原生操作基础上的高层操作构建系统。这样的结构在支持交易操作的信息系统中很常见。一个交易事务封装一组变化的数据。命令模式提供了一种交易模型。命令都有一个共同的接口，允许你使用相同的方式调用所有的交易。这种模式也使得它很容易与新的交易系统进行交互扩展。</li></ul><p><strong>注意事项：</strong></p><ul><li><p>目的：将请求封装为一个对象，从而使客户端可以将不同的请求、队列、日志请求及其他支持撤销的操作进行参数化。</p></li><li><p>发出请求的对象无须知道请求对应的操作或请求接收者的任何信息。</p></li><li><p>后果：</p><ul><li>将调用操作的对象和执行操作的对象之间对命令进行解耦。即调用者和接收者之间解耦。</li><li>命令转换为一类对象。使其可以像其他对象那样进行操作和扩展。</li><li>我们可以将命令组合成一个组合命令。一般来说，组合命令是一个组合模式的实例。</li><li>很容易添加新的命令，因为我们无须改变现有的类。</li></ul></li></ul><h3 id="解释器设计模式"><a href="#解释器设计模式" class="headerlink" title="解释器设计模式"></a>解释器设计模式</h3><p>解释器模式是一种用于在程序中解析特定语法的设计模式。解释器模式是组合模式的一种应用。对于特定的某种语言，解释器模式能够定义针对其语法表示形式的解释器，并实现对该语言语句的翻译和解释。</p><h4 id="模式中包括的类-14"><a href="#模式中包括的类-14" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>内容类（Context）：包含解释器的全局信息。</li><li>表达式（AbstractExpression）：带有名叫 interpret抽象方法的抽象类。它会声明执行操作的接口。</li><li>终结符表达式（TerminalExpression）：就是带有终结符的表达式。</li><li>非终结符表达式（ NonterminalExpression）：在两个终结符表达式或非终结符表达式之间实现逻辑运算（与或运算）的表达式。</li><li>客户端（Client）：建立抽象树，并调用抽象树中的 interpret方法。<h4 id="UML图-14"><a href="#UML图-14" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630195428888.png" alt="image-20210630195428888" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-14"><a href="#功能及应用场景-14" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>解释器模式的适用范围非常有限。我们可以说解释器模式仅仅用于需要进行正式语法解释的地方，但这些领域往往已经有了更好的标准的解决方法，因此，在实际使用中，并不会经常使用该模式。该模式可以用于解释使用了特定语法的表达式或者建立某个简单的规则引擎的时候。</p><h3 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a>迭代器设计模式</h3><p>迭代器模式也是一种行为型模式。迭代器模式允许对一组对象元素的遍历（也叫收集）以完成功能实现。</p><h4 id="模式中包括的类-15"><a href="#模式中包括的类-15" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>迭代器（Iterator）：它会实现一个用于定义迭代器的抽象迭代器接口。</li><li>具体迭代器（Concretel）：这是迭代器的实现（实现迭代器接口）。</li><li>抽象容器（Container）：这是用于定义聚合关系的接口。</li><li>具体容器（ConcreteContainer）：一个聚合关系的实现。<h4 id="UML图-15"><a href="#UML图-15" class="headerlink" title="UML图"></a>UML图</h4></li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630195535105.png" alt="image-20210630195428888" style="zoom:50%;" /><h4 id="功能及应用场景-15"><a href="#功能及应用场景-15" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul><li>需要访问一个聚合（也称为容器）对象的内容，而无须了解其内部表示。</li><li>支持对聚合对象的多种遍历方式。</li><li>为遍历不同的聚合结构提供统一的接口（即支持多态迭代）。</li><li>迭代器模式允许我们访问集合对象中的内容，而无须暴露其内部数据结构。</li><li>支持多个迭代器同时遍历集合对象。这意味着我们可以对相同的集合创建多个独立的迭代器。</li><li>为遍历不同的集合提供统一的接口。</li></ul><h3 id="中介者设计模式"><a href="#中介者设计模式" class="headerlink" title="中介者设计模式"></a>中介者设计模式</h3><p>中介者模式主要是关于数据交互的设计模式。中介者设计模式很容易理解，却难以实现。该模式的核心是一个中介者对象，负责协调一系列对象之间一系列不同的数据请求。这一系列对象称为同事类。同事类会让中介者知道它们会发生变化，这样中介者负责处理变化对不同对象之间交互的影响。</p><h4 id="模式中包括的类-16"><a href="#模式中包括的类-16" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>中介者接口（Mediator）：它定义了一个接口来实现同事类对象之间的沟通。</li><li>具体中介者（ ConcreteMediator）：它知道各个同事类，并和这些同事类保持相互引用。它实现了与同事类之间的通信和消息传递。</li><li>同事类（ Colleague）：这些类保存了对中介者的引用。无论它们想和任何其他同事类进行交互，都必须通过与中介类通信来实现。<h4 id="UML图-16"><a href="#UML图-16" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630195910287.png" alt="image-20210630195910287" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-16"><a href="#功能及应用场景-16" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul><li>一组对象使用了标准的通信方式，但整体通信的连接都非常复杂，由此产生的相互依赖的结果导致系统难以结构化，也很难理解。</li><li>由于对象之间的通信和相互引用，导致对象难以重用。</li><li>分布在多个类中的行为能够被统一定制化，而无须创建过多的子类。</li></ul><p><strong>需要注意的问题：</strong><br>实际使用中介者模式的时候，反而会让问题变得越来越复杂。所以最佳的实践是仅让中介者类负责对象之间的通信部分。</p><ul><li>定义一个对象来负责一系列对象之间的交互。</li><li>同事类发送和接收请求都需要通过中介者。</li></ul><p><strong>功能：</strong></p><ul><li>它对同事类进行解耦。中介类实现了同事类之间的松耦合。你可以相互独立地对不同的同事类进行修改和重用。</li><li>它简化了对象协议。中介者取代了许多交互作用，而实现了与多个同事类之间一对多的通信方式。一对多关系更容易理解、维护和扩展。</li><li>它集中了控制。中介者模式在中介者中集成了系统交互的复杂性。因此通过中介封装协议之后，它会比任何单一的同事类都更为复杂。这会使中介者作为一个整体也很难维护。</li><li>门面模式不同于中介者模式的是，它抽象了对象的子系统以提供一个更方便的接口。该种抽象是单向的。也就是说，门面对象会向子系统中的各个类发出请求，反之则不会。相比之下，中介者模式更像是同事类对象之间通过中介者的合作行为，系统的交互都是多向的。</li><li>当各个同事类只和一个中介者对象交互时，没有必要再去定义一个抽象的中介者类。抽象中介者只用于多个同事类通过多个抽象中介者的子类进行交互的情况，反之则不同。</li></ul><h3 id="备忘录设计模式"><a href="#备忘录设计模式" class="headerlink" title="备忘录设计模式"></a>备忘录设计模式</h3><p>我们每天至少会使用一次这种模式。备忘录模式提供了一种使对象恢复到其以前状态的能力（通过回滚撤销）。备忘录模式是通过两个对象实现的：发起者和管理者。发起者是具有内部状态的某个对象。管理者则会对发起者执行一些操作，并实现撤销更改。</p><h4 id="模式中包括的类-17"><a href="#模式中包括的类-17" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>发起者（Originator）：发起者知道如何保存自己。这是我们想要保存状态的类。</li><li>管理者（ Caretaker）：管理者是用于管理发起者进行状态保存的对象，具体处理发起者何时、如何、为何对状态进行存储。管理员应能够对发起者进行修改，同时也能够撤销这些修改。</li><li>备忘录（Memento）：备忘录会保存发起人的状态信息，而这些状态不能由管理者修改。<h4 id="UML图-17"><a href="#UML图-17" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630200134183.png" alt="image-20210630200134183" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-17"><a href="#功能及应用场景-17" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>当我们在实际应用中需要提供撤销机制，当一个对象有可能需要在后续操作中恢复其内部状态时，就需要使用备忘录模式。结合本设计模式实现对象状态序列化，能够使其易于保存对象的状态并进行状态回滚。</p><p>当一个对象状态的快照必须被存储，且在后续操作过程中需要被恢复时，就可以使用备忘录模式。</p><h3 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a>观察者设计模式</h3><p>在观察者模式中，一种叫作被观察者的对象维护了观察者对象的集合。当被观察者对象变化时，它会通知观察者。在被观察者对象所维护的观察者集合中能够添加或删除观察者。被观察者的状态变化能够传递给观察者。这样观察者能够根据被观察者的状态变化做出相应的改变。</p><h4 id="模式中包括的类-18"><a href="#模式中包括的类-18" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>被观察者（Listener）：定义了向客户端添加和移除观察者操作的接口或抽象类。</li><li>具体被观察者（ ConcreteListener）：具体被观察者类。它维护了对象的状态，并在当其状态改变时通知各个观察者。</li><li>观察者（Observer）：定义了用于通知对象的接口或抽象类。</li><li>具体观察者（ ConcreteObserver）：具体实现了观察者。<h4 id="UML图-18"><a href="#UML图-18" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630200319987.png" alt="image-20210630200319987" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-18"><a href="#功能及应用场景-18" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul><li>当一个对象的改变需要其他对象同时改变，而我们并不知道需要有多少个对象一起改变时。</li><li>当一个对象必须通知其他对象，而无须了解这些对象是谁时。</li><li>当一个抽象包含有两个方面，其中一个依赖于另一个。将这些方面封装成独立的对象，以便我们独立改变和重复使用它们时。</li></ul><h3 id="状态设计模式"><a href="#状态设计模式" class="headerlink" title="状态设计模式"></a>状态设计模式</h3><p>状态模式是一种行为型模式。状态模式背后的理念是根据其状态变化来改变对象的行为。状态模式允许对象根据内部状态（内容类）实现不同的行为。内容类可以具有大量的内部状态，每当对内容类调用 request方法时，消息就被委托给状态类进行处理。</p><p>状态类接口定义了一个对所有具体状态类都有效的通用接口，并在其中封装了与特定状态相关的所有操作。具体状态类对请求提供各自具体的实现。当内容类的状态变化时，那么与之关联的具体状态类也会发生一定相应的改变。</p><h4 id="模式中包括的类-19"><a href="#模式中包括的类-19" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>内容类（ Context）：内容类主要用于状态模式的客户端。客户端并不直接访问对象的状态。内容类拥有一个具体的状态对象并根据其当前状态提供所需实现的行为。</li><li>抽象状态类（ State）：这个抽象类是所有具体状态类的基类。状态类定义了一个通用接口。内容类对象能够通过使用该接口实现对不同功能的改变。在状态类及其子类的各个条目或属性中，本身并没有任何的状态。</li><li>具体状态类（ ConcreteState）：具体状态类根据内容类所提供的状态实现真正的功能改变。每个状态类所提供的行为都适用于内容类对象的某一个状态。它们也包含着由内容类状态变化所下发的指令。<h4 id="UML图-19"><a href="#UML图-19" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630200511439.png" alt="image-20210630200511439" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-19"><a href="#功能及应用场景-19" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul><li>状态模式为对象提供了一个清晰的状态表示。</li><li>它允许一个对象在运行时部分清晰明了地改变其类型。</li></ul><h3 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h3><p>策略模式主要用于需要使用不同的算法来处理不同的数据（对象）时。这意味着策略模式定义了一系列算法，并且使其可以替换使用。策略模式是一种可以在运行时选择算法的设计模式。</p><p>本模式可以使算法独立于调用算法的客户端。策略模式也称为政策模式，在使用多种不同的算法（每种算法都可以对应一个单独的类，而每个类的功能又各不相同）时可以运用策略模式。</p><h4 id="模式中包括的类-20"><a href="#模式中包括的类-20" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>抽象策略类（Strategy）：定义一个所有算法都支持的通用接口。内容类会使用这个接口来调用由具体策略类定义的各个算法。</li><li>具体策略类（ ContreteStrategy）：每个具体策略类都会实现一个相应的算法。</li><li>内容类（ Context）：包含一个对策略对象的引用，它可以定义一个用于策略类访问内容类数据的接口。内容类对象包含了对将要使用的具体策略对象的引用。当需要进行特定操作时，会从对应的策略类对象中运行相应的算法。内容类本身觉察不到策略类的执行。如果有必要的话，还可以定义专用的对象来传递从内容类对象到策略类的数据。内容类对象接收来自客户端的请求，并将其委托给策略类对象。通常具体策略类是由客户端创建，并传递给内容类。从这一点来讲，客户端仅与内容类进行交互。<h4 id="UML图-20"><a href="#UML图-20" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630200732554.png" alt="image-20210630200732554" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-20"><a href="#功能及应用场景-20" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>当我们有多种不同的算法可供选择（每种算法都可以对应一个单独的类，而每个类的功能又各不相同）时，可以应用策略模式。策略模式会定义一组算法并能够使其相互替代使用。</p><h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>模板方法会定义算法的各个执行步骤。算法的一个或多个步骤可以由子类通过重写来实现，同时保证算法的完整性并能够实现多种不同的功能。</p><p>类行为型模式使用继承来实现模式的功能。在模板方法模式中，会有一个方法（ Template method方法）来定义算法的各个步骤，这些步骤（即方法）的具体实现会放到子类中，也就是说，在模板方法中定义了特定算法，但该算法的具体步骤仍然需要通过子类来定义。模板方法会由一个抽象类来实现在这个抽象类中还会声明该算法的各个步骤（方法），最后将其具体实现的方法声明实现为抽象类的子类。</p><h4 id="模式中包括的类-21"><a href="#模式中包括的类-21" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>抽象类（ AbstractClass）：定义了算法的抽象操作，并交由具体的子类完成这些操作的具体实现。它实现了一个模板方法，它该方法包含了算法的各个步骤。该模板方法还会在抽象类中定义各个相应步骤的基本操作。</li><li>具体类（ ConcreteClass）：他们通过执行基本操作来实现算法类的具体步骤。当调用一个具体类时，模板方法代码会从基类执行，而模板方法所使用的各个方法由派生类实现和调用。<h4 id="UML图-21"><a href="#UML图-21" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630200958473.png" alt="image-20210630200958473" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-21"><a href="#功能及应用场景-21" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul><li>当一个算法的功能需要能够改变，并通过在子类中对功能重写来实现这种改变。</li><li>当我们要避免代码重复时，能够在子类中实现算法不同的变化。</li><li>在一开始，模板方法可能不是一个显而易见的选择。最明显的现象会是当我们发现几乎完全一样的类在执行某些类似的逻辑。这时，我们就应该考虑使用模板方法模式来清理现有代码。</li></ul><h3 id="访问者设计模式"><a href="#访问者设计模式" class="headerlink" title="访问者设计模式"></a>访问者设计模式</h3><p>访问者模式用来简化对象相关操作的分组。这些操作是由访问者来执行的，而不是把这些代码放在被访问的类中。由于访问的操作是由访问者执行的，而不是由被访问的类，这样执行操作的代码会集中在访问者中，而不是分散在对象分组中。这为代码提供了更好的可维护性。访问者模式也避免了使用 instanceof运算符对相似的类执行计算。</p><h4 id="模式中包括的类-22"><a href="#模式中包括的类-22" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul><li>访问者（ Visitor）：包括一个接口或抽象类，用于声明在所有类型的可访问对象中访问哪些操作。通常操作的名称是相同的，而是由该方法的参数来区分不同的操作。由输入对象类型来决定访问该方法中的哪一个。</li><li>具体访问者（ Concrete Visitor）：用于实现各个类型的访问者和各个类型的访问方法。它在抽象访问者中进行声明，并各自独立实现。每一个具体访问者会负责实现不同的功能。当定义一个新的访问者时，只需要将其传递给对象结构即可。</li><li>元素类（Element）：一个抽象对象用于声明所接受的操作。它是一个入口点，能够允许哪一类访问者对象访问。在集合中的每个对象都需要实现该抽象对象，以便相应访问者能够实现对其进行访问。</li><li>具体元素类（ Concrete Element）：这些类实现了抽象元素类的接口或类，并定义了所接受的操作。通过其可接受的操作，能够将访问者对象传递给该对象。</li><li>结构对象（ ObjectStruture）：这是一个包含了所有可访问对象的类。它提供了一种机制来遍历所有元素。这种结构不一定是一个集合，也可以是一个极其复杂的结构，如组合对象。<h4 id="UML图-22"><a href="#UML图-22" class="headerlink" title="UML图"></a>UML图</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630201115297.png" alt="image-20210630201115297" style="zoom:50%;" /></li></ul><h4 id="功能及应用场景-22"><a href="#功能及应用场景-22" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>在 visitCollection()方法中，我们调用 Visitable.accept(this)来实现对正确的访问者方法进行调用。这叫作双重分派。访问者调用元素类中的方法，又会回到对访问者类中进行调用。</p><p><strong>访问者模式更适用于对象结构非常稳定，而对象的操作却需要经常变化的情况下。</strong>访问者模式只提供处理每种数据类型的方法，并且让数据对象确定调用哪个方法。由于数据对象本质上都知道其自身的类型，所以在访问者模式中算法决定所调用的方法所起到的作用是微不足道的。</p><p>因此，数据的整体处理包括对数据对象的分发以及通过对适当的访问者处理方法的二次分发。这就叫作双重分派。使用访问者模式的一个主要优点是，对于在我们的数据结构中添加需要执行的新的操作来说，是非常容易的。我们所要做的就是创建一个新的访问者，并定义相应的操作。</p><p>但访问者模式的主要问题是，因为每个访问者需要有相应的方法来处理每一种可能的具体数据，那么一旦实现了访问者模式，其具体类的数量和类型就不能被轻易改变。</p><h2 id="Java中的设计模式应用"><a href="#Java中的设计模式应用" class="headerlink" title="Java中的设计模式应用"></a>Java中的设计模式应用</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><strong>工厂模式</strong></h3><p>java.text.DateFormat 工具类，它用于格式化一个本地日期或者时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style,Locale locale)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><strong>适配器模式</strong></h3><p>把其他类适配为集合类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><strong>代理模式</strong></h3><p>如 JDK （Proxy）本身的动态代理。</p><p>还有Spring AOP、日志打印、异常处理、事务控制、权限控制等。</p><p><strong>代理的分类</strong></p><ul><li>静态代理(静态定义代理类)</li><li>动态代理(动态生成代理类，也称为Jdk自带动态代理)</li><li>Cglib 、javaassist（字节码操作库）</li></ul><p><strong>三种代理的区别</strong></p><ol><li>静态代理：简单代理模式，是动态代理的理论基础。常见使用在代理模式。</li><li>jdk动态代理：使用反射完成代理。需要有顶层接口才能使用，常见是mybatis的mapper文件是代理。</li><li>cglib动态代理：也是使用反射完成代理，可以直接代理类（jdk动态代理不行），使用字节码技术，不能对 final类进行继承。（需要导入jar包）</li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><p>全局只允许有一个实例，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime();</span><br></pre></td></tr></table></figure><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a><strong>装饰器</strong></h3><p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.BufferedInputStream(InputStream);  </span><br><span class="line">java.io.DataInputStream(InputStream);  </span><br><span class="line">java.io.BufferedOutputStream(OutputStream);  </span><br><span class="line">java.util.zip.ZipOutputStream(OutputStream);  </span><br><span class="line">java.util.Collections.checkedList(List list, Class type) ;</span><br></pre></td></tr></table></figure><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a><strong>模板方法模式</strong></h3><p>定义一个操作中算法的骨架，将一些步骤的执行延迟到其子类中。比如，Arrays.sort() 方法，它要求对象实现 Comparable 接口。</p><h3 id="IO-使用了什么设计模式？"><a href="#IO-使用了什么设计模式？" class="headerlink" title="IO 使用了什么设计模式？"></a><strong>IO 使用了什么设计模式？</strong></h3><ul><li>适配器模式：由于 InputStream 是字节流不能享受到字符流读取字符那么便捷的功能，借助 InputStreamReader 将其转为 Reader 子类，因而可以拥有便捷操作文本文件方法；</li><li>装饰器模式：将 InputStream 字节流包装为其他流的过程就是装饰器模式，比如，包装为 FileInputStream、ByteArrayInputStream、PipedInputStream 等。</li></ul><h3 id="Spring-中都使用了哪些设计模式？"><a href="#Spring-中都使用了哪些设计模式？" class="headerlink" title="Spring 中都使用了哪些设计模式？"></a><strong>Spring 中都使用了哪些设计模式？</strong></h3><ul><li>代理模式：在 AOP 中有使用。</li><li>单例模式：bean 默认是单例模式。</li><li>模板方法模式：jdbcTemplate。</li><li>工厂模式：BeanFactory。</li><li>观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件。</li><li>适配器模式：Spring MVC 中也是用到了适配器模式适配 Controller。</li></ul><p><strong>Spring IOC</strong></p><ul><li>看过Spring源码就知道，在Spring IOC容器创建bean的过程是使用了工厂设计模式</li><li>Spring中无论是通过xml配置，还是通过配置类还是注解进行创建bean，大部分都是通过简单工厂来进行创建的。</li><li>当容器拿到了beanName和class类型后，动态的通过反射创建具体的某个对象，最后将创建的对象放到Map中。</li></ul><p><strong>为什么Spring IOC要使用工厂设计模式创建Bean呢</strong></p><ul><li>在实际开发中，如果我们A对象调用B，B调用C，C调用D的话我们程序的耦合性就会变高。（耦合大致分为类与类之间的依赖，方法与方法之间的依赖。）</li><li>在很久以前的三层架构编程时，都是控制层调用业务层，业务层调用数据访问层时，都是是直接new对象，耦合性大大提升，代码重复量很高，对象满天飞</li><li>为了避免这种情况，Spring使用工厂模式编程，写一个工厂，由工厂创建Bean，以后我们如果要对象就直接管工厂要就可以，剩下的事情不归我们管了。Spring IOC容器的工厂中有个静态的Map集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到Map集合中，保证了实例不会重复影响程序效率。</li></ul><h3 id="哪些地方用到了单例模式"><a href="#哪些地方用到了单例模式" class="headerlink" title="哪些地方用到了单例模式"></a><strong>哪些地方用到了单例模式</strong></h3><ol><li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li><li>应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。</li><li>多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制</li><li>Windows的（任务管理器）就是很典型的单例模式，他不能打开俩个</li><li>windows的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。</li></ol><h3 id="单例优缺点"><a href="#单例优缺点" class="headerlink" title="单例优缺点"></a>单例优缺点</h3><p><strong>优点：</strong></p><ol><li>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例</li><li>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li><li>提供了对唯一实例的受控访问。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。</li><li>避免对共享资源的多重占用。</li></ol><p><strong>缺点：</strong></p><ol><li>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</li><li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li></ol><h3 id="单例模式使用注意事项"><a href="#单例模式使用注意事项" class="headerlink" title="单例模式使用注意事项"></a><strong>单例模式使用注意事项</strong></h3><ol><li>使用时不能用反射模式创建单例，否则会实例化一个新的对象。</li><li>使用懒单例模式时注意线程安全问题。</li><li>饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式）。</li></ol><h3 id="如何选择单例创建方式"><a href="#如何选择单例创建方式" class="headerlink" title="如何选择单例创建方式"></a><strong>如何选择单例创建方式</strong></h3><ul><li>如果不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举性好于饿汉式。 如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒韩式。 最好使用饿汉式。</li></ul><h3 id="单例创建方式"><a href="#单例创建方式" class="headerlink" title="单例创建方式"></a>单例创建方式</h3><p><strong>（主要使用饿汉和懒汉式）</strong></p><ol><li>饿汉式：类初始化时，会立即加载该对象，线程天生安全，调用效率高。</li><li>懒汉式：类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象，具备懒加载功能。</li><li>静态内部方式：结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</li><li>枚举单例：使用枚举实现单例模式优点：实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障！避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</li><li>双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)。</li></ol><h3 id="懒汉式的单例模式如何实现单例？"><a href="#懒汉式的单例模式如何实现单例？" class="headerlink" title="懒汉式的单例模式如何实现单例？"></a>懒汉式的单例模式如何实现单例？</h3><p>通过双重检测以及 synchronized,volatile 关键字实现。</p><h3 id="工厂模式好处"><a href="#工厂模式好处" class="headerlink" title="工厂模式好处"></a>工厂模式好处</h3><ul><li>工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。</li><li>利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。</li><li>将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发—线程池</title>
      <link href="2021/06/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2021/06/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h3><p>池化技术现在已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p>线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>使用线程池的好处：</p><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210614101113540.png" alt="image-20210614101113540"></p><p>上图就是一个线程池的实现，先初始化线程池、阻塞队列大小，然后开几个线程通过线程池对象调用方法执行任务，如果任务过多，会添加到阻塞队列中，线程执行完任务再从阻塞队列中取值继续执行。当执行的线程数大于线程池和阻塞队列的大小，我们可以定义拒绝策略，类似 jdk 线程池那样。代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">1</span>,<span class="number">1000</span>,TimeUnit.SECONDS,<span class="number">4</span>,(queue,task)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line">           queue.put(task);</span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line">           <span class="comment">//queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">           <span class="comment">//log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">            <span class="comment">//throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">            <span class="comment">//task.run();</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拒绝策略</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit, <span class="keyword">int</span> queueCapcity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize) &#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 1) 死等</span></span><br><span class="line">                <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                <span class="comment">//taskQueue.put(task);</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line">            <span class="comment">//while(task != null || (task = taskQueue.take()) != null)</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//1.任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWait = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWait = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时的阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 timeout 统一转换为 纳秒</span></span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 返回值是剩余时间</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nanos=emptyWait.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWait.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWait.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWait.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullWait.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWait.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时的阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task, <span class="keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nanos = fullWait.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWait.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy,T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capcity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="keyword">this</span>, task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWait.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量，ThreadPoolExecutor 类中的线程状态变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Integer.SIZE 值为 32 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"> <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><table><thead><tr><th>状态名称</th><th>高3位的值</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>接收新任务，同时处理任务队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>不接受新任务，但是处理任务队列中的任务</td></tr><tr><td>STOP</td><td>001</td><td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>010</td><td>任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td>TERMINATED</td><td>011</td><td>终结状态</td></tr></tbody></table><p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示。</strong>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子整数，前 3 位保存了线程池的状态，剩余位保存的是线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不是所有平台的 int 都是 32 位。</span></span><br><span class="line"><span class="comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span></span><br><span class="line"><span class="comment">// 高3位为0，剩余位数全为1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span></span><br><span class="line"><span class="comment">// CAPACITY 的高3位为 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>获取线程池状态、线程数量以及合并两个值的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ Packing and unpacking ctl</span><br><span class="line"><span class="comment">// 获取运行状态</span></span><br><span class="line"><span class="comment">// 该操作会让除高3位以外的数全部变为0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行线程数</span></span><br><span class="line"><span class="comment">// 该操作会让高3位为0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算ctl新值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p><strong>线程池的属性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作线程，内部封装了Thread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>看一下 ThreadPoolExecutor 类参数最多、最全的有参构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>构造参数解释：</p><ul><li><p>corePoolSize：核心线程数</p></li><li><p>maximumPoolSize：最大线程数</p><ul><li>maximumPoolSize - corePoolSize = 救急线程数</li></ul></li><li><p>keepAliveTime：救急线程空闲时的最大生存时间</p></li><li><p>unit：时间单位</p></li><li><p>workQueue：阻塞队列（存放任务）</p><ul><li>有界阻塞队列：ArrayBlockingQueue</li><li>无界阻塞队列：LinkedBlockingQueue</li><li>最多只有一个同步元素的队列：SynchronousQueue</li></ul></li><li><p>PriorityBlockingQueue：优先队列</p></li><li><p>threadFactory：线程工厂（给线程取名字）</p></li><li><p>handler：拒绝策略</p></li></ul><p><strong>工作方式：</strong></p><ol><li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p></li><li><p>当线程数达到 corePoolSize 没有线程空闲时，这时再加入任务，新加的任务会被加入 workQueue 队列排 队，直到有空闲的线程。</p></li><li><p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</p></li><li><p>如果线程数达到 maximumPoolSize 仍然有新任务，这时会执行拒绝策略。拒绝策略 jdk 提供了下面的前4 种实现，其它的著名框架也提供了实现：</p><ol><li>ThreadPoolExecutor.AbortPolicy：让调用者抛出RejectedExecutionException 异常，这是默认策略。</li><li>ThreadPoolExecutor.CallerRunsPolicy：让调用者运行任务。</li><li>ThreadPoolExecutor.DiscardPolicy：放弃本次任务。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之。</li><li>Dubbo 的实现：在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题。</li><li>Netty 的实现：创建一个新线程来执行任务。</li><li>ActiveMQ 的实现：带超时等待（60s）尝试放入队列，类似之前自定义的拒绝策略。</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略。</li></ol></li><li><p>当高峰过去后，超过 corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。</p></li></ol><p>jdk 线程池的拒绝策略结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210205102514368.png" alt="在这里插入图片描述"></p><p>据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池。</p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p>newFixedThreadPool 创建的是固定大小的线程池。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建大小为 2 的固定线程池, 自定义线程名称</span></span><br><span class="line"> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">     <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;my_thread_&quot;</span> + atomicInteger.getAndIncrement());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// 开 3 个线程, 线程池大小为 2 , 第三个线程执行时, 如果前两个线程任务没执行完, 会加入任务队列.</span></span><br><span class="line"> executorService.execute(() -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> executorService.execute(() -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> executorService.execute(() -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p> Executors 类 使用 newFixedThreadPool 创建线程的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看到 new ThreadPoolExecutor(xxx) 方法其实是是调用了之前的完整参数的构造方法，创建的是固定的线程数，使用了默认的线程工厂和拒绝策略。</p><p><strong>特点：</strong></p><ul><li>核心线程数 = 最大线程数（没有救急线程被创建），因此也无需超时时间。</li><li>阻塞队列是无界的（LinkedBlockingQueue），可以放任意数量的任务。</li><li>适用于任务量已知，相对耗时的任务。</li></ul><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line"> <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line"> <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着全部都是救急线程（60s 后没有任务就回收），救急线程可以无限创建。</li><li>队列采用了 SynchronousQueue 实现特点是它没有容量，没有线程来取任务是放不进去的（一手交钱、一手交 货）SynchronousQueue。</li><li>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲1分钟后释放线程。</li><li>适合任务数比较密集，但每个任务执行时间较短的情况。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue&lt;Integer&gt; integers = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;putting &#123;&#125; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">                integers.put(<span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125; putted...&quot;</span>, <span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;putting...&#123;&#125; &quot;</span>, <span class="number">2</span>);</span><br><span class="line">                integers.put(<span class="number">2</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125; putted...&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;taking &#123;&#125;&quot;</span>,<span class="number">1</span>);</span><br><span class="line">                integers.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;taking &#123;&#125;&quot;</span>,<span class="number">2</span>);</span><br><span class="line">                integers.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">15.364</span> [t1] DEBUG com.heu.test.TestPool2 - putting <span class="number">1</span> </span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">16.372</span> [t2] DEBUG com.heu.test.TestPool2 - taking <span class="number">1</span></span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">16.373</span> [t1] DEBUG com.heu.test.TestPool2 - <span class="number">1</span> putted...</span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">16.373</span> [t1] DEBUG com.heu.test.TestPool2 - putting..<span class="number">.2</span> </span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">17.373</span> [t3] DEBUG com.heu.test.TestPool2 - taking <span class="number">2</span></span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">17.374</span> [t1] DEBUG com.heu.test.TestPool2 - <span class="number">2</span> putted...</span><br></pre></td></tr></table></figure><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line"> (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><ol><li>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</li><li>newSingleThreadExecutor 和 newFixedThreadPool 区别：<ol><li>自己创建一个单线程串行执行任务，如果任务执行失败而终止，那么没有任何补救措施，而newSingleThreadExecutor 线程池还会新建一个线程，保证池的正常工作。</li><li>newSingleThreadExecutor() 线程个数始终为 1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，不能调用 ThreadPoolExecutor 中特有的方法。</li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改。它对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改。</li></ol></li></ol><p><strong>Executors 返回线程池对象的弊端如下：</strong></p><ul><li><p>FixedThreadPool 和 SingleThreadExecutor：允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。</p></li><li><p>CachedThreadPool 和 ScheduledThreadPool：允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</p></li><li><p>其实就是使用有界队列，控制线程创建数量。</p></li><li><p>此外，除了避免 OOM 的原因之外，不推荐使用 Executors提供的线程池的原因还有：</p><ul><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该显示地给线程池命名，这样有助于我们定位问题。</li></ul></li></ul><h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成。</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line"> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line"> <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line"> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><p><strong>shutdown：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 但已提交任务会执行完，包括等待队列里面的</span></span><br><span class="line"><span class="comment">- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">// 修改线程池状态</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown(); <span class="comment">// 扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试终结(没有运行的线程可以立刻终结)</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>shutdownNow：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将队列中的任务返回</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Runnable&gt; tasks;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           checkShutdownAccess();</span><br><span class="line">           <span class="comment">// 修改线程池状态</span></span><br><span class="line">           advanceRunState(STOP);</span><br><span class="line">           <span class="comment">// 打断所有线程</span></span><br><span class="line">           interruptWorkers();</span><br><span class="line">           <span class="comment">// 获取队列中剩余任务</span></span><br><span class="line">           tasks = drainQueue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 尝试终结</span></span><br><span class="line">       tryTerminate();</span><br><span class="line">       <span class="keyword">return</span> tasks;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>其它方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h4 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h4><p>在任务调度线程池功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        TimerTask task2 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">        <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">        timer.schedule(task1,<span class="number">1000</span>);</span><br><span class="line">        timer.schedule(task2,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">59.276</span> [Timer-<span class="number">0</span>] DEBUG com.heu.test.TestTimer - task <span class="number">1</span></span><br><span class="line"><span class="number">20</span>:<span class="number">41</span>:<span class="number">01.296</span> [Timer-<span class="number">0</span>] DEBUG com.heu.test.TestTimer - task <span class="number">2</span></span><br></pre></td></tr></table></figure><p>使用 ScheduledExecutorService 改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        executorService.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">任务<span class="number">1</span>，执行时间：Mon Jun <span class="number">14</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">29</span> CST <span class="number">2021</span></span><br><span class="line">任务<span class="number">2</span>，执行时间：Mon Jun <span class="number">14</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">29</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure><ul><li>整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放，用来执行延迟或反复执行的任务。</li></ul><p><strong>scheduleAtFixedRate 例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">30.311</span> TestTimer [main] - start... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">31.360</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">33.361</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">35.362</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">37.362</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br></pre></td></tr></table></figure><p>输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s。</p><p><strong>scheduleWithFixedDelay 例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleWithFixedDelay(()-&gt; &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">55.078</span> TestTimer [main] - start... </span><br><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">56.140</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">59.143</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">41</span>:<span class="number">02.145</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">41</span>:<span class="number">05.147</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br></pre></td></tr></table></figure><p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所以间隔都是 3s。</p><h4 id="正确处理执行任务异常"><a href="#正确处理执行任务异常" class="headerlink" title="正确处理执行任务异常"></a>正确处理执行任务异常</h4><p>如果线程池中的线程执行任务时，如果任务抛出了异常，默认是中断执行该任务而不是抛出异常或者打印异常信息。</p><p><strong>方法1：主动捉异常：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> log.error(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>方法2：使用 Future，错误信息都被封装进submit方法的返回方法中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());</span><br></pre></td></tr></table></figure><h3 id="Tomcat-线程池"><a href="#Tomcat-线程池" class="headerlink" title="Tomcat 线程池"></a>Tomcat 线程池</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210614205652864.png" alt="image-20210614205652864"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲。</li><li>Acceptor 只负责【接收新的 socket 连接】。</li><li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】。</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理。</li><li>Executor 线程池中的工作线程最终负责【处理请求】。</li></ul><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同，如果总线程数达到 maximumPoolSize，这时不会立刻抛 RejectedExecutionException 异常，而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常。</p><p> <strong>tomcat部分源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        submittedCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.execute(command);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">                <span class="keyword">final</span> TaskQueue queue = (TaskQueue)<span class="keyword">super</span>.getQueue();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 使任务从新进入阻塞队列</span></span><br><span class="line">                    <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                        submittedCount.decrementAndGet();</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Queue capacity is full.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    Thread.interrupted();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> rx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">force</span><span class="params">(Runnable o, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( parent.isShutdown() )</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(</span><br><span class="line">                    <span class="string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span></span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.offer(o,timeout,unit); <span class="comment">//forces the item onto the queue, to be used if the task</span></span><br><span class="line">        is rejected</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Connector 配置如下：</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210205230217933.png" alt="在这里插入图片描述" style="zoom:80%;" /><p><strong>Executor 线程池配置如下：</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210205230254525.png" alt="在这里插入图片描述" style="zoom:80%;" /><p>可以看到该线程池实现的是一个无界的队列，所以说是不是执行任务的线程数大于了核心线程数，都会添加到阻塞队列中，那么救急线程是不是就不会用到呢，其实不是，分析如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210205225434672.png" alt="在这里插入图片描述"></p><p>如图所示，当添加新的任务时，如果提交的任务大于核心线程数小于最大线程数就创建救急线程，否则就加入任务队列中。</p><h3 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h3><p><strong>定义：</strong></p><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</p><p><strong>例如</strong>：</p><p>海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那 么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message） 注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率 例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工。</p><p><strong>饥饿：</strong></p><p>固定大小线程池会有饥饿现象，解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步模式之工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Code_07_StarvationTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_07_StarvationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;青椒肉丝&quot;</span>, <span class="string">&quot;千张肉丝&quot;</span>));</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cooking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(random.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 演示饥饿现象</span></span><br><span class="line"><span class="comment">//  ExecutorService executorService = Executors.newFixedThreadPool(2);</span></span><br><span class="line"><span class="comment">//  test1(executorService);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决</span></span><br><span class="line">        ExecutorService cookPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        ExecutorService waiterPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上菜 &#123;&#125; &quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f2 = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上菜 &#123;&#125; &quot;</span>, f2.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">( ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上菜 &#123;&#125; &quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f2 = executorService.submit(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上菜 &#123;&#125; &quot;</span>, f2.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建多大的线程池合适?</strong></p><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿，过大会导致更多的线程上下文切换，占用更多内存。</p><ol><li>CPU 密集型运算 通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费。</li><li>I/O 密集型运算 CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</li><li>经验公式如下：<ol><li>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间。</li><li>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 50% = 8。</li><li>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 10% = 40。</li></ol></li></ol><h3 id="应用之定时任务"><a href="#应用之定时任务" class="headerlink" title="应用之定时任务"></a>应用之定时任务</h3><p>使用 newScheduledThreadPool 中的 scheduleAtFixedRate 这个方法可以执行定时任务。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">// 获取每周四晚时间</span></span><br><span class="line">        LocalDateTime time = now.withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.THURSDAY);</span><br><span class="line">        <span class="keyword">if</span>(now.compareTo(time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> initalDelay = Duration.between(now, time).toMillis();</span><br><span class="line">        <span class="comment">// 一周的时间</span></span><br><span class="line">        <span class="keyword">long</span> period = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// initalDelay 表示当前时间与周四的时间差, period 一周的间隔时间。</span></span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建一个定时任务, 每周四 18:00:00 执行。</span></span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        &#125;, initalDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadPoolExecutor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发—JMM、Volatile、CAS</title>
      <link href="2021/05/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94JMM%E3%80%81Volatile%E3%80%81CAS/"/>
      <url>2021/05/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94JMM%E3%80%81Volatile%E3%80%81CAS/</url>
      
        <content type="html"><![CDATA[<h2 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h2><h3 id="Java-内存模型（JMM）"><a href="#Java-内存模型（JMM）" class="headerlink" title="Java 内存模型（JMM）"></a>Java 内存模型（JMM）</h3><p>JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）的抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><p>JMM 体现在以下几个方面：</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响。</li><li>可见性 - 保证指令不会受 cpu 缓存的影响。</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响。</li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a><strong>退不出的循环</strong></h4><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(run) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;t1 Stop&quot;</span>);</span><br><span class="line">        run = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为什么呢？分析一下：</p><ol><li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</p></li><li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率。</p></li><li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。分析如下：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210608104021476.png" alt="image-20210608104021476" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210608104045387.png" alt="image-20210608104045387" style="zoom: 448%;" /><strong>解决方法</strong></p></li></ol><ul><li>使用 volatile （易变关键字）</li><li>它可以用来修饰成员变量和静态成员变量（放在主存中的变量），可以避免线程从自己的工作缓存中查找变量的值，而必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。</li></ul><h4 id="可见性-vs-原子性"><a href="#可见性-vs-原子性" class="headerlink" title="可见性 vs 原子性"></a><strong>可见性</strong> <strong>vs</strong> <strong>原子性</strong></h4><p>上面例子体现的实际上就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，但不能保证原子性，仅用在一个写线程，多个读线程的情况。</p><ul><li>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低。</li><li>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了。因为 printIn() 方法使用了 synchronized 同步代码块，可以保证原子性与可见性，它是 PrintStream 类的方法。</li></ul><h3 id="CPU缓存结构原理"><a href="#CPU缓存结构原理" class="headerlink" title="CPU缓存结构原理"></a>CPU缓存结构原理</h3><h4 id="CPU缓存结构"><a href="#CPU缓存结构" class="headerlink" title="CPU缓存结构"></a>CPU缓存结构</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210608110939298.png" alt="image-20210608110939298" style="zoom:80%;" /><p><strong>速度比较</strong></p><table><thead><tr><th><strong>从</strong> <strong>cpu</strong> <strong>到</strong></th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><p><strong>cpu 拿到的内存地址格式是这样的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[高位组标记][低位索引][偏移量]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210608111443605.png" alt="image-20210608111443605"></p><h4 id="CPU-缓存读"><a href="#CPU-缓存读" class="headerlink" title="CPU 缓存读"></a><strong>CPU</strong> <strong>缓存读</strong></h4><p>读取数据流程如下：</p><ul><li>根据低位，计算在缓存中的索引；</li><li>判断是否有效：<ul><li>0 去内存读取新数据更新缓存行；</li><li>1 再对比高位组标记是否一致：<ul><li>一致，根据偏移量返回缓存数据；</li><li>不一致，去内存读取新数据更新缓存行。</li></ul></li></ul></li></ul><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>Memory Barrier（Memory Fence）：</p><ul><li><p>可见性</p><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中。</li><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据。</li></ul></li><li><p>有序性</p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后。</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前。</li></ul></li></ul><h3 id="模式之两阶段终止"><a href="#模式之两阶段终止" class="headerlink" title="模式之两阶段终止"></a>模式之两阶段终止</h3><p>使用 volatile 关键字来实现两阶段终止模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">monitor.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">monitor.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread monitor;</span><br><span class="line"><span class="comment">// 设置标记，用于判断是否被终止了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置线控器线程，用于监控线程状态</span></span><br><span class="line">monitor = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 开始不停的监控</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(stop) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;处理后续任务&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;监控器运行中...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 线程休眠</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;被打断了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">monitor.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于停止监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 修改标记</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 打断线程</span></span><br><span class="line">monitor.interrupt();        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步模式之-Balking"><a href="#同步模式之-Balking" class="headerlink" title="同步模式之 Balking"></a><strong>同步模式之</strong> <strong>Balking</strong></h3><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回，有点类似单例。</p><ul><li>用一个标记来判断该任务是否已经被执行过了；</li><li>需要避免线程安全问题；</li><li>加锁的代码块要尽量的小，以保证性能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBalking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor.start();</span><br><span class="line">        monitor.start();</span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        monitor.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line">    Thread monitor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> starting = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        monitor = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;处理后续任务&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;监控运行中&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;被打断了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">监控运行中</span><br><span class="line">监控运行中</span><br><span class="line">监控运行中</span><br><span class="line">监控运行中</span><br><span class="line">被打断了</span><br><span class="line">处理后续任务</span><br></pre></td></tr></table></figure><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p><strong>指令重排</strong></p><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="comment">// 在某个线程内执行如下赋值操作</span></span><br><span class="line">i = ...; </span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ...; </span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure><p>也可以是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = ...;</span><br><span class="line">i = ...; </span><br></pre></td></tr></table></figure><p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。</p><p>下面看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span></span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>; </span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line"> r.r1 = num + num;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> num = <span class="number">2</span>;</span><br><span class="line"> ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程环境下，以上的代码 r1 的值有三种情况：</p><ul><li>第一种：线程 2 先执行，然后线程 1 后执行，r1 的结果为 4；</li><li>第二种：线程 1 先执行，然后线程 2 后执行，r1 的结果为 1；</li><li>第三种：线程 2 先执行，但是发生了指令重排，num = 2 与 ready = true 这两行代码语序发生交换，然后执行 ready = true 后，线程 1 运行了，那么 r1 的结果是为 0。</li></ul><p><strong>解决方法</strong></p><p>volatile 修饰的变量，可以禁用指令重排。</p><h3 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h3><p>volatile 的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令<strong>后会加入写屏障</strong>。</li><li>对 volatile 变量的读指令<strong>前会加入读屏障</strong>。</li></ul><h4 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h4><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">     num = <span class="number">2</span>;</span><br><span class="line">     ready = <span class="keyword">true</span>; <span class="comment">// ready 是被 volatile 修饰的，赋值带写屏障</span></span><br><span class="line">     <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 读屏障</span></span><br><span class="line"> <span class="comment">// ready是被 volatile 修饰的，读取值带读屏障</span></span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line"> r.r1 = num + num;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析如图：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210202154154463.png" alt="在这里插入图片描述" style="zoom:80%;" /></li></ul><h4 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h4><ul><li>写屏障会确保指令重排时，不会将写屏障之前的代码排在写屏障之后。</li><li>读屏障会确保指令重排时，不会将读屏障之后的代码排在读屏障之前。</li></ul><p>volatile 不能解决指令交错，写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其它线程的读跑到它前面去。<br>而有序性的保证也只是保证了本线程内相关代码不被重排序。</p><h4 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a>double-checked locking 问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 最开始的单例模式是这样的</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">         <span class="comment">// 首次访问会同步，而之后的使用不用进入synchronized</span></span><br><span class="line">       <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">       <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">       INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">         <span class="keyword">return</span> INSTANCE;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 但是上面的代码块的效率是有问题的，因为即使已经产生了单实例之后，之后调用了getInstance()方法之后还是会加锁，这会严重影响 性能！因此就有了模式如下double-checked locking</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">                <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//但是上面的if(INSTANCE == null)判断代码没有在同步代码块synchronized中，不能享有synchronized保证的原子性，可见性。</span></span><br></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁。</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外。</li></ul><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic #2 // Field INSTANCE:com/heu/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line"><span class="comment">// ldc是获得类对象</span></span><br><span class="line">6: ldc #3 // class com/heu/n5/Singleton</span><br><span class="line"><span class="comment">// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="comment">// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span></span><br><span class="line"><span class="comment">// 将类对象的引用地址存储了一份，是为了将来解锁用</span></span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line">11: getstatic #2 // Field INSTANCE:com/heu/n5/Singleton;</span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="comment">// 新建一个实例</span></span><br><span class="line">17: new #3 // class com/heu/n5/Singleton</span><br><span class="line"><span class="comment">// 复制了一个实例的引用</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="comment">// 通过这个复制的引用调用它的构造方法</span></span><br><span class="line">21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"><span class="comment">// 最开始的这个引用用来进行赋值操作</span></span><br><span class="line">24: putstatic #2 // Field INSTANCE:com/heu/n5/Singleton;</span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line">37: getstatic #2 // Field INSTANCE:com/heu/n5/Singleton;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>17 表示创建对象，将对象引用入栈 // new Singleton。</li><li>20 表示复制一份对象引用 // 复制了引用地址。</li><li>21 表示利用一个对象引用，调用构造方法 // 根据复制的引用地址调用构造方法。</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE。</li></ul><p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210202172322592.png" alt="在这里插入图片描述" style="zoom:80%;" /><p>关键在于 0: getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值，这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的将是一个未初始化完毕的单例，解决方法是对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效。</p><h4 id="double-checked-locking-解决"><a href="#double-checked-locking-解决" class="headerlink" title="double-checked locking 解决"></a>double-checked locking 解决</h4><p>加上volatile就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// t2</span></span><br><span class="line">                    <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上面的注释内容所示，读写 volatile 变量操作（即 getstatic 操作和 putstatic 操作）时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p><ol><li>可见性<ul><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中。</li><li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据。</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后。</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前。</li></ul></li></ol><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>下面说的变量都是指成员变量或静态成员变量。</p><ol><li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure></li><li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或t2.isInterrupted）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            x = <span class="number">10</span>;</span><br><span class="line">            t2.interrupt();</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见。</p></li><li><p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y; </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123; </span><br><span class="line">y = <span class="number">10</span>; </span><br><span class="line">x = <span class="number">20</span>; </span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start(); </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123; </span><br><span class="line"><span class="comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见 </span></span><br><span class="line">System.out.println(x); </span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start(); </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="balking-模式习题"><a href="#balking-模式习题" class="headerlink" title="balking 模式习题"></a><strong>balking 模式习题</strong></h4><p>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        doInit();</span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>volatile 可以保存线程的可见性，有序性，但是不能保证原子性，doInit 方法没加锁，可能会被调用多次。</p><h4 id="线程安全单例习题"><a href="#线程安全单例习题" class="headerlink" title="线程安全单例习题"></a><strong>线程安全单例习题</strong></h4><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试着分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题。</p><ul><li>饿汉式：类加载就会导致该单实例对象被创建。</li><li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建。</li></ul><p><strong>实现1： 饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final，防止子类继承后更改</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有? 防止其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?没有，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</span></span><br><span class="line">    <span class="comment">//1.提供更好的封装性；2.提供范型的支持</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现2： 饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例：不能</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现3：懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大，每次访问都会加锁，性能比较低。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现4：DCL 懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile ?为了防止重排序问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？这是为了第一次判断时的并发问题。</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现5：静态内部类懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式：懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行       //LazyHolder内部类的类加载操作的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题，这是线程安全的，类加载时，jvm保证类加载操作的线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h2><h3 id="无锁解决线程安全问题"><a href="#无锁解决线程安全问题" class="headerlink" title="无锁解决线程安全问题"></a>无锁解决线程安全问题</h3><h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><p>有如下需求，保证 account.withdraw 取款方法的线程安全，先看一个线程不安全的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCAS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> AccountUnsafe(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取余额</span></span><br><span class="line">    <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//取款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end-start)/<span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountUnsafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某次执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">420 cost: 151 ms</span><br></pre></td></tr></table></figure><p><strong>为什么不安全</strong></p><p>执行withdraw 方法对应的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ALOAD <span class="number">0</span> <span class="comment">// &lt;- this</span></span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line">GETFIELD com/heu/AccountUnsafe.balance : Ljava/lang/Integer; <span class="comment">// &lt;- this.balance</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I <span class="comment">// 拆箱</span></span><br><span class="line">ALOAD <span class="number">1</span> <span class="comment">// &lt;- amount</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I<span class="comment">// 拆箱</span></span><br><span class="line">ISUB <span class="comment">// 减法</span></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; <span class="comment">// 结果装箱</span></span><br><span class="line">PUTFIELD com/heu/AccountUnsafe.balance : Ljava/lang/Integer; <span class="comment">// -&gt; this.balance</span></span><br></pre></td></tr></table></figure><ul><li><p>单核的指令交错</p></li><li><p>多核的指令交错</p></li></ul><h4 id="解决思路—锁"><a href="#解决思路—锁" class="headerlink" title="解决思路—锁"></a><strong>解决思路—锁</strong></h4><p>首先想到的是给 Account 对象加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountUnsafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 cost: 231 ms</span><br></pre></td></tr></table></figure><p>如上代码加锁会造成线程堵塞，堵塞的时间取决于临界区代码执行的时间，这使用加锁的性能不高，因此可以使用无锁来解决此问题。</p><h4 id="解决思路—无锁"><a href="#解决思路—无锁" class="headerlink" title="解决思路—无锁"></a>解决思路—无锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    AtomicInteger atomicInteger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountUnsafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atomicInteger = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Integer pre = getBalance();</span><br><span class="line">            <span class="keyword">int</span> next = pre - amount;</span><br><span class="line">            <span class="comment">//如果当前值等于参数给定的期望值，则将值设置为参数中的传递值。该函数返回一个布尔值，该布尔值使我们了解更新是否完成.</span></span><br><span class="line">            <span class="comment">//compareAndSet方法实际上是做了两步操作，第一步是比较，第二步是把value的值更新，这两步是原子操作，在没有多线程锁的情况下，借助cpu锁保证数据安全。</span></span><br><span class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(pre, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 cost: 213 ms</span><br></pre></td></tr></table></figure><h3 id="CAS-与-volatile"><a href="#CAS-与-volatile" class="headerlink" title="CAS 与 volatile"></a><strong>CAS</strong> <strong>与</strong> <strong>volatile</strong></h3><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 比如拿到了旧值 1000</span></span><br><span class="line">            Integer pre = getBalance();</span><br><span class="line">            <span class="comment">// 在这个基础上 1000-10 = 990</span></span><br><span class="line">            <span class="keyword">int</span> next = pre - amount;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">             compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值：</span></span><br><span class="line"><span class="comment"> - 不一致了，next 作废，返回 false 表示失败比如，别的线程已经做了减法，当前值已经被减成了 990，那么本线程的这次 990 就作废了，进入 while 下次循环重试；</span></span><br><span class="line"><span class="comment">    - 一致，以 next 设置为新值，返回 true 表示成功 。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(pre, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210202215325496.png" alt="在这里插入图片描述" style="zoom:80%;" /><p>当一个线程要去修改 Account 对象中的值时，先获取值 preVal（调用get方法），然后再将其设置为新的值 nextVal（调用 cas 方法）。在调用 cas 方法时，会将 pre 与 Account 中的余额进行比较：</p><ul><li>如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果两者不相等，就不设置值，重新获取值 preVal（调用get方法），然后再将其设置为新的值 nextVal（调用cas方法），直到修改成功为止。</li></ul><p><strong>注意：</strong></p><ul><li>CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</li><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的 。</li></ul><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ul><li>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</li><li>它可以用来修饰成员变量和静态成员变量，可以避免线程从自己的工作缓存中查找变量的值，保证其必须到主存中获取变量的值。</li><li>线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</li><li>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）。</li><li>CAS 是原子性操作借助 volatile 读取到共享变量的新值来实现【比较并交换】的效果。</li></ul><h4 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a><strong>为什么无锁效率高</strong></h4><ul><li><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</p></li><li><p>打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大。</p></li><li><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p></li></ul><h4 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h4><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思。<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li><li>但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响。</li></ul></li></ul><h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><p>java.util.concurrent.atomic 并发包提供了一些并发工具类，这里把它分成五类，分别是：</p><ul><li><p>原子类</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul></li><li><p>原子引用</p></li><li><p>原子数组</p></li><li><p>字段更新器</p></li><li><p>原子累加器</p></li></ul><p>下面先讨论原子整数类，以 AtomicInteger 为例讨论它的api接口：通过观察源码可以发现，AtomicInteger 内部是通过cas的原理来实现的。上面三个原子类提供的方法几乎相同，所以我们将以 AtomicInteger 为例子进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">        System.out.println(i.getAndIncrement());</span><br><span class="line">        <span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">        System.out.println(i.incrementAndGet());</span><br><span class="line">        <span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">        System.out.println(i.decrementAndGet());</span><br><span class="line">        <span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">        System.out.println(i.getAndDecrement());</span><br><span class="line">        <span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">        System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">        System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line">        <span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">        <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">        System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line">        <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">        System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line">        <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">        <span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line">        <span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">        System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">        <span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span></span><br><span class="line">        <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">        System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p><strong>为什么需要原子引用类型？</strong></p><p>保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）。基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。</p><p>原子引用：</p><ul><li>AtomicReference：引用类型原子类。</li><li>AtomicStampedReference：原子更新带有版本号的引用类型，该类将整数值与引用关联起来，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li></ul><h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>还是上面取款的案例，试着提供不同的 DecimalAccount 实现，实现安全的取款操作。</p><p><strong>不安全实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecimalAccountUnsafe</span> <span class="keyword">implements</span> <span class="title">DecimalAccount</span> </span>&#123;</span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccountUnsafe</span><span class="params">(BigDecimal balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取款任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">        BigDecimal balance = <span class="keyword">this</span>.getBalance();</span><br><span class="line">        <span class="keyword">this</span>.balance = balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 withdraw 方法时，可能会有线程安全问题，我们可以加锁解决或者是使用无锁的方式 CAS 来解决，这里的解决方式是用AtomicReference 原子引用解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecimalAccountCas</span> <span class="keyword">implements</span> <span class="title">DecimalAccount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccountCas</span><span class="params">(BigDecimal balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicReference&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            BigDecimal preVal = balance.get();</span><br><span class="line">            BigDecimal nextVal = preVal.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span>(balance.compareAndSet(preVal, nextVal)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        String preVal = ref.get();</span><br><span class="line">        other();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(preVal, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败的话，这时，仅比较值是不够的，需要再加一个版本号。使用AtomicStampedReference来解决。</p><h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><p>使用 AtomicStampedReference 加 stamp （版本号或者时间戳）的方式解决 ABA 问题。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicStampedReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        String preVal = ref.getReference();</span><br><span class="line">        <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">        log.info(<span class="string">&quot;main 拿到的版本号 &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        other();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">&quot;修改后的版本号 &#123;&#125;&quot;</span>,ref.getStamp());</span><br><span class="line">        log.info(<span class="string">&quot;change A-&gt;C:&#123;&#125;&quot;</span>, ref.compareAndSet(preVal, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            log.info(<span class="string">&quot;change A-&gt;B:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            log.debug(<span class="string">&quot;change B-&gt;A:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>,stamp,stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">22.772</span> [main] DEBUG com.heu.test.TestAtomicStampedReference - main start...</span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">22.782</span> [main] INFO com.heu.test.TestAtomicStampedReference - main 拿到的版本号 <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">22.788</span> [Thread-<span class="number">0</span>] INFO com.heu.test.TestAtomicStampedReference - <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">22.788</span> [Thread-<span class="number">0</span>] INFO com.heu.test.TestAtomicStampedReference - change A-&gt;B:<span class="keyword">true</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">23.792</span> [Thread-<span class="number">1</span>] INFO com.heu.test.TestAtomicStampedReference - <span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">23.792</span> [Thread-<span class="number">1</span>] DEBUG com.heu.test.TestAtomicStampedReference - change B-&gt;A:<span class="keyword">true</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">24.793</span> [main] INFO com.heu.test.TestAtomicStampedReference - 修改后的版本号 <span class="number">2</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">24.793</span> [main] INFO com.heu.test.TestAtomicStampedReference - change A-&gt;C:<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h4><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; A -&gt;C，通过AtomicStampedReference可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference 。</p><h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><p>使用原子的方式更新数组里的某个元素：</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><p>使用原子数组可以保证元素的线程安全。</p><p>上面三个类提供的方法几乎相同，所以这里以 AtomicIntegerArray 为例子来介绍，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicIntegerArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不安全的数组</span></span><br><span class="line">        demo(</span><br><span class="line">                ()-&gt;<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">                (array)-&gt;array.length,</span><br><span class="line">                (array, index) -&gt; array[index]++,</span><br><span class="line">                array-&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//安全的数组</span></span><br><span class="line">        demo(</span><br><span class="line">            ()-&gt;<span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>),</span><br><span class="line">                (array) -&gt; array.length(),</span><br><span class="line">                (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">                (array) -&gt; System.out.println(array)</span><br><span class="line">        );        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Supplier&lt;T&gt; arraySupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">        Function&lt;T,Integer&gt; lengthFun,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;T,Integer&gt; putConsumer,</span></span></span><br><span class="line"><span class="function"><span class="params">        Consumer&lt;T&gt; printConsumer)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        T array = arraySupplier.get();</span><br><span class="line">        <span class="keyword">int</span> length = lengthFun.apply(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    putConsumer.accept(array,j%length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(t-&gt;t.start());</span><br><span class="line">        ts.forEach(t-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[9470, 9579, 9616, 9594, 9566, 9633, 9605, 9611, 9892, 9879]</span><br><span class="line"></span><br><span class="line">[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br></pre></td></tr></table></figure><h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be <span class="keyword">volatile</span> type</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFieldUpdater</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> field;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;TestFieldUpdater&gt; fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(TestFieldUpdater.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        TestFieldUpdater updater = <span class="keyword">new</span> TestFieldUpdater();</span><br><span class="line">        fieldUpdater.compareAndSet(updater, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 修改成功 field = 10</span></span><br><span class="line">        System.out.println(updater.field);</span><br><span class="line">        <span class="comment">// 修改成功 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(updater, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(updater.field);</span><br><span class="line">        <span class="comment">// 修改失败 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(updater, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(updater.field);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 </span><br><span class="line">20 </span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><h4 id="AtomicLong-Vs-LongAdder"><a href="#AtomicLong-Vs-LongAdder" class="headerlink" title="AtomicLong Vs LongAdder"></a>AtomicLong Vs LongAdder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLongAdder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(()-&gt;<span class="keyword">new</span> AtomicLong(<span class="number">0</span>),(ref)-&gt;ref.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(()-&gt;<span class="keyword">new</span> LongAdder(),(ref)-&gt;ref.increment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Supplier&lt;T&gt; supplier, Consumer&lt;T&gt; consumer)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        T adder = supplier.get();</span><br><span class="line">        <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                    consumer.accept(adder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        list.forEach(t -&gt; t.start());</span><br><span class="line">        list.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start)/<span class="number">1000_000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2000000 cost:80</span><br><span class="line">2000000 cost:76</span><br><span class="line">2000000 cost:60</span><br><span class="line">2000000 cost:56</span><br><span class="line">2000000 cost:52</span><br><span class="line">2000000 cost:32</span><br><span class="line">2000000 cost:5</span><br><span class="line">2000000 cost:8</span><br><span class="line">2000000 cost:8</span><br><span class="line">2000000 cost:20</span><br></pre></td></tr></table></figure><p>结论：</p><blockquote><p>执行代码后，发现使用 LongAdder 比 AtomicLong 快2，3倍，使用 LongAdder 性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p></blockquote><h4 id="CAS锁"><a href="#CAS锁" class="headerlink" title="CAS锁"></a>CAS锁</h4><p><strong>使用 cas 实现一个自旋锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockCas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">// 如果 state 值为 0 表示没上锁, 1 表示上锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlock...&quot;</span>);</span><br><span class="line">        state.set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Code_13_LockCas lock = <span class="keyword">new</span> Code_13_LockCas();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上锁成功&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上锁成功&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LongAdder-原理"><a href="#LongAdder-原理" class="headerlink" title="LongAdder 原理"></a>LongAdder 原理</h3><p>LongAdder 类有几个关键域，在public class LongAdder extends Striped64 implements Serializable {}，下面的变量属于 Striped64 被 LongAdder 继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"><span class="comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy; </span><br></pre></td></tr></table></figure><h4 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a><strong>原理之伪共享</strong></h4><p>其中 Cell 即为累加单元。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="comment">// 最重要的方法, 用 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> prev, <span class="keyword">long</span> next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想讨论 @sun.misc.Contended 注解的重要意义得从缓存说起，缓存与内存的速度比较：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210608110939298.png" alt="image-20210608110939298" style="zoom:80%;" /><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。缓存离 cpu 越近速度越快。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210609205336917.png" alt="image-20210609205336917" style="zoom:80%;" /><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了： Core-0 要修改 Cell[0]，Core-1 要修改 Cell[1]，无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这会让 Core-1 的缓存行失效，而@sun.misc.Contended 就是用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效。<br><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210609205244398.png" alt="image-20210609205244398"></p><h4 id="add-方法分析"><a href="#add-方法分析" class="headerlink" title="add 方法分析"></a>add 方法分析</h4><p>LongAdder 进行累加操作是调用 increment 方法，它又调用 add 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>第一步：add 方法分析，流程图如下：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210203225824450.png" alt="在这里插入图片描述"></p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// as 为累加单元数组, b 为基础值, x 为累加值</span></span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">        <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span></span><br><span class="line">        <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">        <span class="comment">// 3. 如果 as 没有创建, 然后 cas 累加成功就返回，累加到 base 中 不存在线程竞争的时候用到。</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="comment">// uncontended 表示 cell 是否有竞争，这里赋值为 true 表示有竞争</span></span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// as 还没有创建</span></span><br><span class="line">                    as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                            <span class="comment">// 当前线程对应的 cell 还没有被创建，a为当线程的cell</span></span><br><span class="line">                            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">       <span class="comment">// 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">                            !(uncontended = a.cas(v = a.value, v + x))</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// 当 cells 为空时，累加操作失败会调用方法，</span></span><br><span class="line">                <span class="comment">// 当 cells 不为空，当前线程的 cell 创建了但是累加失败了会调用方法，</span></span><br><span class="line">                <span class="comment">// 当 cells 不为空，当前线程 cell 没创建会调用这个方法</span></span><br><span class="line">                <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">                longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：longAccumulate 方法分析，流程图如下：</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210609210026550.png" alt="image-20210609210026550" style="zoom:80%;" /><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span></span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化 probe</span></span><br><span class="line">            ThreadLocalRandom.current();</span><br><span class="line">            <span class="comment">// h 对应新的 probe 值, 用来对应 cell</span></span><br><span class="line">            h = getProbe();</span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// collide 为 true 表示需要扩容</span></span><br><span class="line">        <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">            <span class="comment">// 已经有了 cells</span></span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 但是还没有当前线程对应的 cell</span></span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span></span><br><span class="line">                    <span class="comment">// 成功则 break, 否则继续 continue 循环</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                        Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                            <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    <span class="comment">// 判断槽位确实是空的</span></span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="keyword">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                    wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">                h = advanceProbe(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还没有 cells, cells==as是指没有其它线程修改cells，as和cells引用相同的对象，使用casCellsBusy()尝试给 cellsBusy 加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span></span><br><span class="line">                <span class="comment">// 成功则 break;</span></span><br><span class="line">                <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                        cells = rs;</span><br><span class="line">                        init = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上两种情况失败, 尝试给 base 使用casBase累加</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="sum-方法分析"><a href="#sum-方法分析" class="headerlink" title="sum 方法分析"></a><strong>sum 方法分析</strong></h4><p>获取最终结果通过 sum 方法，将各个累加单元的值加起来就得到了总的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        <span class="keyword">long</span> sum = base;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Unsafe方法"><a href="#Unsafe方法" class="headerlink" title="Unsafe方法"></a>Unsafe方法</h3><h4 id="Unsafe-对象的获取"><a href="#Unsafe-对象的获取" class="headerlink" title="Unsafe 对象的获取"></a>Unsafe 对象的获取</h4><p>Unsafe 对象提供了非常底层的操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。LockSupport 的 park 方法，CAS 相关的方法底层都是通过Unsafe类来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line"><span class="comment">// Unsafe 使用了单例模式，unsafe 对象是类中的一个私有的变量 </span></span><br><span class="line">        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe)theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Unsafe-模拟实现-cas-操作"><a href="#Unsafe-模拟实现-cas-操作" class="headerlink" title="Unsafe 模拟实现 cas 操作"></a>Unsafe 模拟实现 cas 操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 unsafe 对象</span></span><br><span class="line">        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe)theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到偏移量</span></span><br><span class="line">        <span class="keyword">long</span> idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行 cas 操作</span></span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">        unsafe.compareAndSwapLong(teacher, idOffset, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        unsafe.compareAndSwapObject(teacher, nameOffset, <span class="keyword">null</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Unsafe-模拟实现原子整数"><a href="#Unsafe-模拟实现原子整数" class="headerlink" title="Unsafe 模拟实现原子整数"></a>Unsafe 模拟实现原子整数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> MyAtomicInteger(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicInteger</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAtomicInteger</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Integer preVal = <span class="keyword">this</span>.value;</span><br><span class="line">            Integer nextVal = preVal - amount;</span><br><span class="line">            <span class="keyword">if</span>(UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, preVal, nextVal)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        decrement(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h2><h3 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h3><p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的，有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread-3&quot;</span> Exception in thread <span class="string">&quot;Thread-0&quot;</span> java.lang.NumberFormatException: For input string: <span class="string">&quot;1951.&quot;</span></span><br><span class="line">at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.base/java.lang.Long.parseLong(Long.java:<span class="number">692</span>)</span><br><span class="line">at java.base/java.lang.Long.parseLong(Long.java:<span class="number">817</span>)</span><br><span class="line">at java.base/java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2123</span>)</span><br><span class="line">at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1933</span>)</span><br><span class="line">at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1541</span>)</span><br><span class="line">at java.base/java.text.DateFormat.parse(DateFormat.java:<span class="number">393</span>)</span><br><span class="line">at com.heu.test.TestDate.lambda$main$<span class="number">0</span>(TestDate.java:<span class="number">21</span>)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>)</span><br></pre></td></tr></table></figure><p>如果一个对象不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改！这样的对象在 java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类 DateTimeFormatter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                LocalDate date = dtf.parse(<span class="string">&quot;2018-10-01&quot;</span>, LocalDate::from);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, date);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h3><p>String类中不可变的体现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final-的使用"><a href="#final-的使用" class="headerlink" title="final 的使用"></a>final 的使用</h4><p>发现该类、类中所有属性都是 ﬁnal 的：</p><ul><li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改。</li><li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性。</li></ul><h4 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h4><p>有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">        <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面是一些校验，下面才是真正的创建新的String对象</span></span><br><span class="line">        <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">                : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现其内部是调用 String 的构造方法创建了一个新字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">               <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">       <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值</span></span><br><span class="line">       <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为保护性拷贝（defensive copy）。</p><h3 id="模式之享元"><a href="#模式之享元" class="headerlink" title="模式之享元"></a>模式之享元</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>享元定义英文名称：Flyweight pattern。当需要重用数量有限的同一类对象时，归类为：Structual patterns。</p><h4 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h4><p><strong>包装类</strong><br>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法。例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line"> <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line"> <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Byte, Short, Long 缓存的范围都是 -128~127。</li><li>Character 缓存的范围是 0~127。</li><li>Integer 的默认范围是 -128~127，最小值不能变，但最大值可以通过调整虚拟机参数 “-Djava.lang.Integer.IntegerCache.high “来改变。</li><li>Boolean 缓存了 TRUE 和 FALSE。</li></ul><h3 id="final的原理"><a href="#final的原理" class="headerlink" title="final的原理"></a>final的原理</h3><p><strong>设置 final 变量的原理</strong></p><p>理解了 volatile 原理，再对比 final 的实现就比较简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line">1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"><span class="number">4</span>: aload_0</span><br><span class="line"><span class="number">5</span>: bipush <span class="number">20</span></span><br><span class="line">7: putfield #2 // Field a:I</span><br><span class="line"> &lt;-- 写屏障</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>final 变量的赋值操作都必须在定义时或者构造器中进行初始化赋值，并且发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况。</p>]]></content>
      
      
      <categories>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
            <tag> Volatile </tag>
            
            <tag> CAS </tag>
            
            <tag> AtomicReference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发—共享模型之管程</title>
      <link href="2021/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/"/>
      <url>2021/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h2><h3 id="线程共享带来的问题"><a href="#线程共享带来的问题" class="headerlink" title="线程共享带来的问题"></a>线程共享带来的问题</h3><p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;count的值是&#123;&#125;&quot;</span>,count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上代码，当执行 count++ 或者 count– 操作的时候，从字节码分析，实际上是 4 步操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">count++; </span><br><span class="line"><span class="comment">// 操作字节码如下：</span></span><br><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">iadd <span class="comment">// 自增</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br><span class="line"></span><br><span class="line">count--; </span><br><span class="line"><span class="comment">// 操作字节码如下：</span></span><br><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">isub <span class="comment">// 自减</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure><p>如果上面代码是单线程按顺序运行的，那么count的值不会计算错，执行过程如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210603162020219.png" alt="image-20210603162020219" style="zoom: 50%;" /></p><p>但多线程下上面代码可能交错运行，出现负数的情况：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210603162438074.png" alt="image-20210603162438074" style="zoom:50%;" /><p>但多线程下上面代码可能交错运行，出现正数的情况：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210603162738148.png" alt="image-20210603162738148" style="zoom:50%;" /><ol><li><p><strong>临界区 Critical Section</strong></p><ul><li><p>一个程序运行多个线程本身是没有问题的；</p></li><li><p>问题出在多个线程访问共享资源：</p><ul><li>多个线程读共享资源其实也没有问题；</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题。</li></ul></li><li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区。</p><p>例如下面代码中的临界区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 临界区 </span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 临界区 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    counter--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>竞态条件 Race Condition</strong></p></li></ol><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件。</p><h3 id="synchronized-解决方案"><a href="#synchronized-解决方案" class="headerlink" title="synchronized 解决方案"></a>synchronized 解决方案</h3><p><strong>解决方案</strong></p><p>为了避免临界区中的竞态条件发生，由多种手段可以达到：</p><ul><li>阻塞式解决方案：synchronized 、Lock</li><li>非阻塞式解决方案：原子变量</li></ul><p>使用 synchronized 来进行解决，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><blockquote><p><strong>注意</strong>：虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li><p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码。</p></li><li><p>同步是由于线程执行的先后、顺序不同，需要一个线程等待其它线程运行到某个点。</p></li></ul></blockquote><p><strong>synchronized 语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实例程序使用synchronized后如下，计算出的结果是正确！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object room = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">             counter++;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">     Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">             counter--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">     t1.start();</span><br><span class="line">     t2.start();</span><br><span class="line">     t1.join();</span><br><span class="line">     t2.join();</span><br><span class="line">     log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized实际上利用对象保证了临界区代码的原子性，临界区内的代码在外界看来是不可分割的，不会被线程切换所打断。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210603182210273.png" alt="image-20210603182210273" style="zoom: 67%;" /><h3 id="synchronized-加在方法上"><a href="#synchronized-加在方法上" class="headerlink" title="synchronized 加在方法上"></a>synchronized 加在方法上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等价于锁住对象</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 等价于锁住类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>所谓的线程八锁</strong></p><p>其实就是考察 synchronized 锁住的是哪个对象。</p><p>情况1：12 或 21</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Number n1 = <span class="keyword">new</span> Number();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2：1s后12，或 2 1s后 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Number n1 = <span class="keyword">new</span> Number();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况3：3 1s 12 或  2 3 1s 1  或 32 1s 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Number n1 = <span class="keyword">new</span> Number();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123; n1.c(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况4：2 1s 后 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Number n1 = <span class="keyword">new</span> Number();</span><br><span class="line">    Number n2 = <span class="keyword">new</span> Number();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况5：2 1s 后 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象锁 b方法获得</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Number n1 = <span class="keyword">new</span> Number();</span><br><span class="line">    Number n2 = <span class="keyword">new</span> Number();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况6：1s 后12， 或 2 1s后 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Number n1 = <span class="keyword">new</span> Number();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况7：2 1s 后 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象锁 b方法获得</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Number n1 = <span class="keyword">new</span> Number();</span><br><span class="line">    Number n2 = <span class="keyword">new</span> Number();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况8：1s 后12， 或 2 1s后 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象锁 b方法获得</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Number n1 = <span class="keyword">new</span> Number();</span><br><span class="line">    Number n2 = <span class="keyword">new</span> Number();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h3><h4 id="成员变量和静态变量的线程安全分析"><a href="#成员变量和静态变量的线程安全分析" class="headerlink" title="成员变量和静态变量的线程安全分析"></a>成员变量和静态变量的线程安全分析</h4><ul><li><p>如果它们没有共享，则线程安全。</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况：</p><ul><li>如果只有读操作，则线程安全；</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全。</li></ul></li></ul><h4 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h4><p><strong>局部变量是否线程安全？</strong></p><ul><li><p>局部变量是线程安全的。</p></li><li><p>但局部变量引用的对象则未必：</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的；</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全。</li></ul></li></ul><p><strong>线程安全的情况</strong></p><p>局部变量【局部变量被初始化为基本数据类型】是安全的，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">     i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程调用 test1() 方法时，局部变量会在每个线程的栈帧内存中被创建多份，是彼此隔离的，因此不存在共享。</p><p> <strong>线程不安全的情况</strong></p><p>如果局部变量引用的对象逃离方法的范围，那么要考虑线程安全的，分析如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeTest unsafeTest = <span class="keyword">new</span> UnsafeTest();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                unsafeTest.method1();</span><br><span class="line">            &#125;, <span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>不安全原因分析</strong></p><p>无论哪个线程中的 method2 和method3 引用的都是同一个对象中的 list 成员变量：一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：</p><ol><li>第一步，在 arrayList[Size] 的位置存放此元素； 第二步增大 Size 的值。</li><li>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情下，比如有两个线程，线程 一先将元素存放在位置 0，但是此时发生上下文切换，线程 B 得到运行的机会，线程B也向此 ArrayList 添加元素，因为此时 Size 仍等于 0 ，所以线程二也将元素存放在位置0，然后线程一和线程二都继续运行，都增加 Size 的值。 那好，现在看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是线程不安全了。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20200307215429-139261.png" alt="1583589268096"></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210129145229674.png" alt="在这里插入图片描述" style="zoom: 67%;" /><p> <strong>解决方法</strong></p><p>可以将list修改成局部变量，然后将 list 作为引用传入方法中，因为局部变量是每个线程私有的，不会出现共享问题，那么就不会有上述问题了。修改的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考 private 或 final的重要性</strong></p><p>在上诉代码中，其实存在线程安全的问题，因为 method2，method3 方法都是用 public 声明的，如果一个类继承 SafeTest 类，对 method2，method3 方法进行了重写，比如重写 method3 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeSubTest</span> <span class="keyword">extends</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到重写的方法中又使用到了线程，当主线程和重写的 method3 方法的线程同时存在，此时 list 就是这两个线程的共享资源了，就会出现线程安全问题，我们可以用 private 访问修饰符解决此问题，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h4><ul><li>String</li><li>Integer</li><li>StringBuﬀer</li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指：多个线程调用它们同一个实例的某个方法时，是线程安全的。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> table.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> table.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><strong>线程安全类方法的组合</strong></p><p>但注意它们多个方法的组合不是原子的，看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line"> table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/2021012916122421.png" alt="在这里插入图片描述" style="zoom:80%;" /><p>如上图所示，当使用方法组合时，出现了线程安全问题，当线程 1 执行完 get(“key”) ，这是一个原子操作没问题，但是在 get(“key”) == null 比较时，如果线程的时间片用完了，线程 2 获取时间片执行了 get(“key”) == null 操作，然后进行 put(“key”, “v2”) 操作，结束后，线程 1 被分配 cpu 时间片继续执行，执行 put 操作就会出现线程安全问题。</p><p><strong>不可变类的线程安全</strong></p><p>String和Integer类都是不可变的类，因为其类内部状态是不可改变的，因此它们的方法都是线程安全的。疑问是String 有 replace，substring 等方法可以改变值啊，其实调用这些方法返回的已经是一个新创建的对象了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">        <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">                : <span class="keyword">new</span> String(value, beginIndex, subLen); <span class="comment">// 新建一个对象，然后返回，没有修改等操作，是线程安全的。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>示例分析-是否线程安全</strong></p><p>分析线程是否安全，先对类的成员变量，类变量，局部变量进行考虑，如果变量会在各个线程之间共享，那么就得考虑线程安全问题了，如果变量A引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量A是线程安全的的。</p><p>示例一：此类不是线程安全的，MyAspect切面类只有一个实例，成员变量start 会被多个线程同时进行读写操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否安全？</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> start = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Before(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            start = System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@After(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">            System.out.println(<span class="string">&quot;cost time:&quot;</span> + (end-start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>示例二：MyServlet、UserServiceImpl、UserDaoImpl类都只有一个实例，UserDaoImpl类中没有成员变量，update方法里的变量引用的对象不是线程共享的，所以是线程安全的；UserServiceImpl类中只有一个线程安全的UserDaoImpl类的实例，那么UserServiceImpl类也是线程安全的，同理 MyServlet也是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 是否安全</span></span><br><span class="line"> <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"> userService.update(...);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 是否安全</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> userDao.update();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> String sql = <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line"> <span class="comment">// 是否安全</span></span><br><span class="line"> <span class="keyword">try</span> (Connection conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例三：跟示例二大体相似，UserDaoImpl类中有成员变量，那么多个线程可以对成员变量conn 同时进行操作，故是不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例四：跟示例三大体相似，UserServiceImpl类的update方法中 UserDao是作为局部变量存在的，所以每个线程访问的时候都会新建有一个UserDao对象，新建的对象是线程独有的，所以是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> Connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例五：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否安全</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        foo(sdf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title">foo</span><span class="params">(SimpleDateFormat sdf)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为外星方法，因为 foo 方法可以被重写，导致线程不安全。在 String 类中就考虑到了这一点，String 类是 final 关键字声明的，子类不能重写它的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(SimpleDateFormat sdf)</span> </span>&#123;</span><br><span class="line">    String dateStr = <span class="string">&quot;1999-10-11 00:00:00&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sdf.parse(dateStr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="案例分析—卖票"><a href="#案例分析—卖票" class="headerlink" title="案例分析—卖票"></a>案例分析—卖票</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExerciseSell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟多人买票</span></span><br><span class="line">        TicketWindow window = <span class="keyword">new</span> TicketWindow(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有线程的集合</span></span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 卖出的票数统计</span></span><br><span class="line">        List&lt;Integer&gt; amountList = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 买票</span></span><br><span class="line">                <span class="keyword">int</span> amount = window.sell(random(<span class="number">5</span>));</span><br><span class="line">                <span class="comment">// 统计买票数</span></span><br><span class="line">                amountList.add(amount);</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计卖出的票数和剩余票数</span></span><br><span class="line">        log.debug(<span class="string">&quot;余票：&#123;&#125;&quot;</span>,window.getCount());</span><br><span class="line">        log.debug(<span class="string">&quot;卖出的票数：&#123;&#125;&quot;</span>, amountList.stream().mapToInt(i-&gt; i).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Random 为线程安全</span></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机 1~5</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(amount) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 售票窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取余票数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 售票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.count &gt;= amount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count -= amount;</span><br><span class="line">            <span class="keyword">return</span> amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Monitor-概念"><a href="#Monitor-概念" class="headerlink" title="Monitor 概念"></a>Monitor 概念</h3><h4 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h4><p>以 32 位虚拟机为例,普通对象的对象头结构如下，其中的Klass Word为指针，指向对应的Class对象。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20200308223951-617147.png" alt="1583651065372"></p><p>数组对象</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130134453728.png" alt="在这里插入图片描述"></p><p>其中 Mark Word 结构为：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130134641162.png" alt="img" style="zoom:80%;" /><p>所以一个对象的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20200308224345-655905.png" alt="1583678624634"></p><h4 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h4><p>Monitor被翻译为监视器或者说管程，每个java对象都可以关联一个Monitor，如果使用synchronized给对象上锁（重量级），该对象头的Mark Word中就被设置为指向Monitor对象的指针。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130135025351.png" alt="在这里插入图片描述" style="zoom:80%;" /><ul><li><p>刚开始时 Monitor 中的 Owner 为 null；</p></li><li><p>当 Thread-2 执行 synchronized(obj){} 代码时就会将 Monitor 的所有者Owner 设置为 Thread-2，上锁成功，Monitor 中同一时刻只能有一个 Owner；</p></li><li><p>当 Thread-2 占据锁时，如果线程 Thread-3 ，Thread-4 也来执行synchronized(obj){} 代码，就会进入 EntryList（阻塞队列） 中变成BLOCKED（阻塞） 状态；</p></li><li><p>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的；</p></li><li><p>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析。</p><blockquote><p>注意：synchronized 必须是进入同一个对象的 monitor 才有上述的效果，不加 synchronized 的对象不会关联监视器，不遵从以上规则。</p></blockquote></li></ul><h3 id="synchronized原理及进阶"><a href="#synchronized原理及进阶" class="headerlink" title="synchronized原理及进阶"></a>synchronized原理及进阶</h3><h4 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码反编译后的部分字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 0 getstatic #2 &lt;com&#x2F;heu&#x2F;test&#x2F;Test17.lock&gt;</span><br><span class="line"> # 取得lock的引用（synchronized开始了）</span><br><span class="line"> 3 dup    </span><br><span class="line"> # 复制操作数栈栈顶的值放入栈顶，即复制了一份lock的引用</span><br><span class="line"> 4 astore_1</span><br><span class="line"> # 操作数栈栈顶的值弹出，即将lock的引用存到局部变量表中</span><br><span class="line"> 5 monitorenter</span><br><span class="line"> # 将lock对象的Mark Word置为指向Monitor指针</span><br><span class="line"> 6 getstatic #3 &lt;com&#x2F;concurrent&#x2F;test&#x2F;Test17.counter&gt;</span><br><span class="line"> 9 iconst_1</span><br><span class="line">10 iadd</span><br><span class="line">11 putstatic #3 &lt;com&#x2F;concurrent&#x2F;test&#x2F;Test17.counter&gt;</span><br><span class="line">14 aload_1</span><br><span class="line"># 从局部变量表中取得lock的引用，放入操作数栈栈顶</span><br><span class="line">15 monitorexit</span><br><span class="line"># 将lock对象的Mark Word重置，唤醒EntryList</span><br><span class="line">16 goto 24 (+8)</span><br><span class="line"># 下面是异常处理指令，可以看到，如果出现异常，也能自动地释放锁</span><br><span class="line">19 astore_2</span><br><span class="line">20 aload_1</span><br><span class="line">21 monitorexit</span><br><span class="line">22 aload_2</span><br><span class="line">23 athrow</span><br><span class="line">24 return</span><br></pre></td></tr></table></figure><p>注意：方法级别的 synchronized 不会在字节码指令中有所体现</p><h4 id="synchronized-原理进阶"><a href="#synchronized-原理进阶" class="headerlink" title="synchronized 原理进阶"></a>synchronized 原理进阶</h4><p>轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code>，假设有两个方法同步块，利用同一个对象加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 B</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的Mark Word和对象引用reference</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210603204523508.png" alt="image-20210603204523508" style="zoom:50%;" /><ol start="2"><li><p>让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130164905217.png" alt="在这里插入图片描述"></p></li><li><p>如果 cas 替换成功，那么对象的对象头储存的就是锁记录的地址和状态 00 表示轻量级锁，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130165114847.png" alt="在这里插入图片描述"></p></li><li><p>如果cas失败，有两种情况：</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，那么表示有竞争，首先会进行自旋锁，自旋一定次数后，如果还是失败就进入锁膨胀阶段。</li><li>如果是自己的线程已经执行了 synchronized 进行加锁，那么再添加一条 Lock Record 作为重入的计数。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130165409613.png" alt="在这里插入图片描述"></p><ol start="5"><li>当线程退出 synchronized 代码块的时候，如果获取的是取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210603205156243.png" alt="image-20210603205156243" style="zoom:50%;" /><ol start="6"><li>当线程退出 synchronized 代码块的时候，如果获取的锁记录取值不为 null，那么使用 cas 将 Mark Word 的值恢复给对象<ol><li>成功则解锁成功</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程。</li></ol></li></ol><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，cas 操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。</p><ol><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130174657210.png" alt="img" style="zoom: 80%;" /><ol start="2"><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程：</li></ol><ul><li>即为对象申请Monitor锁，让Object指向重量级锁地址；</li><li>然后自己进入Monitor 的EntryList 变成BLOCKED状态。</li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130174858951.png" alt="在这里插入图片描述" style="zoom:80%;" /><ol start="3"><li>当 Thread-0 退出 synchronized 同步块时，使用 cas 将 Mark Word 的值恢复给对象头，对象的对象头指向 Monitor，那么会进入重量级锁的解锁过程，即按照 Monitor 的地址找到 Monitor 对象，将 Owner 设置为 null ，唤醒 EntryList 中的 Thread-1 线程。</li></ol><h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换就获得了锁。</p><ol><li>自旋重试成功的情况：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210603210509276.png" alt="image-20210603210509276" style="zoom:50%;" /><ol start="2"><li>自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210603210240902.png" alt="image-20210603210240902" style="zoom:50%;" /><p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在轻量级锁中可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行 CAS 操作，这是有点耗时滴，那么 Java6 开始引入了偏向锁，只有第一次使用 CAS 时将对象的 Mark Word 头设置为偏向线程 ID，之后这个入锁线程再进行重入锁时，发现线程 ID 是自己的，那么就不用再进行CAS了。</p><p><strong>比较轻量级锁与偏向锁：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line"><span class="comment">// 同步块 A</span></span><br><span class="line">m2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line"><span class="comment">// 同步块 B</span></span><br><span class="line">m3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line"><span class="comment">// 同步块 C</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130181026149.png" alt="在这里插入图片描述" style="zoom: 80%;" /><p><strong>偏向状态</strong></p><p>对象头格式如下：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130181306490.png" alt="在这里插入图片描述" style="zoom:80%;" /><p>一个对象的创建过程</p><ul><li><p>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值是101，并且它的 Thread，epoch，age 都是 0 ，在加锁的时候进行设置这些的值。</p></li><li><p>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：<br>-XX:BiasedLockingStartupDelay=0 </p></li><li><p>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中。</p></li><li><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test1 t = <span class="keyword">new</span> Test1();</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t))；</span><br><span class="line">        <span class="keyword">synchronized</span> (t)&#123;</span><br><span class="line">            test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">        &#125;</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>​       输出结果如下，三次输出的状态码都为101：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">biasedLockFlag (1bit): <span class="number">1</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">1</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">1</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br></pre></td></tr></table></figure><p>如果没有开启偏向锁，那么对象创建后最后三位的值为001，这时候它的hashcode、age都为0，hashcode是第一次用到hashcode时才赋值的。在上面测试代码运行时在添加 VM 参数<code>-XX:-UseBiasedLocking</code>禁用偏向锁（禁用偏向锁则优先使用轻量级锁），退出synchronized状态变回001：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">biasedLockFlag (1bit): <span class="number">0</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br><span class="line">LockFlag (2bit): <span class="number">00</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">0</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br></pre></td></tr></table></figure><p> <strong>撤销偏向锁—hashcode方法</strong></p><p>测试 hashCode：当调用对象的hashcode方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存hashcode的值了。</p><ol><li><p>测试代码如下，使用虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code> ，确保最开始使用了偏向锁！但是结果显示程序使用了轻量级锁。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Test1 t = <span class="keyword">new</span> Test1();</span><br><span class="line">    t.hashCode();</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">synchronized</span> (t)&#123;</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">    &#125;</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">biasedLockFlag (1bit): <span class="number">0</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br><span class="line">LockFlag (2bit): <span class="number">00</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">0</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>撤销偏向锁—其它线程使用对象</strong></p><p>这里演示的是偏向锁撤销变成轻量级锁的过程，那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行锁竞争，使用wait和 notify来辅助实现</p><ol><li><p>设置虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code>确保程序最开始使用了偏向锁！</p></li><li><p>输出结果，最开始使用的是偏向锁，但是第二个线程尝试获取对象锁时，发现本来对象偏向的是线程一，那么偏向锁就会失效，加的就是轻量级锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    Thread.sleep(20000);</span></span><br><span class="line">                    lock.wait(<span class="number">20000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">biasedLockFlag (1bit): <span class="number">1</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">1</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">1</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">1</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br><span class="line">LockFlag (2bit): <span class="number">00</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">0</span></span><br><span class="line">LockFlag (2bit): <span class="number">01</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>撤销—调用 wait/notify</strong></p><p>会使对象的锁变成重量级锁，因为wait/notify方法只有重量级锁才支持。</p><p><strong>批量重偏向</strong></p><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向 t1 的对象仍有机会重新偏向 t2(重偏向会重置Thread ID)。</li><li>当撤销超过20次后（超过阈值），JVM 会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><p><strong>批量撤销</strong></p><p>当撤销偏向锁的阈值超过 40 以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><p><strong>小结</strong></p><p>从 JDK1.6开始，synchronized锁的实现发生了很大的变化，JVM引入了相应的优化手段来提升synchronized锁的性能，这种提升涉及到偏向锁、轻量级锁以及重量级锁，从而减少锁竞争带来的用户态与内核态之间的切换，这种锁的优化实际上是通过java对象头中的一些标志位去实现的，对于锁的访问与改变，实际上都是与java对象头息息相关。</p><p>对象实例在堆中会被划分为三个部分：对象头，实例数据与对齐填充。对象头也是由三块内容来构成：</p><ul><li>Mark Word（记录了对象，锁及垃圾回收的相关信息）</li><li>指向类的指针</li><li>数组长度</li></ul><p>Mark Word的位信息包括如下组成部分：</p><ul><li>无锁标记（hashcode、分代年龄、偏向锁标志）</li><li>偏向锁标记 （偏向线程 id）</li><li>轻量级锁标记 （锁记录）</li><li>重量级锁标记 （Monitor）</li><li>GC标记</li></ul><p>对于 synchronized 锁来说，锁的升级主要是通过 Mark Word 中的锁标记位与是否是偏向锁标记为来达成的，synchronized 关键字的对象锁都是先从偏向锁开始，随着锁竞争的不断升级，逐步演化至轻量级锁，最后变成了重量级锁。</p><ol><li><p>偏向锁：针对一个线程来说的，主要作用是优化同一个线程多次获取一个锁的情况， 当一个线程执行了一个 synchronized 方法的时候，肯定能得到对象的 monitor ，这个方法所在的对象就会在 Mark Work 处设为偏向锁标记，还会有一个字段指向拥有锁的这个线程的线程 ID 。当这个线程再次访问同一个 synchronized 方法的时候，如果按照通常的方法，这个线程还是要尝试获取这个对象的 monitor ，再执行这个 synchronized 方法。但是由于 Mark Word 的存在，当第二个线程再次来访问的时候，就会检查这个对象的 Mark Word 的偏向锁标记，再判断一下这个字段记录的线程 ID 是不是跟第二个线程的 ID 是否相同的。如果相同，就无需再获取 monitor 了，直接进入方法体中。</p></li><li><p>如果是另一个线程访问这个 synchronized 方法，那么实际情况会如何呢？：偏向锁会被取消掉。</p></li><li><p>轻量级锁：若第一个线程已经获取到了当前对象的锁，这时第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程再争抢时，会发现该对象头中的 Mark Word 已经是偏向锁，但里面储存的线程 ID 并不是自己（是第一个线程），那么它会进行 CAS(Compare and Swap)，从而获取到锁，这里面存在两种情况：</p><ul><li>获取到锁成功（一共只有两个线程）：那么它会将 Mark Word 中的线程 ID 由第一个线程变成自己(偏向锁标记位保持不表)，这样该对象依然会保持偏向锁的状态。</li><li>获取锁失败（一共不止两个线程）：则表示这时可能会有多个线程同时再尝试争抢该对象的锁，那么这是偏向锁就会进行升级，升级为轻量级锁。</li></ul></li><li><p>旋锁，若自旋失败，那么锁就会转化为重量级锁，在这种情况下，无法获取到锁的线程都会进入到 moniter(即内核态)，自旋最大的特点是避免了线程从用户态进入到内核态。</p></li></ol><h3 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h3><ul><li><p>obj.wait() 让进入 object 监视器的线程到 waitSet 等待。</p></li><li><p>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒。</p></li><li><p>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒。</p></li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210130214454663.png" alt="在这里插入图片描述" style="zoom: 67%;" /><ul><li><p>锁对象调用wait方法（obj.wait），就会使当前线程进入 WaitSet 中，变为 WAITING 状态。</p></li><li><p>处于BLOCKED和 WAITING 状态的线程都为阻塞状态，CPU 都不会分给他们时间片。但是有所区别：</p><ul><li><p>BLOCKED 状态的线程是在竞争对象时，发现 Monitor 的 Owner 已经是别的线程了，此时就会进入 EntryList 中，并处于 BLOCKED 状态。</p></li><li><p>WAITING 状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了 wait 方法而进入了 WaitSet 中，处于 WAITING 状态。</p></li><li><p>BLOCKED 状态的线程会在锁被释放的时候被唤醒，但是处于 WAITING 状态的线程只有被锁对象调用了 notify 方法(obj.notify/obj.notifyAll)，才会被唤醒。</p></li></ul></li></ul><blockquote><p>注：只有当对象加锁以后，才能调用 wait 和 notify 方法。</p></blockquote><h4 id="Wait-与-Sleep-的区别"><a href="#Wait-与-Sleep-的区别" class="headerlink" title="Wait 与 Sleep 的区别"></a>Wait 与 Sleep 的区别</h4><ul><li>Sleep 是 Thread 类的静态方法，Wait 是 Object 的方法，Object 又是所有类的父类，所以所有类都有Wait方法。</li><li>Sleep 在阻塞的时候不会释放锁，而 Wait在阻塞的时候会释放锁，它们都会释放 CPU 资源。</li><li>Sleep 不需要与 synchronized 一起使用，而 Wait 需要与 synchronized 一起使用（对象被锁以后才能使用）</li><li>使用 wait 一般需要搭配 notify 或者 notifyAll 来使用，不然会让线程一直等待。</li></ul><h4 id="优雅地使用-wait-notify"><a href="#优雅地使用-wait-notify" class="headerlink" title="优雅地使用 wait/notify"></a>优雅地使用 wait/notify</h4><p><strong>什么时候适合使用wait？</strong></p><ul><li>当线程不满足某些条件，需要暂停运行时，可以使用 wait 。这样会将对象的锁释放，让其他线程能够继续运行。如果此时使用 sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程 sleep 结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait/notify需要注意什么？</strong></p><ul><li>当有多个线程在运行时，对象调用了 wait 方法，此时这些线程都会进入 WaitSet 中等待。如果这时使用了 notify 方法，可能会造成虚假唤醒（唤醒的不是满足条件的等待线程），这时就需要使用 notifyAll 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span></span><br><span class="line">lock.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//满足条件后再运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"><span class="comment">//唤醒所有等待线程</span></span><br><span class="line">lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object room = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟吗？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，歇会&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;其他人&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            hasCigarette = <span class="keyword">true</span>;</span><br><span class="line">            log.debug(<span class="string">&quot;烟来了&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">21.111</span> [t1] DEBUG com.heu.test.TestWait - 有烟吗？[<span class="keyword">false</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">21.123</span> [t1] DEBUG com.heu.test.TestWait - 没烟，歇会</span><br><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">22.116</span> [送烟的] DEBUG com.heu.test.TestWait - 烟来了</span><br><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">23.134</span> [t1] DEBUG com.heu.test.TestWait - 有烟没？[<span class="keyword">true</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">23.134</span> [t1] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">23.134</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">23.135</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">23.135</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">23.135</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">26</span>:<span class="number">23.136</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br></pre></td></tr></table></figure><ul><li><p>其它干活的线程，都要一直阻塞，效率太低；</p></li><li><p>t1线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来；</p></li><li><p>加了 synchronized (room) 后，就好比t1线程在里面反锁了门睡觉，烟根本没法送进门，而main线程没加synchronized 就好像 main 线程是翻窗户进来的；</p></li><li><p>解决方法，使用 wait - notify 机制。</p></li></ul><p>思考下面的实现行吗，为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object room = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟吗？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，歇会&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;其他人&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasCigarette = <span class="keyword">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;烟来了&quot;</span>);</span><br><span class="line">                room.notify();</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;,<span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">01.717</span> [t1] DEBUG com.heu.test.TestWait - 有烟吗？[<span class="keyword">false</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">01.727</span> [t1] DEBUG com.heu.test.TestWait - 没烟，歇会</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">01.728</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">01.728</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">01.729</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">01.729</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">01.729</span> [其他人] DEBUG com.heu.test.TestWait - 可以干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">02.717</span> [送烟的] DEBUG com.heu.test.TestWait - 烟来了</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">02.717</span> [t1] DEBUG com.heu.test.TestWait - 有烟没？[<span class="keyword">true</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">02.717</span> [t1] DEBUG com.heu.test.TestWait - 可以干活了</span><br></pre></td></tr></table></figure><ul><li>解决了其它干活的线程阻塞的问题；</li><li>但如果有其它线程也在等待条件呢。</li></ul><p>这样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟吗？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，歇会&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>,hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没外卖，歇会&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>,hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasTakeout = <span class="keyword">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖来了&quot;</span>);</span><br><span class="line">        room.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;,<span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">44</span>:<span class="number">18.155</span> [t1] DEBUG com.heu.test.TestWait - 有烟吗？[<span class="keyword">false</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">44</span>:<span class="number">18.166</span> [t1] DEBUG com.heu.test.TestWait - 没烟，歇会</span><br><span class="line"><span class="number">19</span>:<span class="number">44</span>:<span class="number">18.167</span> [t2] DEBUG com.heu.test.TestWait - 外卖送到没？[<span class="keyword">false</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">44</span>:<span class="number">18.167</span> [t2] DEBUG com.heu.test.TestWait - 没外卖，歇会</span><br><span class="line"><span class="number">19</span>:<span class="number">44</span>:<span class="number">19.165</span> [送外卖的] DEBUG com.heu.test.TestWait - 外卖来了</span><br><span class="line"><span class="number">19</span>:<span class="number">44</span>:<span class="number">19.165</span> [t1] DEBUG com.heu.test.TestWait - 有烟没？[<span class="keyword">false</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">44</span>:<span class="number">19.166</span> [t1] DEBUG com.heu.test.TestWait - 没干成活</span><br></pre></td></tr></table></figure><ul><li><p>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】</p></li><li><p>解决方法，改为 notifyAll。</p></li></ul><p>解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasTakeout = <span class="keyword">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖来了&quot;</span>);</span><br><span class="line">        room.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;,<span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">46</span>:<span class="number">23.330</span> [t1] DEBUG com.heu.test.TestWait - 有烟吗？[<span class="keyword">false</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">46</span>:<span class="number">23.340</span> [t1] DEBUG com.heu.test.TestWait - 没烟，歇会</span><br><span class="line"><span class="number">19</span>:<span class="number">46</span>:<span class="number">23.340</span> [t2] DEBUG com.heu.test.TestWait - 外卖送到没？[<span class="keyword">false</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">46</span>:<span class="number">23.341</span> [t2] DEBUG com.heu.test.TestWait - 没外卖，歇会</span><br><span class="line"><span class="number">19</span>:<span class="number">46</span>:<span class="number">24.338</span> [送外卖的] DEBUG com.heu.test.TestWait - 外卖来了</span><br><span class="line"><span class="number">19</span>:<span class="number">46</span>:<span class="number">24.339</span> [t1] DEBUG com.heu.test.TestWait - 有烟没？[<span class="keyword">false</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">46</span>:<span class="number">24.339</span> [t1] DEBUG com.heu.test.TestWait - 没干成活</span><br><span class="line"><span class="number">19</span>:<span class="number">46</span>:<span class="number">24.339</span> [t2] DEBUG com.heu.test.TestWait - 外卖送到没？[<span class="keyword">true</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">46</span>:<span class="number">24.340</span> [t2] DEBUG com.heu.test.TestWait - 可以干活了</span><br></pre></td></tr></table></figure><ul><li><p>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了。</p></li><li><p>解决方法，用 while + wait，当条件不成立，再次 wait。</p></li></ul><p>将 if 改为 while：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> room.wait();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li><p>当调用 wait 时，首先需要确保调用了 wait 方法的线程已经持有了对象的锁(调用 wait 方法的代码片段需要放在 sychronized 块或者时 sychronized 方法中，这样才可以确保线程在调用wait方法前已经获取到了对象的锁)。</p></li><li><p>当调用 wait 时，该线程就会释放掉这个对象的锁，然后进入等待状态 (wait set)。</p></li><li><p>当线程调用了 wait 后进入到等待状态时，它就可以等待其他线程调用相同对象的 notify 或者 notifyAll 方法使得自己被唤醒。</p></li><li><p>一旦这个线程被其它线程唤醒之后，该线程就会与其它线程以同开始竞争这个对象的锁(公平竞争)；只有当该线程获取到对象的锁后，线程才会继续往下执行。</p></li><li><p>当调用对象的 notify 方法时，他会随机唤醒对象等待集合 (wait set) 中的任意一个线程，当某个线程被唤醒后，它就会与其它线程一同竞争对象的锁。</p></li><li><p>当调用对象的 notifyAll 方法时，它会唤醒该对象等待集合 (wait set) 中的所有线程，这些线程被唤醒后，又会开始竞争对象的锁。</p></li><li><p>在某一时刻，只有唯一的一个线程能拥有对象的锁。</p></li></ol><h3 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果。</p></li><li><p>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject。</p></li><li><p>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）。</p></li><li><p>JDK 中，join 、Future 的实现，采用的就是此模式。</p></li><li><p>单任务及多任务版GuardedObject如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210605200231671.png" alt="image-20210605200231671" style="zoom:80%;" /></li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210201101918200.png" alt="在这里插入图片描述"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>一个线程等待另一个线程的执行结果（带超时）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardedObjectV2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> timePassed = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> waitTime = millis - timePassed;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;break..&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                timePassed=System.currentTimeMillis()-begin;</span><br><span class="line">                log.debug(<span class="string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,</span><br><span class="line">                        timePassed, response == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            log.debug(<span class="string">&quot;notify..&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardedObjectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuardedObjectV2 v2 = <span class="keyword">new</span> GuardedObjectV2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            v2.complete(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            v2.complete(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Object response = v2.get(<span class="number">2500</span>);</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;can&#x27;t get response&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">46.262</span> [main] DEBUG com.heu.test.GuardedObjectV2 - waitTime: <span class="number">2500</span></span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">47.258</span> [Thread-<span class="number">0</span>] DEBUG com.heu.test.GuardedObjectV2 - notify..</span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">47.258</span> [main] DEBUG com.heu.test.GuardedObjectV2 - timePassed: <span class="number">1002</span>, object is <span class="keyword">null</span> <span class="keyword">true</span></span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">47.258</span> [main] DEBUG com.heu.test.GuardedObjectV2 - waitTime: <span class="number">1498</span></span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">48.272</span> [Thread-<span class="number">0</span>] DEBUG com.heu.test.GuardedObjectV2 - notify..</span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">48.272</span> [main] DEBUG com.heu.test.GuardedObjectV2 - timePassed: <span class="number">2016</span>, object is <span class="keyword">null</span> <span class="keyword">false</span></span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">48.273</span> [main] DEBUG com.heu.test.GuardedObjectTest - get response: [<span class="number">3</span>] lines</span><br></pre></td></tr></table></figure><p><strong>多任务版GuardedObject</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_23_Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> People().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer id : Mailboxes.getIds()) &#123;</span><br><span class="line">            <span class="keyword">new</span> Postman(id, <span class="string">&quot;内容 &quot;</span> + id).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = Mailboxes.createGuardedObject();</span><br><span class="line">        log.info(<span class="string">&quot;收信的为 id: &#123;&#125;&quot;</span>, guardedObject.getId());</span><br><span class="line">        Object o = guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;收到信的 id: &#123;&#125;, 内容: &#123;&#125;&quot;</span>, guardedObject.getId(), o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Postman&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Postman</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Postman</span><span class="params">(<span class="keyword">int</span> id, String mail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.mail = mail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);</span><br><span class="line">        log.info(<span class="string">&quot;送信的 id: &#123;&#125;, 内容: &#123;&#125;&quot;</span>, id, mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mailboxes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">generateId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户会进行投信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title">createGuardedObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = <span class="keyword">new</span> GuardedObject(generateId());</span><br><span class="line">        boxes.put(guardedObject.getId(), guardedObject);</span><br><span class="line">        <span class="keyword">return</span> guardedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派件员会派发信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title">getGuardedObject</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">getIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuardedObject</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化等待时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> passTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - passTime; <span class="comment">// 剩余等待时间</span></span><br><span class="line">                <span class="keyword">if</span>(waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                passTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">05.689</span> c.People [Thread-<span class="number">1</span>] - 开始收信 id:<span class="number">3</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">05.689</span> c.People [Thread-<span class="number">2</span>] - 开始收信 id:<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">05.689</span> c.People [Thread-<span class="number">0</span>] - 开始收信 id:<span class="number">2</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.Postman [Thread-<span class="number">4</span>] - 送信 id:<span class="number">2</span>, 内容:内容<span class="number">2</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.Postman [Thread-<span class="number">5</span>] - 送信 id:<span class="number">1</span>, 内容:内容<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.People [Thread-<span class="number">0</span>] - 收到信 id:<span class="number">2</span>, 内容:内容<span class="number">2</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.People [Thread-<span class="number">2</span>] - 收到信 id:<span class="number">1</span>, 内容:内容<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.Postman [Thread-<span class="number">3</span>] - 送信 id:<span class="number">3</span>, 内容:内容<span class="number">3</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.689</span> c.People [Thread-<span class="number">1</span>] - 收到信 id:<span class="number">3</span>, 内容:内容<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应。</p></li><li><p>消费队列可以用来平衡生产和消费的线程资源。</p></li><li><p>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据。</p></li><li><p>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据。</p></li><li><p>JDK 中各种阻塞队列，采用的就是这种模式。</p></li></ul><p>“异步“的意思就是生产者产生消息之后消息没有被立刻消费，而“同步模式”中，消息在产生之后被立刻消费了。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210201102116643.png" alt="在这里插入图片描述"></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestProducerConsumer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MessageQueue messageQueue = <span class="keyword">new</span> MessageQueue(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;download...&quot;</span>);</span><br><span class="line">                    List&lt;String&gt; response = Downloader.download();</span><br><span class="line">                    log.debug(<span class="string">&quot;try put message(&#123;&#125;)&quot;</span>, id);</span><br><span class="line">                    messageQueue.put(<span class="keyword">new</span> Message(id, response));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Message message = messageQueue.take();</span><br><span class="line">                List&lt;String&gt; response = (List&lt;String&gt;) message.getMessage();</span><br><span class="line">                log.debug(<span class="string">&quot;take message(&#123;&#125;): [&#123;&#125;] lines&quot;</span>, message.getId(), response.size());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> id, Object message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;没货了, wait&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Message message = queue.removeFirst();</span><br><span class="line">            queue.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;库存已达上限, wait&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(message);</span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="join原理"><a href="#join原理" class="headerlink" title="join原理"></a>join原理</h3><p>调用者轮询检查线程 alive 状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1.join();</span><br><span class="line"><span class="comment">//等价于下面的代码</span></span><br><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line"> <span class="comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span></span><br><span class="line"> <span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line"> t1.wait(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="park-amp-unpark"><a href="#park-amp-unpark" class="headerlink" title="park &amp; unpark"></a>park &amp; unpark</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>park &amp; unpark 是 LockSupport 线程通信工具类的静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPark</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                log.debug(<span class="string">&quot;resume..&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">54</span>:<span class="number">15.719</span> [t1] DEBUG com.heu.test.TestPark - start...</span><br><span class="line"><span class="number">20</span>:<span class="number">54</span>:<span class="number">16.735</span> [t1] DEBUG com.heu.test.TestPark - park...</span><br><span class="line"><span class="number">20</span>:<span class="number">54</span>:<span class="number">17.723</span> [main] DEBUG com.heu.test.TestPark - unpark...</span><br><span class="line"><span class="number">20</span>:<span class="number">54</span>:<span class="number">17.724</span> [t1] DEBUG com.heu.test.TestPark - resume..</span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>与 Object 的 wait &amp; notify 相比：</p><ul><li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必；</p></li><li><p>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】；</p></li><li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。</p></li></ul><h4 id="park-unpark原理"><a href="#park-unpark原理" class="headerlink" title="park unpark原理"></a>park unpark原理</h4><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter， _cond 和  _mutex。</p><ol><li>打个比喻，线程就像一个旅人，Parker 就像他随身携带的背包，条件变量 _ cond 就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）；</li><li>调用 park 就是要看需不需要停下来歇息：<ul><li>如果备用干粮耗尽，那么钻进帐篷歇息；</li><li>如果备用干粮充足，那么不需停留，继续前进。</li></ul></li><li>调用 unpark，就好比令干粮充足：<ul><li>如果这时线程还在帐篷，就唤醒让他继续前进；</li><li>如果这时线程还在运行，那么下次它调用 park 时，仅是消耗掉备用干粮，不需停留继续前进；</li><li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮。</li></ul></li></ol><p><strong>先调用park再调用upark的过程</strong>：</p><p>先调用 park：</p><ol><li>当前线程调用 Unsafe.park() 方法；</li><li>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁(mutex对象有个等待队列 _cond)；</li><li>线程进入 _cond 条件变量阻塞；</li><li>设置 _counter = 0。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/2021020110470197.png" alt="在这里插入图片描述" style="zoom:80%;" /><p>调用 upark：</p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1；</li><li>唤醒 _cond 条件变量中的 Thread_0；</li><li>Thread_0 恢复运行；</li><li>设置 _counter 为 0。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/2021020110480276.png" alt="在这里插入图片描述" style="zoom:80%;" /><p><strong>先调用upark再调用park的过程</strong></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1；</li><li>当前线程调用 Unsafe.park() 方法；</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行；</li><li>设置 _counter 为 0。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210201104925101.png" alt="在这里插入图片描述" style="zoom:80%;" /><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210201112936260.png" alt="在这里插入图片描述" style="zoom:67%;" /><ol><li><p><strong>NEW –&gt; RUNNABLE</strong>：当调用了 t.start() 方法时，由 NEW –&gt; RUNNABLE。</p></li><li><p><strong>RUNNABLE &lt;–&gt; WAITING</strong></p><ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后，调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING。</li><li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时，会在 WaitSet 等待队列中出现锁竞争，非公平竞争。<ul><li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li></ul></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; WAITING</strong></p><ul><li>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING，注意是当前线程在 t 线程对象的监视器上等待。</li><li>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE。</li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; WAITING</strong></p><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING。</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE。</li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p><ul><li>t 线程用 synchronized(obj) 获取了对象锁后，调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING。</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时：<ul><li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li></ul></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p></li></ol><ul><li>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING。</li><li>当前线程等待时间超过了 n 毫秒，或 t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE。</li></ul><ol start="7"><li><p><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING。</li><li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE。</li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING。</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE。</li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; BLOCKED</strong></p><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED。</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED。</li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; TERMINATED</strong></p><ul><li>当前线程所有代码运行完毕，进入 TERMINATED。</li></ul></li></ol><h3 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>线程因为某些原因，导致代码一直无法执行完毕，这种的现象叫做活跃性。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁。如：t1 线程获得 A 对象锁，接下来想获取 B 对象的锁 t2 线程获得 B 对象锁，接下来想获取 A 对象的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Object A = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">final</span> Object B = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发生死锁的必要条件</strong></p><ol><li>互斥条件：在一段时间内，一种资源只能被一个进程所使用。</li><li>请求和保持条件：进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源。</li><li>不可抢占条件：进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放。</li><li>循环等待条件：发生死锁时，必然存在一个进程——资源的循环链。</li></ol><p><strong>定位死锁的方法</strong><br>检测死锁可以使用 jconsole工具；或者使用 jps 定位进程 id，再用 jstack 根据进程 id 定位死锁。</p><p><strong>哲学家就餐问题</strong></p><p>有五位哲学家，围坐在圆桌旁。他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。如果筷子被身边的人拿着，自己就得等待。</p><p>当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情况。</p><p><strong>避免死锁的方法</strong></p><p>在线程使用锁对象时，顺序加锁即可避免死锁。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210201135641629.png" alt="在这里插入图片描述" style="zoom:80%;" /><h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁出现在两个线程互相改变对方的结束条件，谁也无法结束。</p><p><strong>避免活锁的方法</strong>：在线程执行时，中途给予不同的间隔时间即可。</p><p><strong>死锁与活锁的区别：</strong></p><ul><li><p>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时线程阻塞，停止运行的现象。</p></li><li><p>活锁是因为线程间修改了对方的结束条件，而导致代码一直在运行，却一直运行不完的现象。</p></li></ul><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>某些线程因为优先级太低，导致一直无法获得资源的现象。在使用顺序加锁时，可能会出现饥饿现象。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>相对于 synchronized 它具备如下特点：</p><ul><li><p>可中断</p></li><li><p>可以设置超时时间</p></li><li><p>可以设置为公平锁</p></li><li><p>支持多个条件变量</p></li></ul><p>与 synchronized 一样，都支持可重入。</p><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// 释放锁</span></span><br><span class="line"> reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁。</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">            method2();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">            method3();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;method3&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">49</span>:<span class="number">13.947</span> [main] DEBUG com.heu.test.TestReentrantLock - method1</span><br><span class="line"><span class="number">21</span>:<span class="number">49</span>:<span class="number">13.960</span> [main] DEBUG com.heu.test.TestReentrantLock - method2</span><br><span class="line"><span class="number">21</span>:<span class="number">49</span>:<span class="number">13.960</span> [main] DEBUG com.heu.test.TestReentrantLock - method3</span><br></pre></td></tr></table></figure><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><ul><li><p>如果某个线程处于阻塞状态，可以调用其 interrupt 方法让其停止阻塞，获得锁失败。简而言之就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行。</p></li><li><p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加锁，可打断锁</span></span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">                <span class="comment">// 被打断，返回，不再向下执行</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 打断</span></span><br><span class="line">t1.interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">02</span>:<span class="number">40.520</span> [main] c.TestInterrupt - 获得了锁</span><br><span class="line"><span class="number">18</span>:<span class="number">02</span>:<span class="number">40.524</span> [t1] c.TestInterrupt - 启动... </span><br><span class="line"><span class="number">18</span>:<span class="number">02</span>:<span class="number">41.530</span> [main] c.TestInterrupt - 执行打断</span><br><span class="line">java.lang.InterruptedException </span><br><span class="line"> at </span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr</span><br><span class="line">onizer.java:<span class="number">898</span>) </span><br><span class="line"> at </span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron</span><br><span class="line">izer.java:<span class="number">1222</span>) </span><br><span class="line"> at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>) </span><br><span class="line"> at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$<span class="number">0</span>(TestInterrupt.java:<span class="number">17</span>) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br><span class="line"><span class="number">18</span>:<span class="number">02</span>:<span class="number">41.532</span> [t1] c.TestInterrupt - 等锁的过程中被打断</span><br></pre></td></tr></table></figure><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a><strong>锁超时</strong></h4><ul><li>使用 lock.tryLock 方法会返回获取锁是否成功。如果成功则返回 true ，反之则返回 false 。</li><li>tryLock 方法可以指定等待时间，参数为：tryLock(long timeout, TimeUnit unit)，其中 timeout 为最长等待时间，TimeUnit 为时间单位。</li><li>简而言之就是：获取锁失败了、获取超时了或者被打断了，不再阻塞，直接停止运行。</li></ul><p><strong>不设置等待时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 未设置等待时间，一旦获取失败，直接返回false</span></span><br><span class="line"><span class="keyword">if</span>(!lock.tryLock()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">                <span class="comment">// 获取失败，不再向下执行，返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置等待时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 判断获取锁是否成功，最多等待1秒</span></span><br><span class="line"><span class="keyword">if</span>(!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line"><span class="comment">// 获取失败，不再向下执行，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 被打断，不再向下执行，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">// 打断等待</span></span><br><span class="line">t1.interrupt();</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认是不公平锁，需要在创建时指定为公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待。ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比：</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息。</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室,唤醒时也是按休息室来唤醒.</li></ul><p>使用要点：</p><ul><li>await 前需要获得锁。</li><li>await 执行后，会释放锁，进入 conditionObject 等待。</li><li>await 的线程被唤醒（或打断、或超时）时重新竞争 lock 锁。</li><li>竞争 lock 锁成功后，从 await 后继续执行。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition waitCigaretteQueue = lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> Condition waitbreakfastQueue = lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasCigrette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasBreakfast = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitCigaretteQueue.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;等到了它的烟&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!hasBreakfast) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitbreakfastQueue.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;等到了它的早餐&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        sendBreakfast();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        sendCigarette();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendCigarette</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;送烟来了&quot;</span>);</span><br><span class="line">            hasCigrette = <span class="keyword">true</span>;</span><br><span class="line">            waitCigaretteQueue.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sendBreakfast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;送早餐来了&quot;</span>);</span><br><span class="line">            hasBreakfast = <span class="keyword">true</span>;</span><br><span class="line">            waitbreakfastQueue.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">13</span>:<span class="number">53.349</span> [main] DEBUG com.heu.test.TestCondition - 送早餐来了</span><br><span class="line"><span class="number">22</span>:<span class="number">13</span>:<span class="number">53.359</span> [Thread-<span class="number">1</span>] DEBUG com.heu.test.TestCondition - 等到了它的早餐</span><br><span class="line"><span class="number">22</span>:<span class="number">13</span>:<span class="number">54.368</span> [main] DEBUG com.heu.test.TestCondition - 送烟来了</span><br><span class="line"><span class="number">22</span>:<span class="number">13</span>:<span class="number">54.368</span> [Thread-<span class="number">0</span>] DEBUG com.heu.test.TestCondition - 等到了它的烟</span><br></pre></td></tr></table></figure><h3 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现。</p><h4 id="Wait-Notify-实现"><a href="#Wait-Notify-实现" class="headerlink" title="Wait/Notify 实现"></a>Wait/Notify 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitAndNotify waitAndNotify = <span class="keyword">new</span> WaitAndNotify(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            waitAndNotify.run(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            waitAndNotify.run(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            waitAndNotify.run(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String str, <span class="keyword">int</span> flag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="keyword">this</span>.flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="comment">// 设置下一个运行的线程标记</span></span><br><span class="line">                <span class="keyword">this</span>.flag = nextFlag;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitAndNotify</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="park-unpary-实现"><a href="#park-unpary-实现" class="headerlink" title="park/unpary 实现"></a>park/unpary 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread t1, t2, t3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkAndUnPark obj = <span class="keyword">new</span> ParkAndUnPark(<span class="number">5</span>);</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            obj.run(<span class="string">&quot;a&quot;</span>, t2);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            obj.run(<span class="string">&quot;b&quot;</span>, t3);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            obj.run(<span class="string">&quot;c&quot;</span>, t1);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkAndUnPark</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String str, Thread nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkAndUnPark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="await-signal-实现"><a href="#await-signal-实现" class="headerlink" title="await/signal 实现"></a>await/signal 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AwaitAndSignal lock = <span class="keyword">new</span> AwaitAndSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a = lock.newCondition();</span><br><span class="line">        Condition b = lock.newCondition();</span><br><span class="line">        Condition c = lock.newCondition();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.run(<span class="string">&quot;a&quot;</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.run(<span class="string">&quot;b&quot;</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.run(<span class="string">&quot;c&quot;</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitAndSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String str, Condition current, Condition nextCondition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                nextCondition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitAndSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Monitor </tag>
            
            <tag> synchronized </tag>
            
            <tag> wait/notify </tag>
            
            <tag> park/unpark </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发—线程基础、方法</title>
      <link href="2021/05/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h3><p><strong>进程</strong></p><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><p><strong>线程</strong></p><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。</li></ul><p><strong>两者对比</strong></p><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享。</li><li>进程间通信较为复杂，同一台计算机的进程通信称为 IPC（Inter-process communication），不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP。</li><li>线程通信相对简单，因为它们共享进程内的内存，多个线程可以访问同一个共享变量。</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。</li></ul><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p><strong>并发</strong></p><p>单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感、觉是同时运行的 。总结为一句话就是： 微观串行，宏观并行 。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20200305194534-433138.png" alt="img" style="zoom:150%;" /><p><strong>并行</strong></p><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的 cpu 在执行。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20200305194655-483025.png" alt="img" style="zoom:150%;" /><p> <strong>二者对比</strong></p><p>引用 Rob Pike 的一段描述：并发（concurrent）是同一时间应对（dealing with）多件事情的能力，并行（parallel）是同一时间动手做（doing）多件事情的能力。</p><ul><li><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</p></li><li><p>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p></li><li><p>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一 个人用锅时，另一个人就得等待）</p></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>同步和异步的概念</strong></p><p>以调用方的角度讲，如果需要等待结果返回才能继续运行的话就是同步，不需要等待就是异步。</p><p>1）设计</p><p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，那么 cpu 只能等 5 秒，啥都不能做。</p><ol start="2"><li>结论</li></ol><ul><li><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程。</p></li><li><p>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</p></li><li><p>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活。</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的。</li></ol><ul><li><p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率，但不是所有计算任 务都能拆分。</p></li><li><p>而也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义。</p></li></ul><ol start="3"><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：以后的代码示例均在添加 @Slf4j 依赖的情况下执行</span><br></pre></td></tr></table></figure><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><p><strong>方法一，直接使用 Thread</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类方式创建 Thread</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        t.start();</span><br><span class="line">        log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>方法二，使用 Runnable 配合 Thread</strong>（推荐）</p><p>把【线程】和【任务】（要执行的代码）分开，Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 lambda 表达式，因为 Runnable 接口 </span></span><br><span class="line">        <span class="comment">// 标注了 @FunctionalInterface 这个注解，表示是一个函数式接口，可以使用 lambda 表达式</span></span><br><span class="line">        Runnable r = () -&gt; log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了。</li><li>用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。</li><li>通过查看源码可以发现，方法二其实到底还是通过方法一执行的！</li></ul><p> <strong>方法三，FutureTask 配合 Thread</strong></p><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况 ，FutureTask是Future和Runable的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 实现多线程的第三种方法可以返回数据</span></span><br><span class="line">    FutureTask futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;多线程任务&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;我的名字&quot;</span>).start();</span><br><span class="line">    log.debug(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future 就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future提供了三种功能： 　　</p><ol><li><p>判断任务是否完成； 　　</p></li><li><p>能够中断任务； 　　</p></li><li><p>能够获取任务执行结果。</p></li></ol><p><strong>多个线程同时执行</strong></p><ul><li>交替执行</li><li>谁先谁后，不由我们控制  </li></ul><p><strong>查看进程线程的方法</strong>  </p><p><strong>windows</strong></p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程。</li><li>tasklist 查看进程。</li><li>taskkill 杀死进程。</li></ul><p><strong>linux</strong></p><ul><li>ps -fe 查看所有进程。</li><li>ps -fT -p <PID> 查看某个进程（PID）的所有线程。</li><li>kill 杀死进程。</li><li>top 按大写 H 切换是否显示线程。</li><li>top -H -p <PID> 查看某个进程（PID）的所有线程。</li></ul><p><strong>java</strong></p><ul><li>jps 命令查看所有 java 进程。</li><li>jstack <PID> 查看某个 java 进程（PID）的所有线程状态。</li><li>jconsole 来查看某个 java 进程中线程的运行情况（图形界面）。</li></ul><h3 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h3><p><strong>虚拟机栈与栈帧</strong></p><p>虚拟机栈描述的是 java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程私有的。</p><ul><li>当 java 中使用多线程时，每个线程都会维护它自己的栈帧。</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ul><p><strong>线程上下文切换（Thread Context Switch）</strong></p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码：</p><ul><li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)。</li><li>垃圾回收。</li><li>有更高优先级的线程需要运行。</li><li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法。</li></ul><p>当 上下文切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。</p><h3 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h3><h4 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start 与 run"></a>start 与 run</h4><p><strong>调用 start</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(Thread.currentThread().getName() + <span class="string">&quot; running....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试通过 Thread 类实例 t1 对象直接调用 run 方法</span></span><br><span class="line">        t1.run();</span><br><span class="line"></span><br><span class="line">        log.info(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">56</span> [main] c.Code_05_Test - main running....</span><br><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">56</span> [main] c.Code_05_Test - main running...</span><br></pre></td></tr></table></figure><p><strong>调用 run</strong></p><p>将上面代码的<code>thread.start();</code>改为 <code>thread.run();</code>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">59</span>:<span class="number">35</span> [main] c.Code_05_Test - main running...</span><br><span class="line"><span class="number">14</span>:<span class="number">59</span>:<span class="number">35</span> [t1] c.Code_05_Test - t1 running....</span><br></pre></td></tr></table></figure><blockquote><p>通过打印台的输出，发现结果是不一样的，使用 start 方式，CPU 会为创建的线程分配时间片，线程进入运行状态，然后线程调用 run 方法执行逻辑。而直接使用 run 的方式，虽然会创建了线程，但是它是直接调用方法，而不是像 start 方式那样，这个线程对象会处一直处在新建状态，从结果上也可以看出，run 方法是 main 线程调用，而不是 t1 线程。</p></blockquote><p><strong>小结</strong></p><ul><li>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程。</li><li>使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码。</li></ul><h4 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h4><p><strong>sleep</strong></p><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）。</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】。</li><li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)。</li><li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性。</li></ol><p><strong>yield（礼让）</strong></p><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程。</li><li>具体的实现依赖于操作系统的任务调度器。</li></ol><p><strong>小结</strong></p><p>yield 使 cpu 调用其它线程，但是 cpu 可能会再分配时间片给该线程；而 sleep 需要等过了休眠时间之后才有可能被分配 cpu 时间片。</p><p><strong>线程优先级</strong></p><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它。</li><li> 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用。</li></ul><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>join用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。如在主线程中调用t1.join()，则是主线程需要等待t1线程结束，才能执行其线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line"><span class="comment">//等待 t1 线程执行结束</span></span><br><span class="line">t1.join();</span><br><span class="line"><span class="comment">// 最多等待 1000ms,如果 1000ms 内线程执行完毕，则会直接执行下面的语句，不会等够 1000ms</span></span><br><span class="line">t1.join(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><strong>为什么需要join？</strong></p><p>下面的代码执行，打印 r 是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> test1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"> Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"> r = <span class="number">10</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"> t1.start();</span><br><span class="line"> log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line"> log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li><p>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10。</p></li><li><p>而主线程一开始就要打印 r 的结果，所以只能打印出 r=0。</p></li></ul><p>解决方法：要想打印出r=10，用 join加在 t1.start() 之后即可。</p><p>注意：</p><ul><li><p>需要等待结果返回，才能继续运行就是同步。</p></li><li><p>不需要等待结果返回，就能继续运行就是异步。</p></li></ul><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><p>interrupt 打断线程有两种情况，如下：</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为 true 。</li><li>如果是打断的是因sleep、wait、join 方法而被阻塞的线程，会将打断标记置为 false 。</li></ul><p><strong>isInterrupted() 与 interrupted() 比较</strong></p><p>首先，isInterrupted 是实例方法，interrupted 是静态方法，它们的用处都是查看当前打断的状态，但是 isInterrupted 方法查看线程的时候，不会将打断标记清空，也就是置为 false，interrupted 查看线程打断状态后，会将打断标志置为 false，也就是清空打断标记。</p><p>以 sleep 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> t1.start();</span><br><span class="line"> </span><br><span class="line"> sleep(<span class="number">0.5</span>);<span class="comment">//t2睡眠0.5s</span></span><br><span class="line"> t1.interrupt();</span><br><span class="line"> log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native Method)</span><br><span class="line"> at java.lang.Thread.sleep(Thread.java:<span class="number">340</span>)</span><br><span class="line"> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line"> at cn.heu.n2.util.Sleeper.sleep(Sleeper.java:<span class="number">8</span>)</span><br><span class="line"> at cn.heu.n4.TestInterrupt.lambda$test1$<span class="number">3</span>(TestInterrupt.java:<span class="number">59</span>)</span><br><span class="line">     at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">18</span>:<span class="number">10.374</span> [main] TestInterrupt - 打断状态: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>打断正常运行的线程, 不会清空打断状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"> Thread current = Thread.currentThread();</span><br><span class="line"> <span class="keyword">boolean</span> interrupted = current.isInterrupted();</span><br><span class="line"> <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line"> log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  t2.start();</span><br><span class="line">  sleep(<span class="number">0.5</span>);<span class="comment">//t2睡眠0.5s</span></span><br><span class="line">  t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">57</span>:<span class="number">37.964</span> [t2] TestInterrupt - 打断状态: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><blockquote><p>注：打断 park 线程, 不会清空打断状态。而如果打断标记已经是 true, 则 park 会失效。</p><p>​        可以使用 Thread.interrupted() 清除打断状态。</p></blockquote><h4 id="模式之两阶段终止"><a href="#模式之两阶段终止" class="headerlink" title="模式之两阶段终止"></a>模式之两阶段终止</h4><p>Two Phase Termination，就是考虑在一个线程T1中如何优雅地终止另一个线程T2，这里的优雅指的是给T2一个料理后事的机会（如释放锁）。</p><p>如下所示：线程的<code>isInterrupted()</code>方法可以取得线程的打断标记，如果线程在睡眠<code>sleep</code>期间被打断，打断标记是不会变的，为false，但是<code>sleep</code>期间被打断会抛出异常，我们据此手动设置打断标记为<code>true</code>；如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为<code>true</code>。处理好这两种情况那我们就可以放心地来料理后事啦！</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210603153151665.png" alt="image-20210603153151665" style="zoom: 33%;" /><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TwoParseTermination twoParseTermination = <span class="keyword">new</span> TwoParseTermination();</span><br><span class="line">        twoParseTermination.start();</span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        twoParseTermination.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoParseTermination</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread thread = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(thread.isInterrupted()) &#123; <span class="comment">// 调用 isInterrupted 不会清除标记</span></span><br><span class="line">                    log.info(<span class="string">&quot;料理后事 ...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        log.info(<span class="string">&quot;执行监控的功能 ...&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;设置打断标记 ...&quot;</span>);</span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h4><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁。</p><ol><li>stop：停止线程运行。</li><li>suspend() ：挂起（暂停）线程运行。</li><li>resume()：恢复线程运行。</li></ol><h3 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h3><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守</p><p>护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><p><strong>注意</strong></p><ul><li><p>垃圾回收器线程就是一种守护线程</p></li><li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求。</p></li></ul><h3 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h3><p>五种状态的划分主要是从操作系统的层面进行划分的：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20200307093417-638644.png" alt="1583507073055" style="zoom:120%;" /><ul><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联。</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行。</p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态。</p><ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换。</li></ul></li><li><p>【阻塞状态】</p><ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】；</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】。</li><li>与【可运行状态】的区别是：对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们。</li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态。</p></li></ul><h3 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的，根据 Thread.State 枚举，分为六种状态：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210630120605408.png" alt="image-20210630120605408" style="zoom:50%;" /><ul><li><p>【NEW】： 线程刚被创建，但是还没有调用 start() 方法。</p></li><li><p>【RUNNABLE】： 当调用了 start() 方法之后，注意，<strong>Java API</strong> 层面的 RUNNABLE 状态涵盖了 <strong>操作系统</strong> 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）。</p></li><li><p>【BLOCKED】 ， 【WAITING】 ， 【TIMED_WAITING】 都是 <strong>Java API</strong> 层面对【阻塞状态】的细分，后面会在状态转换一节</p></li></ul><p>详述。</p><ul><li>【TERMINATED】 当线程代码运行结束。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题</title>
      <link href="2021/05/15/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/05/15/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="说说什么是Redis"><a href="#说说什么是Redis" class="headerlink" title="说说什么是Redis?"></a>说说什么是Redis?</h2><blockquote><p>Redis 是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，HyperLogLogs 等数据类型。内置复制、Lua 脚本、LRU 收回、事务，以及不同级别磁盘持久化功能，同时通过 Redis Sentinel 提供高可用，通过 Redis Cluster 提供自动分区。根据月度排行网站 DB-Engines的数据，Redis 是最流行的键值对存储数据库。</p></blockquote><p>Redis 全称为：Remote Dictionary Server（远程数据服务），是一个基于内存且支持持久化的高性能 key-value 数据库。具备以下三个基本特征：</p><ul><li>多数据类型</li><li>持久化机制</li><li>主从同步</li></ul><h2 id="Redis-有什么优点和缺点？"><a href="#Redis-有什么优点和缺点？" class="headerlink" title="Redis 有什么优点和缺点？"></a>Redis 有什么优点和缺点？</h2><h4 id="Redis-优点"><a href="#Redis-优点" class="headerlink" title="Redis 优点"></a>Redis 优点</h4><ul><li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li><li>支持数据持久化，支持AOF和RDB两种持久化方式。</li><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li><li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><h4 id="Redis-缺点"><a href="#Redis-缺点" class="headerlink" title="Redis 缺点"></a>Redis 缺点</h4><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h2 id="Redis-的数据类型有哪些？"><a href="#Redis-的数据类型有哪些？" class="headerlink" title="Redis 的数据类型有哪些？"></a>Redis 的数据类型有哪些？</h2><p>Redis 主要有以下几种数据类型：</p><ul><li>String：这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。</li><li>Hash：这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 hash 里的某个字段。</li><li>List：List 是有序列表，这个可以玩儿出很多花样。比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</li><li>Sets：是无序集合，自动去重。直接基于 set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 jvm 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 Redis 进行全局的 set 去重。</li><li>Sorted Set：排序的 set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。可以用来做排行榜相关功能。</li></ul><blockquote><p>一般文章都是以Redis只有 5 种数据类型，还有 Bitmaps、HyperLogLogs、Streams 等。</p></blockquote><p>中文官网上的解释：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/pC6q3OmkGYicFoCaMKezKyWtc6obBrqErbQRA65ufcxBheEB2B0opmOib7YxWvqu8PM4C8d8FsRzxvdKTldt2XHw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="Redis-是单线程的吗？"><a href="#Redis-是单线程的吗？" class="headerlink" title="Redis 是单线程的吗？"></a>Redis 是单线程的吗？</h2><p>这里的单线程指的是 Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><h2 id="Redis-为什么设计成单线程的？"><a href="#Redis-为什么设计成单线程的？" class="headerlink" title="Redis 为什么设计成单线程的？"></a>Redis 为什么设计成单线程的？</h2><ol><li>绝大部分请求是纯粹的内存操作（非常快速）</li><li>采用单线程，避免了不必要的上下文切换和竞争条件</li><li>非阻塞 IO，内部采用 epoll，epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，避免 IO 代价。</li></ol><h2 id="Redis-和-Memcached-的区别有哪些？"><a href="#Redis-和-Memcached-的区别有哪些？" class="headerlink" title="Redis 和 Memcached 的区别有哪些？"></a>Redis 和 Memcached 的区别有哪些？</h2><p>从以下8个方面来讲：</p><ul><li>Redis 和 Memcache 都是将数据存放在内存中，都是内存数据库。不过 Memcache 还可用于缓存其他东西，例如图片、视频等等。</li><li>Memcache 仅支持key-value结构的数据类型，Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，hash等数据结构的存储。</li><li>虚拟内存– Redis 当物理内存用完时，可以将一些很久没用到的value交换到磁盘；分布式–设定 Memcache 集群，利用 magent 做一主多从; Redis 可以做一主多从。都可以一主一从</li><li>存储数据安全– Memcache 挂掉后，数据没了；Redis 可以定期保存到磁盘（持久化）</li><li>Memcache 的单个value最大 1m ， Redis 的单个value最大 512m 。</li><li>灾难恢复– Memcache 挂掉后，数据不可恢复;  Redis 数据丢失后可以通过 aof 恢复</li><li>Redis 原生就支持集群模式， Redis3.0 版本中，官方便能支持Cluster模式了， Memcached 没有原生的集群模式，需要依赖客户端来实现，然后往集群中分片写入数据。</li><li>Memcached 网络IO模型是多线程，非阻塞IO复用的网络模型，原型上接近于 nignx 。而 Redis使用单线程的IO复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现类epoll，kqueue 和 select ，更接近于Apache早期的模式。</li></ul><h2 id="请说说-Redis-的线程模型？"><a href="#请说说-Redis-的线程模型？" class="headerlink" title="请说说 Redis 的线程模型？"></a>请说说 Redis 的线程模型？</h2><blockquote><p>这问题是因为前面回答问题的时候提到了 Redis 是基于非阻塞的IO复用模型。如果这个问题回答不上来，就相当于前面的回答是给自己挖坑，因为你答不上来，面试官对你的印象可能就要打点折扣了。</p></blockquote><p>Redis 内部使用文件事件处理器  file event handler ，这个文件事件处理器是单线程的，所以Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket ，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ol><li>多个 socket 。</li><li>IO 多路复用程序。</li><li>文件事件分派器。</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。</li></ol><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p>来看客户端与 Redis 的一次通信过程：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/pC6q3OmkGYicFoCaMKezKyWtc6obBrqErowgwY0QUWK30wmgm2HgEuRplfQWaj0P4ltLqk3V3r6fto7n2icFy39g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>下面来大致说一下这个图：</p><ol><li>客户端 Socket01 向  Redis 的 Server Socket 请求建立连接，此时 Server Socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列 中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个 能与客户端通信的  Socket01，并将该 Socket01 的 AE_READABLE 事件与命令请求处理器关 联。</li><li>假设此时客户端发送了一个 set key value 请求，此时  Redis 中的  Socket01 会产生 AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事 件，由于前面  Socket01 的  AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器 将事件交给命令请求处理器来处理。命令请求处理器读取  Socket01 的 set key value 并在自己 内存中完成 set key value 的设置。操作完成后，它会将  Socket01 的 AE_WRITABLE 事件与令 回复处理器关联。</li><li>如果此时客户端准备好接收返回结果了，那么 Redis 中的  Socket01 会产生一个AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对  Socket01 输入本次操作的一个结果，比如  ok ，之后解除  Socket01 的AE_WRITABLE 事件与命令回复处理器的关联。</li></ol><p>这样便完成了一次通信。不要怕这段文字，结合图看，一遍不行两遍，实在不行可以网上查点资料 结合着看，一定要搞清楚，否则前面吹的牛逼就白费了。</p><h2 id="为什么-Redis-单线程模型也能效率这么高？"><a href="#为什么-Redis-单线程模型也能效率这么高？" class="headerlink" title="为什么 Redis 单线程模型也能效率这么高？"></a>为什么 Redis 单线程模型也能效率这么高？</h2><p>可以从下面5个方面来回答：</p><ol><li>C语言实现，效率高</li><li>纯内存操作</li><li>基于非阻塞的IO复用模型机制</li><li>单线程的话就能避免多线程的频繁上下文切换问题</li><li>丰富的数据结构（全称采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如亚索表，跳表等）</li></ol><h2 id="Redis-是单线程的，如何提高多核-CPU-的利用率？"><a href="#Redis-是单线程的，如何提高多核-CPU-的利用率？" class="headerlink" title="Redis 是单线程的，如何提高多核 CPU 的利用率？"></a>Redis 是单线程的，如何提高多核 CPU 的利用率？</h2><p>CPU不太可能是Redis的瓶颈，一般内存和网络才有可能是。例如使用Redis的管道（pipelining）在liunx系统上运行可以达到500K的RPS(requests per second) ，因此，如果您的应用程序主要使用O(N) 或者O(log(N)) 的 命令，他们几乎不需要使用什么CPU。</p><p>然而，为了最大限度的使用CPU，可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，所以，如果你想使用多个CPU，你可以考虑一下分片（shard） 。</p><p>在Redis的客户端类库里面，比如RB（Ruby的客户端）和Predis（最常用的PHP客户端之一），能够使用一致性哈希（consistent hashing）来处理多个Redis实例。</p><h2 id="Redis-的同步机制了解是什么？"><a href="#Redis-的同步机制了解是什么？" class="headerlink" title="Redis 的同步机制了解是什么？"></a>Redis 的同步机制了解是什么？</h2><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。</p><p>加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h2 id="什么是-Redis-Pipelining-？"><a href="#什么是-Redis-Pipelining-？" class="headerlink" title="什么是 Redis Pipelining ？"></a>什么是 Redis Pipelining ？</h2><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p><p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。</p><p>同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p><h2 id="Redis-有几种持久化方式？"><a href="#Redis-有几种持久化方式？" class="headerlink" title="Redis 有几种持久化方式？"></a>Redis 有几种持久化方式？</h2><p>面试的时候，如果不能完整回答出来，也不会有大问题。重点，在于有条理，对 RDB 和 AOF 有理解。</p><p>Redis 提供了两种方式，实现数据的持久化到硬盘。</p><ol><li><p>【全量】RDB 持久化，是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p></li><li><p>【增量】AOF持久化，以日志的形式记录服务器所处理的每一个<strong>写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p></li></ol><h2 id="说说RDB的优缺点"><a href="#说说RDB的优缺点" class="headerlink" title="说说RDB的优缺点"></a>说说RDB的优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>灵活设置备份频率和周期。你可能打算每个小时归档一次最近 24 小时的数据，同时还要每天归档一次最近 30 天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>非常适合冷备份，对于灾难恢复而言，RDB 是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。推荐，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 OSS 分布式存储上。</li><li>性能最大化。对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是 fork 出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了。也就是说，RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis 保持高性能。</li><li>恢复更快。相比于 AOF 机制，RDB 的恢复速度更更快，更适合恢复数据，特别是在数据集非常大的情况。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p><blockquote><p>所以，RDB 实际场景下，需要和 AOF 一起使用。</p></blockquote></li><li><p>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。</p><blockquote><p>所以，RDB 建议在业务低估，例如在半夜执行。</p></blockquote></li></ul><h2 id="说说AOF的-优缺点"><a href="#说说AOF的-优缺点" class="headerlink" title="说说AOF的 优缺点"></a>说说AOF的 优缺点</h2><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li><p>该机制可以带来更高的数据安全性</p><p>即数据持久性。Redis 中提供了 3 种同步策略，即每秒同步、每修改(执行一个命令)同步和不同步。</p></li></ol><ul><li>事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。</li><li>而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。</li><li>至于不同步，无需多言，我想大家都能正确的理解它。</li></ul><ol start="2"><li>由于该机制对日志文件的写入操作采用的是 append 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。</li></ol><ul><li>因为以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。</li><li>另外，如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 redis-check-aof 工具来帮助我们解决数据一致性的问题。</li></ul><ol start="3"><li><p>如果 AOF 日志过大，Redis 可以自动启用 <strong>rewrite</strong> 机制。即使出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</p></li><li><p>AOF 包含一个格式清晰、易于理解的日志文件用于记录所有的<strong>修改操作</strong>。事实上，我们也可以通过该文件完成数据的重建。</p></li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p></li><li><p>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB 。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。</p></li><li><p>以前 AOF 发生过 bug ，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志/merge/回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug 。不过 AOF 就是为了避免 rewrite 过程导致的 bug ，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</p></li></ol><h2 id="两种持久化方式该如何选择？"><a href="#两种持久化方式该如何选择？" class="headerlink" title="两种持久化方式该如何选择？"></a>两种持久化方式该如何选择？</h2><p>bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</p><p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p><p>有很多用户都只使用AOF持久化，但并不推荐这种方式：因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外， 使用RDB还可以避免之前提到的AOF程序的问题。</p><h2 id="面试官追问那如果突然机器掉电会怎样？"><a href="#面试官追问那如果突然机器掉电会怎样？" class="headerlink" title="面试官追问那如果突然机器掉电会怎样？"></a>面试官追问那如果突然机器掉电会怎样？</h2><p>取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1 次，这个时候最多就会丢失 1 秒的数据。实际上，极端情况下，是最多丢失 2 秒的数据。因为 AOF 线程，负责每秒执行一次 fsync 操作，操作完成后，记录最后同步时间。主线程，负责对比上次同步时间，如果超过 2 秒，阻塞等待成功。</p><h2 id="面试官追问-bgsave-的原理是什么？"><a href="#面试官追问-bgsave-的原理是什么？" class="headerlink" title="面试官追问 bgsave 的原理是什么？"></a>面试官追问 bgsave 的原理是什么？</h2><p>fork 和 cow 。fork 是指 Redis 通过创建子进程来进行 bgsave 操作。cow 指的是 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。这里 bgsave 操作后，会产生 RDB 快照文件。</p><h2 id="Redis-有几种数据“过期”策略？"><a href="#Redis-有几种数据“过期”策略？" class="headerlink" title="Redis 有几种数据“过期”策略？"></a>Redis 有几种数据“过期”策略？</h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p><p>Redis 提供了 3 种数据过期策略：</p><ul><li>被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。</li><li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。</li><li>主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略。</li></ul><p>在 Redis 中，同时使用了上述 3 种策略，即它们非互斥的。</p><h2 id="Redis-有哪几种数据“淘汰”策略？"><a href="#Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="Redis 有哪几种数据“淘汰”策略？"></a>Redis 有哪几种数据“淘汰”策略？</h2><p>Redis一共有六种数据淘汰策略：</p><p>1.noeviction:返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。</p><p>2.allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p><p>3.volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p><p>4.allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p><p>5.volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p><p>6.volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p><h2 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h2><p>512M</p><h2 id="熟悉Redis的哪些客户端？"><a href="#熟悉Redis的哪些客户端？" class="headerlink" title="熟悉Redis的哪些客户端？"></a>熟悉Redis的哪些客户端？</h2><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>是我们最熟悉和最常用的客户端。轻量，简洁，便于集成和改造。</p><p>Jedis 多个线程使用一个连接的时候线程不安全。可以使用连接池，为每个请求创建不同的连接，基于 Apache common pool 实现。跟数据库一样，可以设置最大连接数等参数。Jedis 中有多种连接池的子类</p><p>Jedis 有 4 种工作模式：单节点、分片、哨兵、集群。</p><p>3 种请求模式：Client、Pipeline、事务。Client 模式就是客户端发送一个命令，阻塞等待服务端执行，然后读取 返回结果。Pipeline 模式是一次性发送多个命令，最后一次取回所有的返回结果，这种模式通过减少网络的往返时间和 io 读写次数，大幅度提高通信性能。第三种是事务模式。Transaction 模式即开启 Redis 的事务管理，事务模式开启后，所有的命令（除了 exec，discard，multi 和 watch）到达服务端以后不会立即执行，会进入一个等待队列。</p><h3 id="Luttece"><a href="#Luttece" class="headerlink" title="Luttece"></a>Luttece</h3><p>与 Jedis 相比，Lettuce 则完全克服了其线程不安全的缺点：Lettuce 是一个可伸缩的线程安全的 Redis 客户端，支持同步、异步和响应式模式（Reactive）。多个线程可以共享一个连接实例，而不必担心多线程并发问题。</p><p>同步调用：异步的结果使用 RedisFuture 包装，提供了大量回调的方法。</p><p>异步调用：它基于 Netty 框架构建，支持 Redis 的高级功能，如 Pipeline、发布订阅，事务、Sentinel，集群，支持连接池。Lettuce 是 Spring Boot 2.x 默认的客户端，替换了 Jedis。集成之后我们不需要单独使用它，直接调用 Spring 的 RedisTemplate 操作，连接和创建和关闭也不需要我们操心。</p><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid），提供了分布式和可扩展的 Java 数据结构。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>基于 Netty 实现，采用非阻塞 IO，性能高</li><li>支持异步请求</li><li>支持连接池、pipeline、LUA Scripting、Redis Sentinel、Redis Cluster 不支持事务，官方建议以 LUA Scripting 代替事务</li><li>主从、哨兵、集群都支持。Spring 也可以配置和注入 RedissonClient。</li></ol><h4 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h4><p>在 Redisson 里面提供了更加简单的分布式锁的实现。</p><h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>可以一次性执行多条命令，本质上是一组命令的集合。一个事务中的所有命令都会序列化，然后按顺序地串行化执行，而不会被插入其他命令 。</p><p>Redis的事务相关命令有：</p><p>（1）DISCARD：取消事务，放弃执行事务块中的所有命令</p><p>（2）EXEC：执行事务块中的命令</p><p>（3）MULTI：标记一个事务的开始</p><p>（4）UNWATCH：取消WATCH命令对所有 key 的监视</p><p>（5）WATCH key [key…]：监视一个（或多个）key，如果在事务之前执行这个（或者这些）key被其他命令所改动，那么事务将会被打断。</p><h2 id="Redis-事务的注意点有哪些？"><a href="#Redis-事务的注意点有哪些？" class="headerlink" title="Redis 事务的注意点有哪些？"></a>Redis 事务的注意点有哪些？</h2><ol><li>不支持回滚，如果事务中有错误的操作，无法回滚到处理前的状态，需要开发者处理。</li><li>在执行完当前事务内所有指令前，不会同时执行其他客户端的请求。</li></ol><h2 id="为什么Redis-事务不支持回滚？"><a href="#为什么Redis-事务不支持回滚？" class="headerlink" title="为什么Redis 事务不支持回滚？"></a>为什么Redis 事务不支持回滚？</h2><p>Redis 事务不支持回滚，如果遇到问题，会继续执行余下的命令。这一点和关系型数据库不太一致。这样处理的原因有：</p><ol><li>只有语法错误，Redis才会执行失败，例如错误类型的赋值， 这就是说从程序层面完全可以捕获以及解决这些问题</li><li>支持回滚需要增加很多工作，不支持的情况下，Redis 可以保持简单、速度快的特性</li></ol><h2 id="Redis有哪些使用场景？"><a href="#Redis有哪些使用场景？" class="headerlink" title="Redis有哪些使用场景？"></a>Redis有哪些使用场景？</h2><p>常见Redis的使用场景如下：</p><h4 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h4><p>Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p><h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。</p><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。</p><h4 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h4><p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>分布式锁实现方案，常见有三种：数据库，Redis、zookeepr。Redis就是其中之一。</p><p>如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p><h4 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h4><p>点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。</p><h4 id="最新列表"><a href="#最新列表" class="headerlink" title="最新列表"></a>最新列表</h4><p>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p><h4 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h4><p>消息队列主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统 。但Redis不是一个专业的消息队列。建议使用其他消息队列：Kafka、RocketMQ、RabbitMQ等。</p><h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p>使用redis实现分布式锁的思路：</p><p>1、setnx(String key,String value)</p><p>若返回1，说明设置成功，获取到锁；</p><p>若返回0，说明设置失败，已经有了这个key，说明其它线程持有锁，重试。</p><p>2、expire(String key, int seconds)</p><p>获取到锁（返回1）后，还需要用设置生存期，如果在多少秒内没有完成，比如发生机器故障、网络故障等，键值对过期，释放锁，实现高可用。</p><p>3、del(String key)</p><p>完成业务后需要释放锁。释放锁有2种方式：del删除key，或者expire将有效期设置为0（马上过期）。</p><p>在执行业务过程中，如果发生异常，不能继续往下执行，也应该马上释放锁。</p><p>如果你的项目中Redis是多机部署的，那么可以尝试使用Redisson实现分布式锁，这是Redis官方提供的Java组件。</p><h2 id="分布式锁的实现条件？"><a href="#分布式锁的实现条件？" class="headerlink" title="分布式锁的实现条件？"></a>分布式锁的实现条件？</h2><ol><li><p>互斥性，和单体应用一样，要保证任意时刻，只能有一个客户端持有锁</p></li><li><p>可靠性，要保证系统的稳定性，不能产生死锁</p></li><li><p>一致性，要保证锁只能由加锁人解锁，不能产生A的加锁被B用户解锁的情况</p></li></ol><h2 id="Redis和Zookeeper实现的分布式锁有什么区别？"><a href="#Redis和Zookeeper实现的分布式锁有什么区别？" class="headerlink" title="Redis和Zookeeper实现的分布式锁有什么区别？"></a>Redis和Zookeeper实现的分布式锁有什么区别？</h2><p>实现方式的不同，Redis 实现为去插入一条占位数据，而 ZK 实现为去注册一个临时节点。</p><p>遇到宕机情况时，Redis 需要等到过期时间到了后自动释放锁，而 ZK 因为是临时节点，在宕机时候已经是删除了节点去释放锁。</p><p>Redis 在没抢占到锁的情况下一般会去自旋获取锁，比较浪费性能，而 ZK 是通过注册监听器的方式获取锁，性能而言优于 Redis。</p><p>没有谁是最好的。</p><p>对于性能要求很高的建议使用Redis来实现，否则，建议使用Zookeeper来实现。</p><h2 id="如何使用-Redis-实现分布式限流？"><a href="#如何使用-Redis-实现分布式限流？" class="headerlink" title="如何使用 Redis 实现分布式限流？"></a>如何使用 Redis 实现分布式限流？</h2><p>限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务。</p><p>Redis限流的实现方式有3种，分别是：</p><ol><li><p>基于Redis的setnx的操作，给指定的key设置了过期实践；</p></li><li><p>基于Redis的数据结构zset，将请求打造成一个zset数组；</p></li><li><p>基于Redis的令牌桶算法，输出速率大于输入速率，就要限流。</p></li></ol><h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用rpush/lpush操作入队列，使用lpop 和 rpop来出队列。rpush 和 lpop 结合 或者lpush 和rpop 结合。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210715102100864.png" alt="image-20210715102100864" style="zoom:50%;" /><p>客户端是通过队列的 pop 操作来获取消息，然后进行处理。处理完了再接着获取消息，再进行处理。如此循环往复，这便是作为队列消费者的客户端的生命周期。</p><h2 id="Redis-高可用方案有哪些？"><a href="#Redis-高可用方案有哪些？" class="headerlink" title="Redis 高可用方案有哪些？"></a>Redis 高可用方案有哪些？</h2><h4 id="Redis-单副本"><a href="#Redis-单副本" class="headerlink" title="Redis 单副本"></a>Redis 单副本</h4><p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p><h4 id="Redis-多副本（主从）"><a href="#Redis-多副本（主从）" class="headerlink" title="Redis 多副本（主从）"></a>Redis 多副本（主从）</h4><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。</p><h4 id="Redis-Sentinel（哨兵）"><a href="#Redis-Sentinel（哨兵）" class="headerlink" title="Redis Sentinel（哨兵）"></a>Redis Sentinel（哨兵）</h4><p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。</p><p>其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n&gt;=1）的奇数个。</p><h4 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h4><p>Redis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p><p>Redis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p><h4 id="Redis-自研"><a href="#Redis-自研" class="headerlink" title="Redis 自研"></a>Redis 自研</h4><p>Redis 自研的高可用解决方案，主要体现在配置中心、故障探测和 failover 的处理机制上，通常需要根据企业业务的实际线上环境来定制化。</p><h2 id="什么是-Redis-主从同步？"><a href="#什么是-Redis-主从同步？" class="headerlink" title="什么是 Redis 主从同步？"></a>什么是 Redis 主从同步？</h2><p>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</p><ul><li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li><li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li><li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ul><p><strong>好处</strong></p><p>通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p><blockquote><p>实际上，我们不是非常推荐在 Redis 中，使用读写分离。主要有两个原因：</p><ul><li>Redis Sentinel 只保证主节点的故障的失效转移，而例如说 Jedis 库，也只监听了主节点的变化，但是从节点故障的情况，Jedis 是不进行处理的。这就会导致，Jedis 读会访问到从节点，导致问题。当然，Redisson 库的功能比较强大，已经支持从节点的故障监听。</li><li>如果到达需要读写分离的体量，一般写操作也不一定会少，可以考虑上 Redis Cluster 方案，更加可靠。</li></ul></blockquote><h2 id="如何使用-Redis-Sentinel-实现高可用？"><a href="#如何使用-Redis-Sentinel-实现高可用？" class="headerlink" title="如何使用 Redis Sentinel 实现高可用？"></a>如何使用 Redis Sentinel 实现高可用？</h2><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li><strong>监控（Monitoring</strong>）：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li><strong>提醒（Notification）</strong>：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong>：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p><p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel 。</p><h2 id="如果使用-Redis-Cluster-实现高可用？"><a href="#如果使用-Redis-Cluster-实现高可用？" class="headerlink" title="如果使用 Redis Cluster 实现高可用？"></a>如果使用 Redis Cluster 实现高可用？</h2><p>Redis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p><p>Redis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所映射的键值数据。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210715102145148.png" alt="image-20210715102145148" style="zoom:50%;" /><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>无中心架构；</p><p>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；</p><p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</p><p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；</p><p>降低运维成本，提高系统的扩展性和可用性。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p><p>节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。</p><p>数据通过异步复制，不保证数据的强一致性。</p><p>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p><p>Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</p><h2 id="说说-Redis-哈希槽的概念？"><a href="#说说-Redis-哈希槽的概念？" class="headerlink" title="说说 Redis 哈希槽的概念？"></a>说说 Redis 哈希槽的概念？</h2><p>Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。</p><p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。</p><p><strong>为什么是 16384 呢？</strong></p><p>主要考虑集群内的网络带宽，而 16384 刚好是 2K 字节大小。</p><h2 id="Redis-Cluster-的主从复制模型是怎样的？"><a href="#Redis-Cluster-的主从复制模型是怎样的？" class="headerlink" title="Redis Cluster 的主从复制模型是怎样的？"></a>Redis Cluster 的主从复制模型是怎样的？</h2><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了<strong>主从复制</strong>模型，每个节点都会有 N-1 个复制节点。</p><p>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：</p><ul><li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li><li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。</li></ul><h2 id="Redis-的哨兵有什么功能？"><a href="#Redis-的哨兵有什么功能？" class="headerlink" title="Redis 的哨兵有什么功能？"></a>Redis 的哨兵有什么功能？</h2><p>哨兵是 Redis 集群架构中非常重要的一个组件，主要功能如下：</p><ul><li>集群监控，负责监控 Redis Master 和 Slave 进程是否正常工作；</li><li>消息通知，如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员；</li><li>故障转移，如果 Master node 挂掉了，会自动转移到 Slave node 上；</li><li>配置中心，如果故障转移发生了，通知 Client 客户端新的 Master 地址。</li></ul><h2 id="Redis-哨兵和集群的区别是什么？"><a href="#Redis-哨兵和集群的区别是什么？" class="headerlink" title="Redis 哨兵和集群的区别是什么？"></a>Redis 哨兵和集群的区别是什么？</h2><p>Redis 的哨兵作用是管理多个 Redis 服务器，提供了监控、提醒以及自动的故障转移的功能。哨兵可以保证当主服务器挂了后，可以从从服务器选择一台当主服务器，把别的从服务器转移到读新的主机。Redis 哨兵的主要功能有：</p><ul><li>集群监控：对 Redis 集群的主从进程进行监控，判断是否正常工作。</li><li>消息通知：如果存在 Redis 实例有故障，那么哨兵可以发送报警消息通知管理员。</li><li>故障转移：如果主机（master）节点挂了，那么可以自动转移到从（slave）节点上。</li><li>配置中心：当存在故障时，对故障进行转移后，配置中心会通知客户端新的主机（master）地址。</li></ul><p>Redis 的集群的功能是为了解决单机 Redis 容量有限的问题，将数据按一定的规则分配到多台机器，对内存的每秒访问不受限于单台服务器，可受益于分布式集群高扩展性。</p><h2 id="缓存命中率表示什么？"><a href="#缓存命中率表示什么？" class="headerlink" title="缓存命中率表示什么？"></a>缓存命中率表示什么？</h2><p>通常来说，缓存命中率越高，缓存的收益越高，应用的性能也就越好。</p><ul><li><strong>缓存命中：</strong> 可以同缓存中获取到需要的数据</li><li><strong>缓存不命中：</strong>缓存中无法获取所需数据，需要再次查询数据库或者其他数据存储载体。</li></ul><blockquote><p>缓存命中率 = 缓存中获取数据次数/获取数据总次数</p></blockquote><h2 id="假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。</p><ul><li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 <code>keys</code> 指令会有什么问题？</li><li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。<code>keys</code> 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</li></ul><h2 id="请说说你们生产环境中的-Redis-是怎么部署的？"><a href="#请说说你们生产环境中的-Redis-是怎么部署的？" class="headerlink" title="请说说你们生产环境中的 Redis 是怎么部署的？"></a>请说说你们生产环境中的 Redis 是怎么部署的？</h2><p>请大家自信品尝，只要遇到此问题，98%的人必挂，下面是参考答案：</p><ul><li>Redis Cluster ，10 台机器，5 台机器部署了 Redis 主实例，另外 5 台机器部署了 Redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</li><li>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10G 内存，一般线上生产环境，Redis 的内存尽量不要超过 10G，超过 10G 可能会有问题。那么，5 台机器对外提供读写，一共有 50G 内存。</li><li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</li><li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1G 。常驻内存的是 200 万条商品数据，占用内存是 20G ，仅仅不到总内存的 50% 。目前高峰期每秒就是 3500 左右的请求量。</li><li>其实大型的公司，会有基础架构的 Team 负责缓存集群的运维。</li></ul><h2 id="你知道有哪些-Redis-分区实现方案？"><a href="#你知道有哪些-Redis-分区实现方案？" class="headerlink" title="你知道有哪些 Redis 分区实现方案？"></a>你知道有哪些 Redis 分区实现方案？</h2><p>Redis 分区方案，主要分成两种类型：</p><ul><li>客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。案例：Redis Cluster 和客户端分区。</li><li>代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。案例：Twemproxy 和 Codis 。</li></ul><p>查询路由(Query routing)的意思，是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接 Redirect 到正确的 Redis 节点。</p><h2 id="如何提高-Redis-命中率？"><a href="#如何提高-Redis-命中率？" class="headerlink" title="如何提高 Redis 命中率？"></a>如何提高 Redis 命中率？</h2><p>提供缓存命中率，通常有如下方式：</p><ul><li>缓存预加载</li><li>增加缓存存储量</li><li>调整缓存存储数据类型</li><li>提升缓存更新频次</li></ul><h2 id="怎么优化-Redis-的内存占用？"><a href="#怎么优化-Redis-的内存占用？" class="headerlink" title="怎么优化 Redis 的内存占用？"></a>怎么优化 Redis 的内存占用？</h2><p>可以通过以下六种方式来对Redis的内存优化：</p><ul><li>redisObject 对象</li><li>缩减键值对象</li><li>共享对象池</li><li>字符串优化</li><li>编码优化</li><li>控制 key 的数量</li></ul><h2 id="什么是缓存穿透？怎么解决？"><a href="#什么是缓存穿透？怎么解决？" class="headerlink" title="什么是缓存穿透？怎么解决？"></a>什么是缓存穿透？怎么解决？</h2><p>大量的请求瞬时涌入系统，而这个数据在 Redis 中不存在，所有的请求都落到了数据库上把数据库打死。造成这种情况的原因有系统设计不合理、缓存数据更新不及时，或爬虫等恶意攻击。解决办法有：</p><p><strong>1. 使用布隆过滤器</strong></p><p>将查询的参数都存储到一个 bitmap 中，在查询缓存前，再找个新的 bitmap，在里面对参数进行验证。如果验证的 bitmap 中存在，则进行底层缓存的数据查询，如果 bitmap 中不存在查询参数，则进行拦截，不再进行缓存的数据查询。</p><p><strong>2. 缓存空对象</strong></p><p>如果从数据库查询的结果为空，依然把这个结果进行缓存，那么当用 key 获取数据时，即使数据不存在，Redis 也可以直接返回结果，避免多次访问数据库。</p><p>但是缓存空值的缺点是：</p><ul><li>如果存在黑客恶意的随机访问，造成缓存过多的空值，那么可能造成很多内存空间的浪费。但是也可以对这些数据设置很短的过期时间来控制；</li><li>如果查询的 key 对应的 Redis 缓存空值没有过期，数据库这时有了新数据，那么会出现数据库和缓存数据不一致的问题。但是可以保证当数据库有数据后更新缓存进行解决。</li></ul><h2 id="什么是缓存雪崩？怎么解决？"><a href="#什么是缓存雪崩？怎么解决？" class="headerlink" title="什么是缓存雪崩？怎么解决？"></a>什么是缓存雪崩？怎么解决？</h2><p>缓存雪崩是指当大量缓存失效时，大量的请求访问直接请求数据库，导致数据库服务器无法抗住请求或挂掉的情况。这时网站常常会出现 502 错误，导致网站不可用问题。</p><p>在预防缓存雪崩时，建议遵守以下几个原则：</p><ul><li>合理规划缓存的失效时间，可以给缓存时间加一个随机数，防止统一时间过期；</li><li>合理评估数据库的负载压力，这有利于在合理范围内部分缓存失，数据库也可以正常访问；</li><li>对数据库进行过载保护或应用层限流，这种情况下一般是在网站处于大流量、高并发时，服务器整体不能承受时，可以采用的一种限流保护措施；</li><li>最后还可以考虑多级缓存设计，实现缓存的高可用。</li></ul><h2 id="对-Redis-进行性能优化，有些什么建议？"><a href="#对-Redis-进行性能优化，有些什么建议？" class="headerlink" title="对 Redis 进行性能优化，有些什么建议？"></a>对 Redis 进行性能优化，有些什么建议？</h2><ol><li><p>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。</p></li><li><p>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</p></li><li><p>尽量避免在压力很大的主库上增加过多的从库。</p></li><li><p>主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</code> 。</p></li><li><p>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> Redis </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis线程模型</title>
      <link href="2021/05/08/Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/08/Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><p>redis 内部使用文件事件处理器 （file event handler），这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。 它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p><strong>文件事件处理器的结构包含 4 个部分：</strong></p><ul><li><strong>多个 socket</strong></li><li><strong>IO 多路复用程序</strong></li><li><strong>文件事件分派器</strong></li><li><strong>事件处理器（包括：连接应答处理器、命令请求处理器、命令回复处理器）</strong></li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p><strong>客户端与 redis 的一次通信过程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210722175808855.png" alt="image-20210722175808855"></p><ol><li>客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。</li><li>假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。</li><li>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。</li></ol><p><strong>详细说明</strong>：</p><ol><li><p>首先在redis启动初始化的时候，redis会先将事件处理器中的连接应答处理器和AE_READABLE事件关联起来;</p></li><li><p>如果客户端向redis发起连接，会产生AE_READABLE事件(步骤A)，产生该事件后会被IO多路复用程序监听到(步骤B)，然后IO多路复用程序会把监听到的socket信息放入到队列中(步骤C)，事件分配器每次从队列中取出一个socket(步骤D)，然后事件分派器把socket给对应的事件处理器(步骤E)。由于连接应答处理器和AE_READABLE事件在redis初始化的时候已经关联起来，所以由连接应答处理器来处理跟客户端建立连接，然后通过ServerSocket创建一个与客户端一对一对应的socket，如叫socket01，同时将这个socket01的AE_READABLE事件和命令请求处理器关联起来。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210715115052113.png" alt="image-20210715115052113"></p></li><li><p>当客户端向redis发生请求时(读、写操作)，首先就会在对应的socket如socket01上会产生AE_READABLE事件(步骤A)，产生该事件后会被IO多路复用程序监听到(步骤B)，然后IO多路复用程序会把监听到的socket信息放入到队列中(步骤C)，事件分配器每次从队列中取出一个socket(步骤D)，然后事件分派器把socket给对应的事件处理器(步骤E)。由于命令处理器和socket01的AE_READABLE事件关联起来了，然后对应的命令请求处理器来处理。这个命令请求处理器会从事件分配器传递过来的socket01上读取相关的数据，如何执行相应的读写处理。操作执行完之后，redis就会将准备好相应的响应数据(如你在redis客户端输入 set a 123回车时会看到响应ok)，并将socket01的AE_WRITABLE事件和命令回复处理器关联起来。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210715115112249.png" alt="image-20210715115112249"></p></li><li><p>当客户端会查询redis是否完成相应的操作，就会在socket01上产生一个AE_WRITABLE事件，会由对应的命令回复处理器来处理，就是将准备好的相应数据写入socket01(由于socket连接是双向的),返回给客户端，如读操作，客户端会显示ok。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210715115157067.png" alt="image-20210715115157067"></p></li><li><p>如果命令回复处理器执行完成后，就会删除这个socket01的AE_WRITABLE事件和命令回复处理器的关联。</p></li><li><p>这样客户端就和redis进行了一次通信。由于连接应答处理器执行一次就够了，如果客户端在次进行操作就会由命令请求处理器来处理，反复执行。</p></li></ol><blockquote><p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</p></blockquote><h4 id="为啥-redis-单线程模型也能效率这么高？"><a href="#为啥-redis-单线程模型也能效率这么高？" class="headerlink" title="为啥 redis 单线程模型也能效率这么高？"></a>为啥 redis 单线程模型也能效率这么高？</h4><ul><li><strong>纯内存操作</strong></li><li><strong>核心是基于非阻塞的 IO 多路复用机制</strong></li><li><strong>单线程反而避免了多线程的频繁上下文切换问题</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis线程模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="2021/05/02/Redis/"/>
      <url>2021/05/02/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><ul><li>Redis是一个开源的key-value存储系统。</li><li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</li><li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>在此基础上，Redis支持各种不同方式的排序。</li><li>与memcached一样，为了保证效率，数据都是缓存在内存中。</li><li>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li><li>并且在此基础上实现了master-slave(主从)同步。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>配合关系型数据库做高速缓存</strong></p><ul><li><p>高频次，热门访问的数据，降低数据库IO。</p></li><li><p>分布式架构，做session共享。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618160003509.png" alt="image-20210618160003509"></p><p><strong>多样的数据结构存储持久化数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618160101040.png" alt="image-20210618160101040"></p><h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><p><strong>Redis使用的是单线程+多路IO复用技术：</strong></p><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p><p>**串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)**（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用） 。</p><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a><strong>Redis</strong>字符串(String)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p></li><li><p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p></li><li><p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。</p></li></ol><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618162745983.png" alt="image-20210618162745983" style="zoom:120%;" /><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h3 id="Redis列表（List"><a href="#Redis列表（List" class="headerlink" title="Redis列表（List)"></a>Redis列表（List)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>单键多值：Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底</p><p>层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618163018649.png" alt="image-20210618163018649" style="zoom:120%;" /><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>List的数据结构为快速链表quickList。</li><li>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</li><li>当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618164459005.png" alt="image-20210618164459005" style="zoom:120%;" /><ul><li>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</li></ul><h3 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul><li><p>Redis set对外提供的功能与list类似，是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p></li><li><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的**复杂度都是O(1)**。</p></li><li><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。</p></li></ul><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>Set数据结构是dict字典，字典是用哈希表实现的。</li><li>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</li></ul><h3 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul><li><p>Redis hash 是一个键值对集合。</p></li><li><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p></li><li><p>类似Java里面的Map&lt;String,Object&gt;。</p></li><li><p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618203434868.png" alt="image-20210618203434868" style="zoom:120%;" />                    <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618203449210.png" alt="image-20210618203449210" style="zoom:120%;" /></p><p>方法一：每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</p><p>方法二：用户ID数据冗余。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618203718979.png" alt="image-20210618203718979" style="zoom:120%;" /><p>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</p><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h3 id="Redis有序集合Zset（Sorted-set）"><a href="#Redis有序集合Zset（Sorted-set）" class="headerlink" title="Redis有序集合Zset（Sorted set）"></a>Redis有序集合Zset（Sorted set）</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ul><li><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p></li><li><p>不同之处是有序集合的每个成员都关联了一个<strong>评分（</strong>score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p></li><li><p>因为元素是有序的，所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p></li><li><p>访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。</p></li></ul><h4 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>zset底层使用了两个数据结构：</p><ol><li><p>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p></li><li><p>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p></li></ol><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p><strong>简介</strong></p><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表，跳跃表效率堪比红黑树，实现远比红黑树简单。</p><p><strong>实例</strong></p><p>对比有序链表和跳跃表，从链表中查询出51：</p><ol><li>有序链表</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618205641992.png" alt="image-20210618205641992" style="zoom:120%;" /><p>​       要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><ol start="2"><li>跳跃表</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618205920332.png" alt="image-20210618205920332" style="zoom:120%;" /><ul><li><p>从第2层开始，1节点比51节点小，向后比较；</p></li><li><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层；</p></li><li><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下；</p></li><li><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p></li></ul><p>从此可以看出跳跃表比有序链表效率要高。</p><h3 id="Redis-Bitmaps"><a href="#Redis-Bitmaps" class="headerlink" title="Redis Bitmaps"></a>Redis Bitmaps</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ul><li><p>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p></li><li><p>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p> <img src="img/image-20210618212534639.png" alt="image-20210618212534639" style="zoom:120%;" /></li></ul><h4 id="Bitmaps与set对比"><a href="#Bitmaps与set对比" class="headerlink" title="Bitmaps与set对比"></a><strong>Bitmaps</strong>与set对比</h4><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表：</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合</td><td>64位</td><td>50000000</td><td>64位*50000000 = 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。</p><table><thead><tr><th>set和Bitmaps存储独立用户空间对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr><td>集合</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比（用户比较少）</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合</td><td>64位</td><td>100000</td><td>64位*100000 = 800KB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a><strong>HyperLogLog</strong></h3><p> 在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量），可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p><p>解决基数问题有很多种方案：</p><ol><li><p>数据存储在MySQL表中，使用distinct count计算不重复个数。</p></li><li><p>使用Redis提供的hash、set、bitmaps等数据结构来处理。</p></li></ol><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog。</p><ul><li><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p></li><li><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p></li><li><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p></li></ul><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}，那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a><strong>Geospatial</strong></h3><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h2 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h2><h3 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h3><ul><li><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p></li><li><p>Redis 客户端可以订阅任意数量的频道。</p></li></ul><h3 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a><strong>Redis</strong>的发布和订阅</h3><ol><li>客户端可以订阅频道如下图：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211300027.png" alt="image-20210618211300027" style="zoom:150%;" /><ol start="2"><li>当给这个频道发布消息后，消息就会发送给订阅的客户端：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211401669.png" alt="image-20210618211401669" style="zoom:150%;" /><h3 id="发布订阅命令行实现"><a href="#发布订阅命令行实现" class="headerlink" title="发布订阅命令行实现"></a><strong>发布订阅命令行实现</strong></h3><ol><li><p>打开一个客户端订阅channel1：</p>  <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211907299.png" alt="image-20210618211907299" style="zoom: 60%;" /></li><li><p>打开另一个客户端，给channel1发布消息hello：</p>  <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618212029799.png" alt="image-20210618212029799" style="zoom:50%;" /></li><li><p>打开第一个客户端可以看到发送的消息：</p></li></ol> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211941020.png" alt="image-20210618211941020" style="zoom: 55%;" /><h2 id="Redis事务、锁机制秒杀"><a href="#Redis事务、锁机制秒杀" class="headerlink" title="Redis事务、锁机制秒杀"></a>Redis事务、锁机制秒杀</h2><h3 id="Redis事务定义"><a href="#Redis事务定义" class="headerlink" title="Redis事务定义"></a>Redis事务定义</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p><h3 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h3><p>Redis事务中有Multi、Exec和discard三个指令，在Redis中，从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。而组队的过程中可以通过discard来放弃组队。</p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093306171.png" alt="image-20210619093306171" style="zoom:120%;" /><p>案例说明：</p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093617872.png" alt="image-20210619093617872" style="zoom: 50%;" /><p>组队成功，提交成功。</p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093741383.png" alt="image-20210619093741383" style="zoom: 50%;" /><p>组队阶段报错，提交失败。</p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093941172.png" alt="image-20210619093941172" style="zoom:50%;" /><p>组队成功，提交有成功有失败情况。</p><h3 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h3><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094058710.png" alt="image-20210619094058710" style="zoom:130%;" /><p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094201203.png" alt="image-20210619094201203" style="zoom:130%;" /><h3 id="为什么要做成事务"><a href="#为什么要做成事务" class="headerlink" title="为什么要做成事务"></a><strong>为什么要做成事务</strong></h3><p>想想一个场景：有很多人有你的账户，同时去参加双十一抢购。</p><h3 id="事务冲突的问题"><a href="#事务冲突的问题" class="headerlink" title="事务冲突的问题"></a><strong>事务冲突的问题</strong></h3><p><strong>例子</strong></p><ul><li><p>一个请求想给金额减8000；</p></li><li><p>一个请求想给金额减5000；</p></li><li><p>一个请求想给金额减1000。</p><p>最终我们可以发现，总共金额是10000，如果请求全部执行，那最后的金额变为-4000，很明显不合理。</p></li></ul> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094341090.png" alt="image-20210619094341090" style="zoom:130%;" /><p><strong>悲观锁</strong></p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094633896.png" alt="image-20210619094633896" style="zoom:130%;" /><p><strong>悲观锁(Pessimistic Lock)<strong>，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><p><strong>乐观锁</strong></p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094741479.png" alt="image-20210619094741479" style="zoom:130%;" /><p><strong>乐观锁(Optimistic Lock)<strong>，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种<strong>check-and-set机制</strong>实现事务的。</p><p><strong>WATCH</strong> <strong>key</strong> <strong>[key …]</strong></p><p>在执行multi之前，先执行watch key1 [key2]，可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</strong></p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619095200164.png" alt="image-20210619095200164" style="zoom: 50%;" /><p> <strong>unwatch</strong></p><p>取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p><h3 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h3><ul><li><p>单独的隔离操作 ：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p></li><li><p>没有隔离级别的概念 ：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p></li><li><p>不保证原子性 ：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p></li></ul><h2 id="Redis-事务秒杀案例"><a href="#Redis-事务秒杀案例" class="headerlink" title="Redis_事务秒杀案例"></a>Redis_事务秒杀案例</h2><h3 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a><strong>解决计数器和人员记录的事务操作</strong></h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619095633057.png" alt="image-20210619095633057" style="zoom:130%;" /><h3 id="Redis事务—秒杀并发模拟"><a href="#Redis事务—秒杀并发模拟" class="headerlink" title="Redis事务—秒杀并发模拟"></a>Redis事务—秒杀并发模拟</h3><blockquote><p><strong>使用工具ab模拟测试：</strong></p><ul><li><p>CentOS6 默认安装</p></li><li><p>CentOS7需要手动安装</p></li></ul></blockquote><p><strong>通过ab测试</strong></p><p>im postfile 模拟表单提交参数， 以&amp;符号结尾，存放当前目录。</p><p>内容：prodid=0101&amp;</p><p>执行：ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded</p><p>访问：<a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p><p><strong>超卖</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100129431.png" alt="image-20210619100129431" style="zoom:120%;" /><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100138313.png" alt="image-20210619100138313" style="zoom:120%;" /></p><h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100303067.png" alt="image-20210619100303067" style="zoom:130%;" /><p><strong>利用乐观锁淘汰用户，解决超卖问题。</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100339429.png" alt="image-20210619100339429" style="zoom:130%;" /><p><strong>主要代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKill_redis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Jedis jedis =<span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.44.168&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">System.out.println(jedis.ping());</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//秒杀过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1 uid和prodid非空判断</span></span><br><span class="line"><span class="keyword">if</span>(uid == <span class="keyword">null</span> || prodid == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 连接redis</span></span><br><span class="line"><span class="comment">//Jedis jedis = new Jedis(&quot;192.168.44.168&quot;,6379);</span></span><br><span class="line"><span class="comment">//通过连接池得到jedis对象</span></span><br><span class="line">JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">Jedis jedis = jedisPoolInstance.getResource();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 拼接key</span></span><br><span class="line"><span class="comment">// 3.1 库存key</span></span><br><span class="line">String kcKey = <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="comment">// 3.2 秒杀成功用户key</span></span><br><span class="line">String userKey = <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:user&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监视库存</span></span><br><span class="line">jedis.watch(kcKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 获取库存，如果库存null，秒杀还没有开始</span></span><br><span class="line">String kc = jedis.get(kcKey);</span><br><span class="line"><span class="keyword">if</span>(kc == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀还没有开始，请等待&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 判断用户是否重复秒杀操作</span></span><br><span class="line"><span class="keyword">if</span>(jedis.sismember(userKey, uid)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;已经秒杀成功了，不能重复秒杀&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 判断如果商品数量，库存数量小于1，秒杀结束</span></span><br><span class="line"><span class="keyword">if</span>(Integer.parseInt(kc)&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀已经结束了&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7 秒杀过程</span></span><br><span class="line"><span class="comment">//使用事务</span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line"></span><br><span class="line"><span class="comment">//组队操作</span></span><br><span class="line">multi.decr(kcKey);</span><br><span class="line">multi.sadd(userKey,uid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">List&lt;Object&gt; results = multi.exec();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(results == <span class="keyword">null</span> || results.size()==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀失败了....&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.1 库存-1</span></span><br><span class="line"><span class="comment">//jedis.decr(kcKey);</span></span><br><span class="line"><span class="comment">//7.2 把秒杀成功用户添加清单里面</span></span><br><span class="line"><span class="comment">//jedis.sadd(userKey,uid);</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;秒杀成功了..&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100941862.png" alt="image-20210619100941862" style="zoom:100%;" /><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101004992.png" alt="image-20210619101004992"></p><h3 id="继续增加并发测试"><a href="#继续增加并发测试" class="headerlink" title="继续增加并发测试"></a>继续增加并发测试</h3><p> <strong>连接有限制</strong></p><p>增加-r参数，-r  Don’t exit on socket receive errors。</p><p> <strong>已经秒光，可是还有库存</strong></p><p>已经秒光，可是还有库存。原因：乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101322601.png" alt="image-20210619101322601" style="zoom:150%;" /><p><strong>连接超时，通过连接池解决</strong></p><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。通过参数管理连接的行为，代码见项目中：</p><p>连接池参数：</p><ul><li><p>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</p></li><li><p> maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</p></li><li><p>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</p></li><li><p>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的。</p></li></ul><h3 id="解决库存遗留问题"><a href="#解决库存遗留问题" class="headerlink" title="解决库存遗留问题"></a><strong>解决库存遗留问题</strong></h3><p><strong>LUA脚本在Redis中的优势</strong></p><ul><li><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数，提升性能。</p></li><li><p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p></li><li><p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p></li><li><p>利用lua脚本淘汰用户，解决超卖问题，redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis</strong> <strong>利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101853376.png" alt="image-20210619101853376" style="zoom:130%;" /><h2 id="Redis持久化之RDB"><a href="#Redis持久化之RDB" class="headerlink" title="Redis持久化之RDB"></a><strong>Redis</strong>持久化之RDB</h2><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a><strong>总体介绍</strong></h3><blockquote><p>官网介绍：<a href="http://www.redis.io/">http://www.redis.io</a></p></blockquote><p>Redis 提供了2个不同形式的持久化方式：</p><ul><li><p>RDB（Redis DataBase）</p></li><li><p>AOF（Append Of File）</p></li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><h4 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a><strong>备份是如何执行的</strong></h4><p>Redis会单独创建（fork）一个子进程来进行持久化，首先会将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><ul><li><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p></li><li><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”。</p></li><li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p></li></ul><h4 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a><strong>RDB</strong>持久化流程</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619103155712.png" alt="image-20210619103155712" style="zoom:150%;" /><h4 id="dump-rdb文件"><a href="#dump-rdb文件" class="headerlink" title="dump.rdb文件"></a><strong>dump.rdb</strong>文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb。</p><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下 “dir  ./”</p><h4 id="如何触发RDB快照；保持策略"><a href="#如何触发RDB快照；保持策略" class="headerlink" title="如何触发RDB快照；保持策略"></a><strong>如何触发RDB快照；保持策略</strong></h4><p><strong>配置文件中默认的快照配置</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619103558260.png" alt="image-20210619103558260" style="zoom:130%;" /><p><strong>命令save VS bgsave</strong></p><ul><li><p>save ：save时只管保存，其它不管，全部阻塞。手动保存，不建议。</p></li><li><p><strong>bgsave：Redis会在后台异步进行快照操作，</strong> <strong>快照同时还可以响应客户端请求。</strong></p></li><li><p>可以通过lastsave 命令获取最后一次成功执行快照的时间。</p></li></ul><p><strong>flushall命令</strong></p><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><p>适合大规模的数据恢复</p></li><li><p>对数据完整性和一致性要求不高更适合使用</p></li><li><p>节省磁盘空间</p></li><li><p>恢复速度快</p></li></ul><p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104039665.png" alt="image-20210619104039665"></p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li><p>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。</p></li><li><p>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能。</p></li><li><p>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p></li></ul><h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104309571.png" alt="image-20210619104309571" style="zoom:130%;" /><h2 id="Redis持久化之AOF"><a href="#Redis持久化之AOF" class="headerlink" title="Redis持久化之AOF"></a>Redis持久化之AOF</h2><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF<strong>（Append Only File）</strong></h3><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h4 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a><strong>AOF</strong>持久化流程</h4><ol><li><p>客户端的请求写命令会被append追加到AOF缓冲区内；</p></li><li><p>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</p></li><li><p>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</p></li><li><p>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104813563.png" alt="image-20210619104813563" style="zoom:130%;" /><h4 id="AOF默认不开启"><a href="#AOF默认不开启" class="headerlink" title="AOF默认不开启"></a><strong>AOF</strong>默认不开启</h4><p>可以在redis.conf中配置文件名称默认为 appendonly.aof文件中开启，AOF文件的保存路径，同RDB的路径一致。</p><h4 id="AOF和RDB同时开启，redis听谁的？"><a href="#AOF和RDB同时开启，redis听谁的？" class="headerlink" title="AOF和RDB同时开启，redis听谁的？"></a>AOF和RDB同时开启，redis听谁的？</h4><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）。</p><h4 id="AOF启动、修复、恢复"><a href="#AOF启动、修复、恢复" class="headerlink" title="AOF启动、修复、恢复"></a><strong>AOF</strong>启动、修复、恢复</h4><ul><li><p>AOF的备份机制和性能虽然和RDB不同，但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p></li><li><p>正常恢复</p><ul><li>修改默认的appendonly no，改为yes。</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)。</li><li>恢复：重启redis然后重新加载。</li></ul></li><li><p>异常恢复</p><ul><li>修改默认的appendonly no，改为yes。</li><li>如遇到<strong>AOF文件损坏</strong>，通过/usr/local/bin/<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复。</li><li>备份被写坏的AOF文件。</li><li>恢复：重启redis，然后重新加载。</li></ul></li></ul><h4 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h4><ul><li><p>appendfsync always：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好。</p></li><li><p>appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p></li><li><p>appendfsync no：redis不主动进行同步，把同步时机交给操作系统。</p></li></ul><h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a><strong>Rewrite</strong>压缩</h4><p><strong>Rewrite压缩是什么</strong></p><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p><p><strong>重写原理，如何实现重写</strong></p><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指把rdb 的快照，以二进制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p><p><strong>no-appendfsync-on-rewrite：</strong></p><ul><li><p>如果 no-appendfsync-on-rewrite=yes ，不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p></li><li><p>如果 no-appendfsync-on-rewrite=no，还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p></li></ul><p><strong>触发机制，何时重写</strong></p><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 </p><ul><li><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）。</p></li><li><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p></li><li><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p></li><li><p>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 </p></li><li><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p></li></ul><p><strong>重写流程</strong></p><ol><li><p>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行；</p></li><li><p>主进程fork出子进程执行重写操作，保证主进程不会阻塞；</p></li><li><p>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区，保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失；</p></li><li><p>子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。主进程把aof_rewrite_buf中的数据写入到新的AOF文件；</p></li><li><p>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619110418254.png" alt="image-20210619110418254" style="zoom:120%;" /><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619110452361.png" alt="image-20210619110452361" style="zoom:120%;" /><ul><li><p>备份机制更稳健，丢失数据概率更低。</p></li><li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p></li></ul><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul><li><p>比起RDB占用更多的磁盘空间。</p></li><li><p>恢复备份速度要慢。</p></li><li><p>每次读写都同步的话，有一定的性能压力。</p></li><li><p>存在个别Bug，造成恢复不能。</p></li></ul><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619110629704.png" alt="image-20210619110629704" style="zoom:120%;" /><h3 id="总结-Which-one"><a href="#总结-Which-one" class="headerlink" title="总结(Which one)"></a><strong>总结</strong>(Which one)</h3><h4 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a><strong>用哪个好</strong></h4><p>官方推荐两个都启用：</p><ul><li><p>如果对数据不敏感，可以选单独用RDB。</p></li><li><p>不建议单独用 AOF，因为可能会出现Bug。</p></li><li><p>如果只是做纯内存缓存，可以都不用。</p></li></ul><h4 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a>官网建议</h4><ul><li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</p></li><li><p>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。 </p></li><li><p>Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</p></li><li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p></li><li><p>同时开启两种持久化方式：在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p></li><li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p></li><li><p>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p></li><li><p>性能建议：</p><ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 9001这条规则。    </li><li>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单，只load自己的AOF文件就可以了。</li><li>aof代价：一是带来了持续的IO，二是AOF rewrite的最后，将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。  </li><li>只要硬盘许可，应该尽量减少AOF  rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。  </li></ul></li></ul><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master以写为主，Slave以读为主</strong>，主从复制节点间数据是全量的。</p><p>作用：</p><ul><li><p>读写分离，性能扩展</p></li><li><p>容灾快速恢复</p></li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619111652745.png" alt="image-20210619111652745" style="zoom:150%;" /><h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a><strong>复制原理</strong></h3><ul><li><p>Slave启动成功连接到master后会发送一个sync命令；</p></li><li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步。</p></li><li><p>全量复制：slave服务器在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p>增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步。</p></li><li><p>但是只要是重新连接master，一次完全同步（全量复制)将被自动执行。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619112440704.png" alt="image-20210619112440704" style="zoom:150%;" /><h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a><strong>哨兵模式</strong>(sentinel)</h3><p>反客为主：当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。用 slaveof no one 指令将从机变为主机。而哨兵模式是<strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619154258222.png" alt="image-20210619154258222" style="zoom:130%;" /><p> <strong>当主机挂掉，从机选举产生新的主机</strong></p><ul><li><p>哪个从机会被选举为主机呢？根据优先级别：slave-priority 。</p></li><li><p>原主机重启后会变为从机。</p></li></ul><p><strong>复制延时</strong></p><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时</p><p>候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><p><strong>故障恢复</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619154850009.png" alt="image-20210619154850009" style="zoom:130%;" /><p>优先级：在redis.conf中默认 slave-priority 100，值越小优先级越高。</p><p>偏移量：指获得原主机数据最全的概率。</p><p>runid：每个redis实例启动后都会随机生成一个40位的runid。</p><h2 id="Redis集群（cluster模式）"><a href="#Redis集群（cluster模式）" class="headerlink" title="Redis集群（cluster模式）"></a>Redis集群（cluster模式）</h2><p>Redis 集群（包括很多小集群）实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N，即一个小集群存储1/N的数据，每个小集群里面维护好自己的1/N的数据。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><p>该模式的redis集群特点是：分治、分片。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>容量不够，redis如何进行扩容？</p></li><li><p>并发写操作， redis如何分摊？</p></li><li><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p></li><li><p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p></li></ol><h3 id="集群连接"><a href="#集群连接" class="headerlink" title="集群连接"></a>集群连接</h3><p>普通方式登录：可能直接进入读主机，存储数据时，会出现MOVED重定向操作，所以，应该以集群方式登录。</p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619162020586.png" alt="image-20210619162020586" style="zoom:150%;" /><p>集群登录：redis-cli -c -p 6379  采用集群策略连接，设置数据会自动切换到相应的写主机.</p><h3 id="redis-cluster-如何分配这六个节点"><a href="#redis-cluster-如何分配这六个节点" class="headerlink" title="redis cluster 如何分配这六个节点?"></a><strong>redis cluster</strong> <strong>如何分配这六个节点?</strong></h3><ul><li>一个集群至少要有三个主节点。</li><li>选项 –cluster-replicas 1 ：表示我们希望为集群中的每个主节点创建一个从节点。</li><li>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</li></ul><h3 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a>什么是slots</h3><p>一个 Redis 集群包含 16384 个插槽（hash slot），数据库中的每个键都属于这 16384 个插槽的其中一个。集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p><ul><li>节点 A 负责处理 0 号至 5460 号插槽。</li><li>节点 B 负责处理 5461 号至 10922 号插槽。</li><li>节点 C 负责处理 10923 号至 16383 号插槽。</li></ul><h3 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="在集群中录入值"></a><strong>在集群中录入值</strong></h3><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p><p>redis-cli客户端提供了 –c 参数实现自动重定向。如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。不在一个slot下的键值，是不能使用mget,mset等多键操作。</p><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a><strong>故障恢复</strong></h3><ul><li><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15</strong>秒超时</p></li><li><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p></li></ul><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><ul><li><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么整个集群都挂掉。</p></li><li><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p></li></ul><h3 id="Redis-集群优点"><a href="#Redis-集群优点" class="headerlink" title="Redis 集群优点"></a><strong>Redis</strong> <strong>集群优点</strong></h3><ul><li><p>实现扩容</p></li><li><p>分摊压力</p></li><li><p>无中心配置相对简单</p></li></ul><h3 id="Redis-集群不足"><a href="#Redis-集群不足" class="headerlink" title="Redis 集群不足"></a><strong>Redis</strong> <strong>集群不足</strong></h3><ul><li><p>多键操作是不被支持的。</p></li><li><p>多键的Redis事务是不被支持的，lua脚本不被支持。</p></li><li><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p></li></ul><h2 id="Redis应用问题解决"><a href="#Redis应用问题解决" class="headerlink" title="Redis应用问题解决"></a>Redis应用问题解决</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源（数据库），从而可能压垮数据源。比如</p><p>用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p>缓存穿透发生的条件：</p><ol><li>应用服务器压力变大</li><li>redis命中率降低</li><li>一直查询数据库，使得数据库压力太大而压垮</li></ol><p>其实redis在这个过程中一直平稳运行，崩溃的是我们的数据库（如MySQL）。</p><p>缓存穿透发生的原因：黑客或者其他非正常用户频繁进行很多非正常的url访问，使得redis查询不到数据库。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619163643698.png" alt="image-20210619163643698" style="zoom:120%;" /><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p><strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p></li><li><p><strong>设置可访问的名单（白名单）：</strong>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p></li><li><p><strong>采用布隆过滤器</strong>：布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p></li><li><p><strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p></li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p><p>缓存击穿的现象：</p><ol><li>数据库访问压力瞬时增加，数据库崩溃</li><li>redis里面没有出现大量key过期</li><li>redis正常运行</li></ol><p>缓存击穿发生的原因：redis某个key过期了，大量访问使用这个key（热门key）。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619165201337.png" alt="image-20210619165201337" style="zoom:120%;" /><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。</p><ol><li><p><strong>预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长。</p></li><li><p><strong>实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长。</p></li><li><p><strong>使用锁：</strong></p><ol><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key。</li><li>当操作返回成功时，再进行load db的操作，并回设缓存，最后删除mutex key；</li><li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li></ol></li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619165505113.png" alt="image-20210619165505113" style="zoom:120%;" /><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key正常访问。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619170416116.png" alt="image-20210619170416116" style="zoom:120%;" /><p><strong>缓存失效瞬间：</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619170456227.png" alt="image-20210619170456227" style="zoom:120%;" /><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p><strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）。</p></li><li><p><strong>使用锁或队列：</strong>用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，该方法不适用高并发情况。</p></li><li><p><strong>设置过期标志更新缓存：</strong>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p></li><li><p><strong>将缓存失效时间分散开：</strong>比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li></ol><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程的特点以及分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ol><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis等）</p></li><li><p>基于Zookeeper</p></li></ol><p>根据实现方式，分布式锁还可以分为类CAS自旋式分布式锁以及event事件类型分布式锁：</p><ul><li>类CAS自旋式分布式锁：询问的方式，类似java并发编程中的线程获询问的方式尝试加锁，如mysql、redis。</li><li>另外一类是event事件通知进程后续锁的变化，轮询向外的过程，如zookeeper、etcd。</li></ul><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li><p>性能：redis最高</p></li><li><p>可靠性：zookeeper最高</p></li></ol><h4 id="解决方案：使用redis实现分布式锁"><a href="#解决方案：使用redis实现分布式锁" class="headerlink" title="解决方案：使用redis实现分布式锁"></a><strong>解决方案：使用redis实现分布式锁</strong></h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619213926122.png" alt="image-20210619213926122" style="zoom:120%;" /><p>setnx：通过该命令尝试获得锁，没有获得锁的线程会不断等待尝试。</p><p>set key ex 3000nx：设置过期时间，自动释放锁，解决当某一个业务异常而导致锁无法释放的问题。但是当业务运行超过过期时间时，开辟监控线程增加该业务的运行时间，直到运行结束，释放锁。</p><p>uuid：设置uuid，释放前获取这个值，判断是否自己的锁，防止误删锁，造成没锁的情况。</p><h3 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h3><p>Redlock是一种算法，Redlock也就是 Redis Distributed Lock，可用实现多节点redis的分布式锁。RedLock官方推荐，Redisson完成了对Redlock算法封装。</p><p>此种方式具有以下特性：</p><ul><li>互斥访问：即永远只有一个 client 能拿到锁。</li><li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。</li><li>容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务</li></ul><p>RedLock原理（了解）</p><ol><li>获取当前Unix时间，以毫秒为单位。</li><li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li><li>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li></ol><h2 id="Redis-IO多线程"><a href="#Redis-IO多线程" class="headerlink" title="Redis IO多线程"></a>Redis IO多线程</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Redis6终于支撑多线程了，告别单线程了吗？</p><p>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><h3 id="原理架构"><a href="#原理架构" class="headerlink" title="原理架构"></a><strong>原理架构</strong></h3><p>Redis 6 加入多线程，但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619215600452.png" alt="image-20210619215600452" style="zoom:120%;" /><p>另外，多线程IO默认也是不开启的，需要再配置文件中配置：</p><ul><li><p>io-threads-do-reads yes </p></li><li><p>io-threads 4</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神秘的Java NIO</title>
      <link href="2021/04/28/%E7%A5%9E%E7%A7%98%E7%9A%84Java-NIO/"/>
      <url>2021/04/28/%E7%A5%9E%E7%A7%98%E7%9A%84Java-NIO/</url>
      
        <content type="html"><![CDATA[<h2 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><ul><li><p>同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p></li><li><p>而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。我们可以用打电话和发短信来很好的比喻同步与异步操作。</p></li></ul><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><ul><li><p>阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。</p></li><li><p>非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU 使用时间能不能补偿系统的切换成本需要好好评估。</p></li></ul><h3 id="同-异、阻-非堵塞-组合"><a href="#同-异、阻-非堵塞-组合" class="headerlink" title="同/异、阻/非堵塞 组合"></a>同/异、阻/非堵塞 组合</h3><table><thead><tr><th>组合方式</th><th>性能分析</th></tr></thead><tbody><tr><td>同步阻塞</td><td>最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态。</td></tr><tr><td>同步非阻塞</td><td>提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。 这种方式通常能提升 I/O 性能，但是会增加CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上。</td></tr><tr><td>异步阻塞</td><td>这种方式在分布式数据库中经常用到，例如在网一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O。异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。</td></tr><tr><td>异步非阻塞</td><td>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高。</td></tr></tbody></table><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-3a31f3fd3df13c18.jpg" alt="img"></p><h2 id="NIO定义"><a href="#NIO定义" class="headerlink" title="NIO定义"></a>NIO定义</h2><ul><li>即 <code>Java New IO。</code></li><li>是1个全新的、 <code>JDK 1.4</code>后提供的 <code>IO API。</code></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>提供了与标准<code>IO</code>不同的<code>IO</code>工作方式。</li><li>可替代 标准<code>Java IO</code> 的<code>IO API</code>。</li></ul><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>对比于 <code>Java IO</code>，<code>NIO</code>具备的新特性如下：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210709102817810.png" alt="image-20210709102817810" style="zoom:50%;" /><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>通过Channel注册到Selector上的状态来实现一种客户端与服务端的通信。</p></li><li><p>Channel中数据的读取是通过Buffer ,  一种非阻塞的读取方式。</p></li><li><p>Selector 多路复用器为单线程模型， 线程的资源开销相对比较小。</p></li></ol><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><code>Java NIO</code>的核心组件 包括：</p><ul><li>通道（<code>Channel</code>）</li><li>缓冲区（<code>Buffer</code>）</li><li>选择器（<code>Selectors</code>）</li></ul><p>下面将详细介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-93cd55b2ed7cd37c.png" alt="img"></p><p>Bufer是一个缓冲区，实际上是一个容器，一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/13449209-300fd48a7251c327.png" alt="img"></p><p>Buffer缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该模块内存。为了理解Buffer的工作原理，需要熟悉它的三个属性：capacity、position和limit。</p><p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。见下图：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/13449209-d261cbcb9b9ed88f.png" alt="img"></p><ul><li>capacity：Buffer作为一个内存块，有固定的大小值，也叫作“capacity”，只能往其中写入capacity个byte、long、char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清楚数据）才能继续写数据。</li><li>position：当你写数据到Buffer中时，position表示当前的位置。初始的position值为0，当写入一个字节数据到Buffer中后，position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity-1。当读取数据时，也是从某个特定位置读，将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取一个字节数据后，position向前移动到下一个可读的位置。</li><li>limit：在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）。</li></ul><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="基于通道-amp-缓冲数据"><a href="#基于通道-amp-缓冲数据" class="headerlink" title="基于通道 &amp; 缓冲数据"></a>基于通道 &amp; 缓冲数据</h3><p>具体步骤如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取数据源 和 目标传输地的输入输出流（此处以数据源 = 文件为例）</span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(infile);</span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(outfile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取数据源的输入输出通道</span></span><br><span class="line">FileChannel fcin = fin.getChannel();</span><br><span class="line">FileChannel fcout = fout.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 缓冲区 对象：Buffer（共有2种方法）</span></span><br><span class="line"> <span class="comment">// 方法1：使用allocate()静态方法</span></span><br><span class="line"> ByteBuffer buff = ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line"> <span class="comment">// 上述方法创建1个容量为256字节的ByteBuffer</span></span><br><span class="line"> <span class="comment">// 注：若发现创建的缓冲区容量太小，则重新创建一个大小合适的缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：通过包装一个已有的数组来创建</span></span><br><span class="line"> <span class="comment">// 注：通过包装的方法创建的缓冲区保留了被包装数组内保存的数据</span></span><br><span class="line"> ByteBuffer buff = ByteBuffer.wrap(byteArray);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 额外：若需将1个字符串存入ByteBuffer，则如下</span></span><br><span class="line"> String sendString=<span class="string">&quot;你好,服务器. &quot;</span>;</span><br><span class="line"> ByteBuffer sendBuff = ByteBuffer.wrap(sendString.getBytes(<span class="string">&quot;UTF-16&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从通道读取数据 &amp; 写入到缓冲区</span></span><br><span class="line"><span class="comment">// 注：若 以读取到该通道数据的末尾，则返回-1</span></span><br><span class="line">fcin.read(buff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 传出数据准备：将缓存区的写模式 转换-&gt;&gt; 读模式 调用flip()方法会将position设置为0，并将limit设置为之前的position的值。</span></span><br><span class="line">buff.flip();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 从 Buffer 中读取数据 &amp; 传出数据到通道</span></span><br><span class="line">fcout.write(buff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 重置缓冲区</span></span><br><span class="line"><span class="comment">// 目的：重用现在的缓冲区,即 不必为了每次读写都创建新的缓冲区，在再次读取之前要重置缓冲区</span></span><br><span class="line"><span class="comment">// 注：不会改变缓冲区的数据，只是重置缓冲区的主要索引值</span></span><br><span class="line">buff.clear();</span><br></pre></td></tr></table></figure><p>向Buffer中写数据：写数据到Buffer中有两种方式：</p><ul><li><p>从channel写到Buffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytes = channel.read(buf); <span class="comment">//将channel中的数据读取到buf中</span></span><br></pre></td></tr></table></figure></li><li><p>通过Buffer的put()方法写到Buffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(<span class="keyword">byte</span>); <span class="comment">//将数据通过put()方法写入到buf中</span></span><br></pre></td></tr></table></figure></li></ul><p>从Buffer中读数据有两种方式：</p><ul><li><p>从Buffer读取数据到Channel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytes = channel.write(buf); <span class="comment">//将buf中的数据读取到channel中</span></span><br></pre></td></tr></table></figure></li><li><p>通过Buffer的get()方法读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> bt = buf.get(); <span class="comment">//从buf中读取一个byte</span></span><br></pre></td></tr></table></figure></li></ul><p>其他方法：</p><ul><li><p>rewind()方法：Buffer.rewind()方法将position设置为0，使得可以重读Buffer中的所有数据，limit保持不变。</p></li><li><p>clear()与compact()方法：一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，可以通过clear()或compact()方法完成。如果调用的是clear()方法，position将被设置为0，limit设置为capacity的值，但是Buffer并未被清空，只是通过这些标记告诉我们可以从哪里开始往Buffer中写入多少数据。如果Buffer中还有一些未读的数据，调用clear()方法将被”遗忘 “。compact()方法将所有未读的数据拷贝到Buffer起始处，然后将position设置到最后一个未读元素的后面，limit属性依然设置为capacity。可以使得Buffer中的未读数据还可以在后续中被使用。</p></li><li><p>mark()与reset()方法：通过调用Buffer.mark()方法可以标记一个特定的position，之后可以通过调用Buffer.reset()恢复到这个position上。</p></li></ul><h3 id="基于选择器（Selecter）"><a href="#基于选择器（Selecter）" class="headerlink" title="基于选择器（Selecter）"></a>基于选择器（Selecter）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建Selector对象   </span></span><br><span class="line">Selector sel = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 向Selector对象绑定通道   </span></span><br><span class="line"> <span class="comment">// a. 创建可选择通道，并配置为非阻塞模式   </span></span><br><span class="line"> ServerSocketChannel server = ServerSocketChannel.open();   </span><br><span class="line"> server.configureBlocking(<span class="keyword">false</span>);   </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// b. 绑定通道到指定端口   </span></span><br><span class="line"> ServerSocket socket = server.socket();   </span><br><span class="line"> InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);   </span><br><span class="line"> socket.bind(address);   </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// c. 向Selector中注册感兴趣的事件   </span></span><br><span class="line"> server.register(sel, SelectionKey.OP_ACCEPT);    </span><br><span class="line"> <span class="keyword">return</span> sel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 处理事件</span></span><br><span class="line"><span class="keyword">try</span> &#123;    </span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </span><br><span class="line">        <span class="comment">// 该调用会阻塞，直到至少有一个事件就绪、准备发生 </span></span><br><span class="line">        selector.select(); </span><br><span class="line">        <span class="comment">// 一旦上述方法返回，线程就可以处理这些事件</span></span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); </span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = keys.iterator(); </span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123; </span><br><span class="line">            SelectionKey key = (SelectionKey) iter.next(); </span><br><span class="line">            iter.remove(); </span><br><span class="line">            process(key); </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;    </span><br><span class="line">    e.printStackTrace();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Selector与Channel是相互配合使用的，将Channel注册在Selector上之后，才可以正确的使用Selector，但此时Channel必须为非阻塞模式。Selector可以监听Channel的四种状态（Connect、Accept、Read、Write），当监听到某一Channel的某个状态时，才允许对Channel进行相应的操作。</p><ul><li>Connect：某一个客户端连接成功后</li><li>Accept：准备好进行连接</li><li>Read：可读</li><li>Write：可写</li></ul><h3 id="NIO实现多路复用"><a href="#NIO实现多路复用" class="headerlink" title="NIO实现多路复用"></a>NIO实现多路复用</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210709111120737.png" alt="image-20210709111120737"></p><ul><li>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色；</li><li>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求；</li><li>为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出 IllegalBlockingModeException 异常；</li><li>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</li></ul><blockquote><p>当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p></blockquote><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><ul><li>实例说明：实现文件复制功能</li><li>实现方式：通道<code>FileChannel</code>、 缓冲区<code>ByteBuffer</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置输入源 &amp; 输出地 = 文件</span></span><br><span class="line">        String infile = <span class="string">&quot;C:\\copy.sql&quot;</span>;</span><br><span class="line">        String outfile = <span class="string">&quot;C:\\copy.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取数据源 和 目标传输地的输入输出流（此处以数据源 = 文件为例）</span></span><br><span class="line">        FileInputStream fin = <span class="keyword">new</span> FileInputStream(infile);</span><br><span class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(outfile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取数据源的输入输出通道</span></span><br><span class="line">        FileChannel fcin = fin.getChannel();</span><br><span class="line">        FileChannel fcout = fout.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建缓冲区对象</span></span><br><span class="line">        ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 从通道读取数据 &amp; 写入到缓冲区</span></span><br><span class="line">            <span class="comment">// 注：若 以读取到该通道数据的末尾，则返回-1  </span></span><br><span class="line">            <span class="keyword">int</span> r = fcin.read(buff);</span><br><span class="line">            <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 传出数据准备：调用flip()方法  </span></span><br><span class="line">            buff.flip();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 6. 从 Buffer 中读取数据 &amp; 传出数据到通道</span></span><br><span class="line">            fcout.write(buff);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 7. 重置缓冲区</span></span><br><span class="line">            buff.clear();</span><br><span class="line">            </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NIO的工作流程步骤：</strong></p><ol><li>首先是先创建ServerSocketChannel 对象，和真正处理业务的线程池；</li><li>然后给刚刚创建的ServerSocketChannel 对象进行绑定一个对应的端口，然后设置为非阻塞；</li><li>然后创建Selector对象并打开，把这Selector对象注册到ServerSocketChannel 中，并设置好监听的事件，监听 SelectionKey.OP_ACCEPT；</li><li>接着就是Selector对象进行死循环监听每一个Channel通道的事件，循环执行 Selector.select() 方法，轮询就绪的 Channel；</li><li>从Selector中获取所有的SelectorKey（这个就可以看成是不同的事件），如果SelectorKey是处于 OP_ACCEPT 状态，说明是新的客户端接入，调用 ServerSocketChannel.accept 接收新的客户端。；</li><li>然后对这个把这个接受的新客户端的Channel通道注册到ServerSocketChannel上，并且把之前的OP_ACCEPT 状态改为SelectionKey.OP_READ读取事件状态，并且设置为非阻塞的，然后把当前的这个SelectorKey给移除掉，说明这个事件完成了；</li><li>如果第5步的时候过来的事件不是OP_ACCEPT 状态，那就是OP_READ读取数据的事件状态，然后调用本文章的上面的那个读取数据的机制就可以了。</li></ol><h2 id="与Java-IO的区别"><a href="#与Java-IO的区别" class="headerlink" title="与Java IO的区别"></a>与Java IO的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-a155ef4609137f75.png" alt="img"></p><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><ul><li><p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；</p></li><li><p>对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。  在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：</p><ul><li>AsynchronousSocketChannel</li><li>AsynchronousServerSocketChannel</li><li>AsynchronousFileChannel</li><li>AsynchronousDatagramChannel</li></ul></li></ul><p>其中的read/write方法，会返回一个带回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Java对BIO、NIO、AIO的支持：</strong></p><ul><li><p>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p></li><li><p>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p></li><li><p>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p></li></ul><p><strong>BIO、NIO、AIO适用场景分析:</strong></p><ul><li><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p></li><li><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p></li><li><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="2021/04/24/Mybatis/"/>
      <url>2021/04/24/Mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="什么是Mybatis？"><a href="#什么是Mybatis？" class="headerlink" title="什么是Mybatis？"></a>什么是Mybatis？</h3><p>答：<code>MyBatis</code>是一个优秀的持久层框架，是一个半<code>ORM</code>（对象关系映射）框架，它对<code>jdbc</code>的操作数据库的过程进行封装，使开发者只需要关注<code>SQL</code>本身，而不需要花费精力去处理例如加载驱动、创建连接、创建statement等繁杂的过程。</p><p><code>Mybatis</code>通过<code>xml</code>或注解的方式将要执行的<code>statement</code>配置起来，并通过<code>java</code>对象和<code>statement</code>中的<code>sql</code>进行<strong>映射</strong>生成最终执行的<code>sql</code>语句，最后由<code>mybatis</code>框架执行<code>sql</code>并将结果映射成<code>java</code>对象并返回。</p><h3 id="Mybatis的优点与缺点？"><a href="#Mybatis的优点与缺点？" class="headerlink" title="Mybatis的优点与缺点？"></a>Mybatis的优点与缺点？</h3><p><strong>优点：</strong></p><ol><li>基于<code>SQL</code>语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，<code>SQL</code>写在<code>XML</code>里，解除<code>sql</code>与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态<code>SQL</code>语句，并可重用。</li><li>与<code>JDBC</code>相比，减少了<code>JDBC</code>大量冗余的代码，不需要手动开关连接。</li><li>很好的与各种数据库兼容。</li><li>能够与<code>Spring</code>很好的集成。</li><li>提供映射标签，支持对象与数据库的<code>ORM</code>字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li></ol><p><strong>缺点：</strong></p><ol><li><code>SQL</code>语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写<code>SQL</code>语句的功底有一定要求。</li><li><code>SQL</code>语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li></ol><h3 id="Mybatis和Hibernate有什么区别？"><a href="#Mybatis和Hibernate有什么区别？" class="headerlink" title="Mybatis和Hibernate有什么区别？"></a>Mybatis和Hibernate有什么区别？</h3><ol><li><code>Mybatis</code>和<code>hibernate</code>不同，它不完全是一个<code>ORM</code>框架，因为<code>MyBatis</code>需要程序员自己编写<code>Sql</code>语句。</li><li><code>Hibernate</code>对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用<code>hibernate</code>开发可以节省很多代码，提高效率。</li><li><code>Mybatis</code>直接编写原生态<code>sql</code>，可以严格控制<code>sql</code>执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是<code>mybatis</code>无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套<code>sql</code>映射文件，工作量大。</li></ol><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h3><ul><li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li><li><code>#&#123;&#125;</code>是 sql 的参数占位符，Mybatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li></ul><h3 id="Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h3><p>答：还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中为 sql 片段标签，通过<code>&lt;include&gt;</code>标签引入 sql 片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p><h3 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h3><p>答：insert 方法总是返回一个int值 ，这个值代表的是插入的行数。</p><p>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。</p><h3 id="Mybatis的一级、二级缓存？"><a href="#Mybatis的一级、二级缓存？" class="headerlink" title="Mybatis的一级、二级缓存？"></a>Mybatis的一级、二级缓存？</h3><ol><li>一级缓存：Mybatis的一级缓存是指SQLSession，一级缓存的作用域是SQlSession，Mabits默认开启一级缓存。在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。</li></ol><blockquote><p>1：一级缓存是默认开启的；<br>2：底层其实是基于hashmap的本地内存缓存；<br>3：作用域是session（其实就相当于一个方法）；<br>4：当session关闭或者刷新的时候缓存清空；<br>5：不同sqlsession之间缓存互不影响。</p></blockquote><ol start="2"><li>二级缓存： 二级缓存是mapper级别的，Mybatis默认是没有开启二级缓存的。多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是多个SqlSession共享的。</li></ol><blockquote><p>1：首先mybatis默认是没有开启二级缓存的；<br>2：二级缓存需要我们手动开启，它是mapper级别的缓存；<br>3：同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p></blockquote><h3 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h3><ol><li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同；</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；</li><li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ol><h3 id="当实体类中的属性名和表中的字段名不一样，怎么办？"><a href="#当实体类中的属性名和表中的字段名不一样，怎么办？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样，怎么办？"></a>当实体类中的属性名和表中的字段名不一样，怎么办？</h3><ol><li>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li><li>第2种： 通过 `` 来映射字段名和实体类属性名的一一对应的关系。</li></ol><h3 id="模糊查询like语句该怎么写？"><a href="#模糊查询like语句该怎么写？" class="headerlink" title="模糊查询like语句该怎么写？"></a>模糊查询like语句该怎么写？</h3><ol><li>第1种：在Java代码中添加sql通配符；</li><li>第2种：在sql语句中拼接通配符，会引起sql注入</li></ol><h3 id="MyBatis实现一对一有几种方式-具体怎么操作的？"><a href="#MyBatis实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="MyBatis实现一对一有几种方式?具体怎么操作的？"></a>MyBatis实现一对一有几种方式?具体怎么操作的？</h3><ul><li>联合查询是几个表联合查询，只查询一次，通过在resultMap里面配置association节点配置一对一的类就可以完成； </li><li>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过association配置，但另外一个表的查询通过select属性配置。</li></ul><h3 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>答：接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。 接口绑定有两种实现方式：</p><ol><li>注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</li><li>外一种就是通过xml里面写SQL来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定，当SQL语句比较复杂时候，用xml绑定一般用xml绑定的比较多。</li></ol><h3 id="Mybatis是如何防止SQL注入的？"><a href="#Mybatis是如何防止SQL注入的？" class="headerlink" title="Mybatis是如何防止SQL注入的？"></a>Mybatis是如何防止SQL注入的？</h3><p>MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。</p><h3 id="最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h3><p>答：Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到 namespace 为<code>com.mybatis3.mappers.StudentDao</code>下面<code>id = findStudentById</code>的<code>MappedStatement</code>。在 Mybatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。</p><p>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p><p>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行<code>MappedStatement</code>所代表的 sql，然后将 sql 执行结果返回。</p><h3 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h3><p>答：Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：<code>select _ from student</code>，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p><h4 id="简述-Mybatis-的插件运行原理，以及如何编写一个插件？"><a href="#简述-Mybatis-的插件运行原理，以及如何编写一个插件？" class="headerlink" title="简述 Mybatis 的插件运行原理，以及如何编写一个插件？"></a>简述 Mybatis 的插件运行原理，以及如何编写一个插件？</h4><p>答：Mybatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现 Mybatis 的 Interceptor 接口并复写<code> intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><h3 id="Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>Mybatis 执行批量插入，能返回数据库主键列表吗？</h3><p>答：能，JDBC 都能，Mybatis 当然也能。</p><h3 id="Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h3><p>答：Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，Mybatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p><p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p><h3 id="Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>答：第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。</p><p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h3 id="Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h3><p>答：能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可；多对多查询，其实就是一对多查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可。</p><p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p><p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<code>&lt;resultMap&gt;</code>标签内的<code>&lt;id&gt;</code>子标签，指定了唯一确定一条记录的 id 列，Mybatis 根据列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code>可以有多个，代表了联合主键的语意。</p><p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p><p>举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，Mybatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t_id t_name s_id</span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> teacher <span class="operator">|</span> <span class="number">38</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> teacher <span class="operator">|</span> <span class="number">39</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> teacher <span class="operator">|</span> <span class="number">40</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> teacher <span class="operator">|</span> <span class="number">41</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> teacher <span class="operator">|</span> <span class="number">42</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> teacher <span class="operator">|</span> <span class="number">43</span> <span class="operator">|</span></span><br></pre></td></tr></table></figure><h3 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>答：Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p><p>它的原理是，使用<code> CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p><h3 id="Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h3><p>答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p><p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p><h3 id="Mybatis-中如何执行批处理？"><a href="#Mybatis-中如何执行批处理？" class="headerlink" title="Mybatis 中如何执行批处理？"></a>Mybatis 中如何执行批处理？</h3><p>答：使用 BatchExecutor 完成批处理。</p><h3 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><p>答：Mybatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p><p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p><p><strong>``ReuseExecutor`：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p><p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p><p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p><h3 id="Mybatis-中如何指定使用哪一种-Executor-执行器？"><a href="#Mybatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="Mybatis 中如何指定使用哪一种 Executor 执行器？"></a>Mybatis 中如何指定使用哪一种 Executor 执行器？</h3><p>答：在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p><h3 id="Mybatis-是否可以映射-Enum-枚举类？"><a href="#Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="Mybatis 是否可以映射 Enum 枚举类？"></a>Mybatis 是否可以映射 Enum 枚举类？</h3><p>答：Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>TypeHandler</code>，实现 <code>TypeHandler</code> 的 <code>setParameter()</code>和 <code>getResult()</code>接口方法。<code>TypeHandler</code> 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code>和 <code>getResult()</code>两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p><h3 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h3><p>答：虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。</p><p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h3 id="简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h3><p>答：Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 ParameterMapping 对象。<code>&lt;resultMap&gt;</code>标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 BoundSql 对象。</p><h3 id="为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h3><p>答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="OSI、TCP-IP、五层协议的体系结构"><a href="#OSI、TCP-IP、五层协议的体系结构" class="headerlink" title="OSI、TCP/IP、五层协议的体系结构"></a>OSI、TCP/IP、五层协议的体系结构</h3> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210628211717783.png" alt="image-20210628211717783" style="zoom: 50%;" /><p><strong>OSI分层 （7层）</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p><strong>TCP/IP分层（4层）</strong>：网络接口层、 网际层、运输层、 应用层。</p><p><strong>五层协议 （5层）</strong>：物理层、数据链路层、网络层、运输层、 应用层。</p><h3 id="每一层的作用"><a href="#每一层的作用" class="headerlink" title="每一层的作用"></a><strong>每一层的作用</strong></h3><ol><li><strong>物理层：</strong>通过媒介传输比特，确定机械及电气规范（比特Bit）。</li><li><strong>数据链路层</strong>：将比特组装成帧和点到点的传递（帧Frame）。</li><li><strong>网络层</strong>：负责数据包从源到宿的传递和网际互连（包PackeT）。</li><li><strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复（段Segment）。</li><li><strong>会话层</strong>：建立、管理和终止会话（会话协议数据单元SPDU）。</li><li><strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）。</li><li><strong>应用层</strong>：允许访问OSI环境的手段（应用协议数据单元APDU）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210628190305430.png" alt="image-20210628190305430"></p><h3 id="每一层的协议"><a href="#每一层的协议" class="headerlink" title="每一层的协议"></a><strong>每一层的协议</strong></h3><p><strong>物理层</strong>：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）。</p><p><strong>数据链路</strong>：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）。</p><p><strong>网络层</strong>：IP、ICMP、IP、ARP、NAT、RIP…</p><p><strong>传输层</strong>：TCP、UDP、SPX。</p><p><strong>会话层</strong>：NFS、SQL、NETBIOS、RPC。</p><p><strong>表示层</strong>：JPEG、MPEG、ASII。</p><p><strong>应用层常见协议：</strong></p><ul><li>FTP(21端口)：文件传输协议</li><li>SSH(22端口)：远程登陆</li><li>TELNET(23端口)：远程登录</li><li>SMTP(25端口)：发送邮件</li><li>POP3(110端口)：接收邮件</li><li>HTTP(80端口)：超文本传输协议</li><li>DNS(53端口)：运行在UDP上，域名解析服务。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/v2-2af488004591cbc12cd82c44518523de_r.jpg" alt="preview"></p><h3 id="路由器、交换机位于哪一层？"><a href="#路由器、交换机位于哪一层？" class="headerlink" title="路由器、交换机位于哪一层？"></a>路由器、交换机位于哪一层？</h3><ul><li>路由器网络层，根据IP地址进行寻址；</li><li>交换机数据链路层，根据MAC地址进行寻址。</li></ul><h2 id="传输层：TCP和UDP"><a href="#传输层：TCP和UDP" class="headerlink" title="传输层：TCP和UDP"></a>传输层：TCP和UDP</h2><h3 id="什么是三次握手-three-way-handshake-？"><a href="#什么是三次握手-three-way-handshake-？" class="headerlink" title="什么是三次握手 (three-way handshake)？"></a>什么是三次握手 (three-way handshake)？</h3><p>如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息： </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p><ul><li>客户端–发送带有 SYN 标志的数据包—一次握手–服务端；</li><li>服务端–发送带有 SYN/ACK 标志的数据包—二次握手–客户端；</li><li>客户端–发送带有带有 ACK 标志的数据包—三次握手–服务端。</li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191129101827556_21212.png" alt="三次握手" style="zoom:130%;" /><p><strong>详细说明：</strong></p><ul><li>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；</li><li>第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端，进入SYN_RCVD状态；</li><li>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器，进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</li></ul><h4 id="TCP建立连接可以两次握手吗？为什么"><a href="#TCP建立连接可以两次握手吗？为什么" class="headerlink" title="TCP建立连接可以两次握手吗？为什么?"></a>TCP建立连接可以两次握手吗？为什么?</h4><p><strong>不可以</strong>。有两个原因：</p><ol><li>可能会出现<strong>已失效的连接请求报文段又传到了服务器端</strong>。</li></ol><blockquote><p>client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p></blockquote><ol start="2"><li>两次握手<strong>无法保证Client正确接收第二次握手的报文</strong>（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。</li></ol><h4 id="可以采用四次握手吗？为什么？"><a href="#可以采用四次握手吗？为什么？" class="headerlink" title="可以采用四次握手吗？为什么？"></a>可以采用四次握手吗？为什么？</h4><p><strong>可以。但是会降低传输的效率。</strong></p><p>四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。</p><h4 id="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"><a href="#第三次握手中，如果客户端的ACK未送达服务器，会怎样？" class="headerlink" title="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"></a>第三次握手中，如果客户端的ACK未送达服务器，会怎样？</h4><p><strong>Server端：</strong> 由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。</p><p><strong>Client端，两种情况：</strong>  </p><ol><li>在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态  </li><li>在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。</li></ol><h4 id="如果已经建立了连接，但客户端出现了故障怎么办？"><a href="#如果已经建立了连接，但客户端出现了故障怎么办？" class="headerlink" title="如果已经建立了连接，但客户端出现了故障怎么办？"></a>如果已经建立了连接，但客户端出现了故障怎么办？</h4><p>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h4 id="初始序列号是什么？"><a href="#初始序列号是什么？" class="headerlink" title="初始序列号是什么？"></a>初始序列号是什么？</h4><p>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</p><h4 id="为什么要传回-SYN？"><a href="#为什么要传回-SYN？" class="headerlink" title="为什么要传回 SYN？"></a>为什么要传回 SYN？</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><blockquote><p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h4 id="传了-SYN-为啥还要传-ACK？"><a href="#传了-SYN-为啥还要传-ACK？" class="headerlink" title="传了 SYN,为啥还要传 ACK？"></a>传了 SYN,为啥还要传 ACK？</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p><h3 id="什么是四次挥手？"><a href="#什么是四次挥手？" class="headerlink" title="什么是四次挥手？"></a>什么是四次挥手？</h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191129112652915_15481.png" alt="四次挥手" style="zoom:130%;" /><ul><li>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server，进入FIN_WAIT_1状态；</li><li>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1，进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li><li>第三次挥手：Server将FIN置1，发送一个序列号给Client，进入LAST_ACK状态；</li><li>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器，服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。最终完成四次挥手。</li></ul><h4 id="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？"><a href="#为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？" class="headerlink" title="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？"></a>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</h4><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</p><h4 id="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的ACK没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</h4><p>客户端没有收到ACK确认，会重新发送FIN请求。</p><h4 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a>客户端TIME_WAIT状态的意义是什么？</h4><p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。</p><p>MSL(Maximum Segment Lifetime)：指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h3 id="TCP如何实现流量控制？"><a href="#TCP如何实现流量控制？" class="headerlink" title="TCP如何实现流量控制？"></a>TCP如何实现流量控制？</h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191129145400104_2106.png" alt="滑动窗口" style="zoom:80%;" /><p><strong>使用滑动窗口协议实现流量控制</strong>。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接收窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。</p><p>发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1615897397.gif" alt="滑动窗口" style="zoom:150%;" /><h4 id="什么是零窗口（接收窗口为0时会怎样）？"><a href="#什么是零窗口（接收窗口为0时会怎样）？" class="headerlink" title="什么是零窗口（接收窗口为0时会怎样）？"></a>什么是零窗口（接收窗口为0时会怎样）？</h4><p>如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。</p><h3 id="TCP的拥塞控制是怎么实现的？"><a href="#TCP的拥塞控制是怎么实现的？" class="headerlink" title="TCP的拥塞控制是怎么实现的？"></a>TCP的拥塞控制是怎么实现的？</h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191129153624025_28293.png" alt="拥塞控制" style="zoom:120%;" /><p>拥塞控制主要由四个算法组成：<strong>慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）</strong></p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/v2-1ba5604ea0b53cd252833aa4a0671962_r.jpg" alt="preview" style="zoom:80%;" /><ol><li>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191129155345024_11142.png" alt="slow start" style="zoom:120%;" /><ol start="2"><li><p>拥塞避免：当拥塞窗口的大小达到慢启动门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS。</p><blockquote><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2），然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<strong>（这是不使用快重传的情况）</strong></p></blockquote></li><li><p>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191129161026032_32431.png" alt="快重传" style="zoom:120%;" /><ol start="4"><li>快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。 </li></ol><p>  也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组，因此可以适当把拥塞窗口扩大些。</p><h3 id="TCP如何最大利用带宽？"><a href="#TCP如何最大利用带宽？" class="headerlink" title="TCP如何最大利用带宽？"></a>TCP如何最大利用带宽？</h3><p><strong>TCP速率受到三个因素影响：</strong></p><ul><li><p>窗口：即滑动窗口大小，见 TCP如何实现流量控制。</p></li><li><p>带宽：这里带宽是指单位时间内从发送端到接收端所能通过的“最高数据率”，是一种硬件限制。TCP发送端和接收端的数据传输数不可能超过两点间的带宽限制。发送端和接收端之间带宽取所通过线路的带宽最小值（如通过互联网连接）。</p></li><li><p>RTT：即Round Trip Time，表示从发送端到接收端的一去一回需要的时间，TCP在数据传输过程中会对RTT进行采样（即对发送的数据包及其ACK的时间差进行测量，并根据测量值更新RTT值），TCP根据得到的RTT值更新RTO值，即Retransmission TimeOut，就是重传间隔，发送端对每个发出的数据包进行计时，如果在RTO时间内没有收到所发出的数据包的对应ACK，则任务数据包丢失，将重传数据。一般RTO值都比采样得到的RTT值要大。</p><p> <strong>带宽时延乘积</strong></p></li><li><p>带宽时延乘积=带宽*RTT，实际上等于发送端到接收端单向通道的数据容积的两倍，这里单向通道的数据容积可以这样来理解，单向通道看成是一条单行道马路，带宽就是马路的车道数，路上跑的汽车就是数据（不过这里所有汽车的速率都是一样的，且不会有人想超车，大家齐头并进），那么单向通道的数据容积就是这条单行道上摆满车，一共可以摆多少辆。带宽就是马路的车道数，带宽数乘以单向通道的数据容积就是路面上所能容纳的全部数据量。当路面上已经摆满的时候，就不能再往里面放了</p></li><li><p>设滑动窗口大小为<img src="https://latex.codecogs.com/svg.latex?W">， 发送端和接收端的带宽为<img src="https://latex.codecogs.com/svg.latex?B">， RTT为<img src="https://latex.codecogs.com/svg.latex?T_r">。前面已经说过了，TCP发送数据时受滑动窗口的限制，当TCP将滑动窗口中的数据都发出后，在收到第一个ACK之前，滑动窗口大小是0，不能再发送数据了，必须等待ACK包使滑动窗口移动。那么在理想情况下，ACK包应该在什么时候到达呢？显然，就是在数据发出后的RTT时间后，ACK包到达。这也就是说，现在在不考虑丢包和拥塞情况下，TCP在一个RTT时间内能发出的最大数据量为 <img src="http://latex.codecogs.com/gif.latex?W"> ，所以不考虑带宽限制下，TCP能一个时刻能达到的最大速度是 <img src="https://latex.codecogs.com/svg.latex?V=%5Cfrac%7BW%7D%7BT_r%7D"></p></li><li><p>现在再考虑带宽限制，前面说过当马路上摆满车的时候，就无法再往里放车了，同理，TCP发送端在 <img src="https://latex.codecogs.com/svg.latex?%5Cfrac%7BT_r%7D%7B2%7D"> 时间内，能往通道上放的最大数据量为 <img src="https://latex.codecogs.com/svg.latex?%5Cfrac%7BV*T_r%7D%7B2%7D"> ，通过带宽时延乘积得到的容积限制为 <img src="https://latex.codecogs.com/svg.latex?%5Cfrac%7BB*T_r%7D%7B2%7D">。当 <img src="https://latex.codecogs.com/svg.latex?%5Cfrac%7BB*T_r%7D%7B2%7D%20%5Cgeq%20%5Cfrac%7BV*T_r%7D%7B2%7D"> 时，单向通道容积不构成瓶颈，速率的限制主要来源于窗口大小限制。而当 <img src="https://latex.codecogs.com/svg.latex?%5Cfrac%7BV*T_r%7D%7B2%7D%20%5Cgeq%20%5Cfrac%7BB*T_r%7D%7B2%7D"> 时，则就受到容积限制，即此时速率限制来源于带宽限制。因此，TCP的最大速率为 <img src="https://latex.codecogs.com/svg.latex?V%20=%20%5Cmin%7B(%5Cfrac%7BW%7D%7BT_r%7D,%20B)%7D"></p></li><li><p>在我们平时生活中使用的宽带网络，ADSL等环境下，因为带宽都比较小，从而 <img src="https://latex.codecogs.com/svg.latex?B*T_r"> 也比较小，再加上网络情况比较复杂，拥塞情况比较常见，所以这些网络环境下，TCP速率的主要限制因素在于带宽，丢包率等。长肥管道一般不太常见，多见于一些单位使用的专线网络，在这些网络中速率的主要限制因素就是窗口大小了，这也是传统TCP在这些网络环境中不能充分利用带宽的原因所在（因为传统TCP的窗口大小是用2字节表示的，所以最大只有65535（不考虑窗口扩大选项）），除了专线网络外，随着网络硬件技术的发展，万兆交换机的出现，局域网中也可能会出现带宽时延乘积较大的情况。</p></li></ul><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ol><li>TCP是面向连接的，UDP是无连接的；什么叫无连接？UDP发送数据之前不需要建立连接。</li><li>TCP是可靠的，UDP不可靠；UDP接收方收到报文后，不需要给出任何确认。</li><li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多。</li><li>TCP是面向字节流的，UDP是面向报文的。面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li><li>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏。</li><li>TCP首部开销（20字节）比UDP首部开销（8字节）要大。</li><li>UDP 的主机不需要维持复杂的连接状态表。</li></ol><h4 id="什么时候选择TCP，什么时候选UDP？"><a href="#什么时候选择TCP，什么时候选UDP？" class="headerlink" title="什么时候选择TCP，什么时候选UDP？"></a>什么时候选择TCP，什么时候选UDP？</h4><p>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失。</p><h4 id="HTTP可以使用UDP吗？"><a href="#HTTP可以使用UDP吗？" class="headerlink" title="HTTP可以使用UDP吗？"></a>HTTP可以使用UDP吗？</h4><p>HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠。</p><blockquote><p>注：<strong>http 3.0 使用udp实现。</strong></p></blockquote><h4 id="面向连接和无连接的区别"><a href="#面向连接和无连接的区别" class="headerlink" title="面向连接和无连接的区别"></a>面向连接和无连接的区别</h4><p><strong>无连接的网络服务（数据报服务）– 面向连接的网络服务（虚电路服务）</strong></p><p>虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；</p><p>数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化），网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃。</p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191201081919108_30577.png" alt="virtual circuit" style="zoom:80%;" /><h3 id="TCP如何保证传输的可靠性"><a href="#TCP如何保证传输的可靠性" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h3><ol><li><p>数据包校验。</p></li><li><p>对失序数据包重新排序（TCP报文具有序列号）。</p></li><li><p>丢弃重复数据。</p></li><li><p>应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）。</p></li><li><p>超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据。</p></li><li><p>流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出。</p></li></ol><h2 id="应用层：HTTP和HTTPS"><a href="#应用层：HTTP和HTTPS" class="headerlink" title="应用层：HTTP和HTTPS"></a>应用层：HTTP和HTTPS</h2><h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol><li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li><li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li><li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li><li>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买。</li></ol><h4 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a><strong>HTTP 协议包括哪些请求？</strong></h4><ul><li>GET：向特定的资源发出请求。</li><li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</li><li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li><li>HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</li><li>PUT：向指定资源位置上传其最新内容。</li><li>DELETE：请求服务器删除Request-URI所标识的资源。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li><li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li></ul><h4 id="HTTP1-0和HTTP1-1和HTTP2-0的区别"><a href="#HTTP1-0和HTTP1-1和HTTP2-0的区别" class="headerlink" title="HTTP1.0和HTTP1.1和HTTP2.0的区别"></a>HTTP1.0和HTTP1.1和HTTP2.0的区别</h4><p><strong>HTTP1.0和HTTP1.1的区别</strong></p><ol><li><strong>长连接</strong>： HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。</li><li><strong>节约带宽</strong>：  HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</li><li><strong>HOST域</strong>：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</li><li><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>错误通知的管理</strong>：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li></ol><p><strong>HTTP1.1和HTTP2.0的区别</strong></p><ol><li><p><strong>多路复用</strong>：HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20190730231346806.jpg" alt="img"></p></li><li><p><strong>头部数据压缩</strong>：  在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。 </p><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p></li><li><p><strong>服务器推送</strong>： 服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</p><p> 为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20190730231423477.jpg" alt="img"></p></li></ol><h4 id="Https的连接过程？"><a href="#Https的连接过程？" class="headerlink" title="Https的连接过程？"></a>Https的连接过程？</h4><ol><li>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</li><li>服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，<strong>加密公钥</strong>（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</li><li>客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</li><li>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个<strong>随机密钥</strong>（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行<strong>摘要</strong>计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</li><li>服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</li><li>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密。</li></ol><p><strong>总结</strong>：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。</p><h4 id="输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？"><a href="#输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？" class="headerlink" title="输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS？"></a>输入 <a href="http://www.baidu.com,怎么变成/">www.baidu.com，怎么变成</a> <a href="https://www.baidu.com/">https://www.baidu.com</a> 的，怎么确定用HTTP还是HTTPS？</h4><blockquote><p><a href="https://www.sohu.com/a/136637876_487516">你访问的网站是如何自动切换到 HTTPS 的？</a></p></blockquote><p>一种是原始的302跳转，服务器把所有的HTTP流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。<br>解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。</p><h4 id="什么是对称加密、非对称加密？区别是什么？"><a href="#什么是对称加密、非对称加密？区别是什么？" class="headerlink" title="什么是对称加密、非对称加密？区别是什么？"></a>什么是对称加密、非对称加密？区别是什么？</h4><ul><li>对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4。</li><li>非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA。</li><li>区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）。</li></ul><h4 id="数字签名、报文摘要的原理"><a href="#数字签名、报文摘要的原理" class="headerlink" title="数字签名、报文摘要的原理"></a>数字签名、报文摘要的原理</h4><ul><li>发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。</li><li>摘要算法：MD5、SHA。</li></ul><h3 id="GET与POST的区别？"><a href="#GET与POST的区别？" class="headerlink" title="GET与POST的区别？"></a>GET与POST的区别？</h3><ol><li>GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；</li><li>GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；</li><li>请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；</li><li>安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；</li><li>GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；</li><li>GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制。</li></ol><h3 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h3><ol><li><p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案；</p></li><li><p>Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）；</p></li><li><p>Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p></li><li><p>Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p></li><li><p>Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p></li><li><p>Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p></li></ol><h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><ol><li>浏览器查询 DNS，获取域名对应的IP地址：具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立连接，发起三次握手；</li><li>TCP/IP连接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h3 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h3><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用。</li></ol><h3 id="什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？"><a href="#什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？" class="headerlink" title="什么是RIP (Routing Information Protocol,距离矢量路由协议)? 算法是什么？"></a>什么是RIP (Routing Information Protocol,距离矢量路由协议)? 算法是什么？</h3><p>每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。</p><blockquote><p>（PS：RIP是应用层协议：<a href="https://www.zhihu.com/question/19645407">https://www.zhihu.com/question/19645407</a>）</p></blockquote><p><strong>优缺点：</strong></p><ul><li>实现简单，开销小；</li><li>随着网络规模扩大开销也会增大；</li><li>最大距离为15，限制了网络的规模；</li><li>当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器。</li></ul><h2 id="网络层：IP"><a href="#网络层：IP" class="headerlink" title="网络层：IP"></a>网络层：IP</h2><h3 id="IP地址的分类？"><a href="#IP地址的分类？" class="headerlink" title="IP地址的分类？"></a>IP地址的分类？</h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191201085151639_2895.png" alt="IP address" style="zoom:50%;" /><p>路由器仅根据网络号net-id来转发分组，当分组到达目的网络（局域网编号）的路由器之后，再按照主机号host-id将分组交付给主机（局域网中真实主机id）；同一网络上的所有主机的网络号相同。</p><h3 id="什么叫划分子网？"><a href="#什么叫划分子网？" class="headerlink" title="什么叫划分子网？"></a>什么叫划分子网？</h3><p>从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网，将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。即通过目标地址与子网掩码进行与运算找到目的子网。</p><h3 id="什么是ARP协议-Address-Resolution-Protocol-？"><a href="#什么是ARP协议-Address-Resolution-Protocol-？" class="headerlink" title="什么是ARP协议 (Address Resolution Protocol)？"></a>什么是ARP协议 (Address Resolution Protocol)？</h3><ul><li><p><strong>ARP协议完成了IP地址与物理地址的映射</strong>。每一个主机都设有一个 ARP 高速缓存，里面有<strong>所在的局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。</p></li><li><p>当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向<strong>所在的局域网</strong>发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。</p></li><li><p>源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。</p></li><li><p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。</p></li></ul><h3 id="什么是NAT-Network-Address-Translation-网络地址转换-？"><a href="#什么是NAT-Network-Address-Translation-网络地址转换-？" class="headerlink" title="什么是NAT (Network Address Translation, 网络地址转换)？"></a>什么是NAT (Network Address Translation, 网络地址转换)？</h3><p>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> HTTP </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2021/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="进程和线程有什么区别？"><a href="#进程和线程有什么区别？" class="headerlink" title="进程和线程有什么区别？"></a>进程和线程有什么区别？</h2><ul><li>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；</li><li>线程依赖于进程而存在，一个进程至少有一个线程；</li><li>进程有自己的独立地址空间，线程共享所属进程的地址空间；</li><li>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；</li><li>在进程切换时，涉及到整个当前进程CPU环境的保存、环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</li><li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮。</li></ul><blockquote><p>进程操作代码实现，可以参考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064">多进程 - 廖雪峰的官方网站</a></p></blockquote><h3 id="同一进程中的线程可以共享哪些数据？"><a href="#同一进程中的线程可以共享哪些数据？" class="headerlink" title="同一进程中的线程可以共享哪些数据？"></a>同一进程中的线程可以共享哪些数据？</h3><ul><li>进程代码段</li><li>进程的公有数据（全局变量、静态变量…）</li><li>进程打开的文件描述符</li><li>进程的当前目录</li><li>信号处理器/信号处理函数：对收到的信号的处理方式</li><li>进程ID与进程组ID</li></ul><h3 id="线程独占哪些资源？"><a href="#线程独占哪些资源？" class="headerlink" title="线程独占哪些资源？"></a>线程独占哪些资源？</h3><ul><li>线程ID</li><li>一组寄存器的值</li><li>线程自身的栈（堆是共享的）</li><li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改</li><li>信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</li></ul><h2 id="进程间通信有哪些方式？"><a href="#进程间通信有哪些方式？" class="headerlink" title="进程间通信有哪些方式？"></a>进程间通信有哪些方式？</h2><ol><li><p><strong>管道(Pipe)</strong></p><ul><li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li><li>一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；</li><li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)。</li></ul></li><li><p><strong>命名管道</strong></p></li><li><p><strong>消息队列</strong></p></li><li><p><strong>信号(Signal)</strong></p></li><li><p><strong>共享内存</strong></p></li><li><p>**信号量(Semaphore)**：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态。</p></li><li><p>**套接字(Socket)**：IP+端口号。</p></li></ol><h2 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h2><p><strong>管程 Monitor</strong></p><p>管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。</p><p>当一个进程试图进入管程时，在<strong>入口等待队列</strong>等待。若P进程唤醒了Q进程，则Q进程先执行，P在<strong>紧急等待队列</strong>中等待。（<strong>HOARE管程</strong>）</p><ol><li><p>wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；</p></li><li><p>signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（<strong>HOARE管程</strong>）</p></li></ol><p><strong>MESA管程</strong>：将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。优点：没有额外的进程切换。</p><p><strong>生产者-消费者问题</strong></p><blockquote><p>问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据。</p></blockquote><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述 </span></span><br><span class="line"><span class="comment">// 定义信号量 full记录缓冲区物品数量 empty代表缓冲区空位数量 mutex为互斥量</span></span><br><span class="line">semaphore full = <span class="number">0</span>, empty = n, mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">     P(empty);</span><br><span class="line">  P(mutex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 生产者进行生产</span></span><br><span class="line">   </span><br><span class="line">     V(mutex);</span><br><span class="line">     V(full);</span><br><span class="line"> &#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  P(full);</span><br><span class="line">  P(mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者进行消费</span></span><br><span class="line"></span><br><span class="line">  V(mutex);</span><br><span class="line">  V(empty);</span><br><span class="line"> &#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哲学家就餐问题</strong></p><blockquote><p>问题描述：有五位哲学家围绕着餐桌坐，每一位哲学家要么思考，要么吃饭。为了吃饭，哲学家必须拿起两双筷子（分别放于左右两端）不幸的是，筷子的数量和哲学家相等，所以每只筷子必须由两位哲学家共享。</p></blockquote><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5  <span class="comment">// number of philosopher</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1)%N <span class="comment">// number of i&#x27;s left neighbors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1)%N <span class="comment">// number of i&#x27;s right neighbors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING 2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N]; <span class="comment">// array to keep track of everyone&#x27;s state</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// mutual exclusion of critical region</span></span><br><span class="line">semaphore s[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">think();</span><br><span class="line">take_forks(i);</span><br><span class="line">eat();</span><br><span class="line">put_forks(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_forks</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">down(&amp;mutex); <span class="comment">// enter critical region</span></span><br><span class="line">state[i] = HUNGRY; <span class="comment">// record that i is hungry</span></span><br><span class="line">test_forks(i); <span class="comment">// try to acquire two forks</span></span><br><span class="line">up(&amp;mutex); <span class="comment">// exit critical region</span></span><br><span class="line">down(&amp;s[i]); <span class="comment">// block if forks are not acquired</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_forks</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">down(&amp;mutex); <span class="comment">// enter critical region</span></span><br><span class="line">state[i] = THINKING; <span class="comment">// record that has finished eating</span></span><br><span class="line">test_forks(LEFT); <span class="comment">// see if left neighbor can now eat</span></span><br><span class="line">test_forks(RIGHT); <span class="comment">// see if right neighbor can now eat</span></span><br><span class="line">up(&amp;mutex); <span class="comment">// exit critical region</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_forks</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) &#123;</span><br><span class="line">state[i] = EATING;</span><br><span class="line">up(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读者-写者问题</strong></p><h3 id="临界区的概念？"><a href="#临界区的概念？" class="headerlink" title="临界区的概念？"></a>临界区的概念？</h3><p>各个进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段。</p><h3 id="同步与互斥的概念？"><a href="#同步与互斥的概念？" class="headerlink" title="同步与互斥的概念？"></a>同步与互斥的概念？</h3><ul><li>同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="并发、并行、异步的区别？"><a href="#并发、并行、异步的区别？" class="headerlink" title="并发、并行、异步的区别？"></a>并发、并行、异步的区别？</h3><ul><li><p>并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的。</p></li><li><p>多线程：并发运行的一段代码。是实现异步的手段。</p></li><li><p>并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的。</p></li><li><p>异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事。</p></li></ul><h2 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191202090217863_1873.png" alt="Process State"></p><ul><li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源。</li><li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数。</li><li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行。</li></ul><h2 id="进程调度策略有哪些？"><a href="#进程调度策略有哪些？" class="headerlink" title="进程调度策略有哪些？"></a>进程调度策略有哪些？</h2><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a><strong>批处理系统</strong></h3><p><strong>1. 先来先服务 first-come first-serverd（FCFS）</strong></p><ul><li><p>按照请求的顺序进行调度。</p></li><li><p>非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）。</p></li><li><p>对短进程不利，对IO密集型进程不利。</p></li></ul><p><strong>2. 最短作业优先 shortest job first（SJF）</strong></p><ul><li><p>按估计运行时间最短的顺序进行调度。</p></li><li><p>非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题。</p></li><li><p>对短进程提供好的响应时间，对长进程不利。</p></li></ul><p><strong>3. 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p><ul><li><p>按剩余运行时间的顺序进行调度。(最短作业优先的抢占式版本)。</p></li><li><p>吞吐量高，开销可能较大，提供好的响应时间。</p></li><li><p>可能导致饥饿问题，对长进程不利。</p></li></ul><p><strong>4. 最高响应比优先 Highest Response Ratio Next（HRRN）</strong></p><ul><li>响应比 = 1+ 等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。</li><li>非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。</li></ul><h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a><strong>交互式系统</strong></h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><p><strong>1. 时间片轮转 Round Robin</strong></p><ul><li>将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。</li><li>抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间。</li><li>若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。</li></ul><p><strong>2. 优先级调度算法</strong></p><ul><li>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</li></ul><p><strong>3. 多级反馈队列调度算法 Multilevel Feedback Queue</strong></p><ul><li><p>设置多个就绪队列1、2、3…，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。</p></li><li><p>抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。</p></li></ul><h3 id="什么叫优先级反转？如何解决？"><a href="#什么叫优先级反转？如何解决？" class="headerlink" title="什么叫优先级反转？如何解决？"></a>什么叫优先级反转？如何解决？</h3><p>高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。</p><p>此处详细解释优先级反转带来的问题：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。</p><p>解决方法：</p><ul><li>优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。</li><li>优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。</li></ul><h2 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h2><p>一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。</p><p>僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。</p><p><strong>危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。</strong></p><p>以下情况不会产生僵尸进程：</p><ul><li>该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。</li><li>父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入<code>WNOHANG</code>(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程。</li><li>子进程结束时，系统会产生<code>SIGCHLD</code>(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）。</li><li>也可以用<code>signal(SIGCLD, SIG_IGN)</code>(signal-ignore)通知内核，表示忽略<code>SIGCHLD</code>信号，那么子进程结束后，内核会进行回收。</li></ul><h3 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h3><p>一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。</p><h2 id="线程同步有哪些方式？"><a href="#线程同步有哪些方式？" class="headerlink" title="线程同步有哪些方式？"></a>线程同步有哪些方式？</h2><blockquote><p>为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。</p></blockquote><ul><li><strong>互斥量</strong> Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源。</li><li><strong>信号量</strong> Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了<strong>最大资源计数</strong>和<strong>当前可用资源计数</strong>，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过<code>ReleaseSemaphore</code>函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量。</li><li><strong>事件</strong> Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒<strong>所有</strong>等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒<strong>一个</strong>等待中的线程，然后自动恢复为未激发状态。</li><li><strong>临界区</strong> Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</li></ul><h3 id="互斥量和临界区有什么区别？"><a href="#互斥量和临界区有什么区别？" class="headerlink" title="互斥量和临界区有什么区别？"></a>互斥量和临界区有什么区别？</h3><p>互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。</p><h2 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h2><p>协程是一种<strong>用户态的轻量级线程</strong>，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><h3 id="协程多与线程进行比较？"><a href="#协程多与线程进行比较？" class="headerlink" title="协程多与线程进行比较？"></a>协程多与线程进行比较？</h3><ol><li><p>一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</p></li><li><p>线程进程都是同步机制，而协程则是异步</p></li><li><p>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p></li></ol><h2 id="进程的异常控制流：陷阱、中断、异常和信号"><a href="#进程的异常控制流：陷阱、中断、异常和信号" class="headerlink" title="进程的异常控制流：陷阱、中断、异常和信号"></a>进程的异常控制流：陷阱、中断、异常和信号</h2><ol><li><p>陷阱是<strong>有意</strong>造成的“异常”，是执行一条指令的结果。陷阱是同步的。陷阱的主要作用是实现<strong>系统调用</strong>。比如，进程可以执行 <code>syscall n</code> 指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，<strong>陷入</strong>到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行<strong>下一条指令</strong>。</p></li><li><p>中断由处理器<strong>外部</strong>的<strong>硬件</strong>产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。</p></li><li><p>异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。这里特指因为执行当前指令而产生的<strong>错误情况</strong>，比如除法异常、缺页异常等。有些书上为了区分，也将这类“异常”称为<strong>“故障”</strong>。</p></li><li><p>信号是一种<strong>更高层的</strong>软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来<strong>通知进程</strong>发生了某种系统事件。</p></li></ol><blockquote><p>更详细的可以参考：<a href="https://imageslr.github.io/2020/07/09/trap-interrupt-exception.html">https://imageslr.github.io/2020/07/09/trap-interrupt-exception.html</a></p></blockquote><h2 id="什么是IO多路复用？怎么实现？"><a href="#什么是IO多路复用？怎么实现？" class="headerlink" title="什么是IO多路复用？怎么实现？"></a>什么是IO多路复用？怎么实现？</h2><p>IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。</p><p><strong>实现原理</strong>：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。</p><h3 id="select-poll-epoll三者的区别？"><a href="#select-poll-epoll三者的区别？" class="headerlink" title="select/poll/epoll三者的区别？"></a><strong>select/poll/epoll三者的区别？</strong></h3><ul><li><code>select</code>：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，<strong>开销大</strong>），由内核根据就绪状态修改该集合的内容。（缺点2）<strong>集合大小有限制</strong>，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：<strong>轮询的方式效率较低</strong>），当文件描述符的数量增加时，效率会线性下降；</li><li><code>poll</code>：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制。</li><li><code>epoll</code>：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。</li></ul><p><strong>总结，区别主要在于：</strong></p><ul><li>一个线程/进程所能打开的最大连接数</li><li>文件描述符传递方式（是否复制）</li><li>水平触发 or 边缘触发</li><li>查询就绪的描述符时的效率（是否轮询）</li></ul><h3 id="什么时候使用select-poll，什么时候使用epoll？"><a href="#什么时候使用select-poll，什么时候使用epoll？" class="headerlink" title="什么时候使用select/poll，什么时候使用epoll？"></a><strong>什么时候使用select/poll，什么时候使用epoll？</strong></h3><p>当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。</p><h3 id="什么是文件描述符？"><a href="#什么是文件描述符？" class="headerlink" title="什么是文件描述符？"></a>什么是文件描述符？</h3><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><p><strong>内核通过文件描述符来访问文件。文件描述符指向一个文件。</strong></p><h3 id="什么是水平触发？什么是边缘触发？"><a href="#什么是水平触发？什么是边缘触发？" class="headerlink" title="什么是水平触发？什么是边缘触发？"></a>什么是水平触发？什么是边缘触发？</h3><ul><li>水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知。</li><li>边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。</li><li>区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。</li><li>为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。</li></ul><h3 id="有哪些常见的IO模型？"><a href="#有哪些常见的IO模型？" class="headerlink" title="有哪些常见的IO模型？"></a>有哪些常见的IO模型？</h3><ul><li>同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够。</li><li>同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源。</li><li>IO多路复用</li><li>异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。</li></ul><h2 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h2><p>为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。</p><ul><li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；</li><li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li></ul><p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用<strong>陷阱指令</strong>，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p><h3 id="为什么要分用户态和内核态？"><a href="#为什么要分用户态和内核态？" class="headerlink" title="为什么要分用户态和内核态？"></a>为什么要分用户态和内核态？</h3><p>（我自己的见解：）</p><ul><li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；</li><li>封装性：用户程序不需要实现更加底层的代码；</li><li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度，统一交给操作系统调度更加方便。</li></ul><h3 id="如何从用户态切换到内核态？"><a href="#如何从用户态切换到内核态？" class="headerlink" title="如何从用户态切换到内核态？"></a>如何从用户态切换到内核态？</h3><ul><li>系统调用：比如读取命令行输入。本质上还是通过中断实现。</li><li>用户程序发生异常时：比如缺页异常。</li><li>外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li></ul><h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。</p><h3 id="死锁产生的必要条件？"><a href="#死锁产生的必要条件？" class="headerlink" title="死锁产生的必要条件？"></a>死锁产生的必要条件？</h3><ul><li><strong>互斥</strong>：一个资源一次只能被一个进程使用；</li><li><strong>占有并等待</strong>：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；</li><li><strong>非抢占</strong>：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；</li><li><strong>循环等待</strong>：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h3 id="死锁有哪些处理方法？"><a href="#死锁有哪些处理方法？" class="headerlink" title="死锁有哪些处理方法？"></a>死锁有哪些处理方法？</h3><p><strong>鸵鸟策略</strong></p><p>直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p><strong>死锁预防</strong></p><p>基本思想是破坏形成死锁的四个必要条件：</p><ul><li>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；</li><li>破坏占有并等待条件：<ul><li>实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；</li><li>或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；</li><li>缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性。</li></ul></li><li>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；</li><li>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。</li></ul><p><strong>死锁避免</strong></p><p>动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</p><blockquote><p>银行家算法</p></blockquote><p><strong>死锁解除</strong></p><blockquote><p>如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。</p></blockquote><p>死锁解除的方法：</p><ul><li>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</li><li>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；</li><li>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。</li></ul><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><strong>概念</strong></p><p>银行家算法（ banker’s algorithm ）由 Dijkstra于1965提出，关键是将死锁的问题演示为一个银行家贷款的模型，由于能用于银行系统的现金贷款而出名。一个银行家向一群客户发放信用卡，每个客户有不同的信用额度。每个客户可以提出信用额度内的任意额度的请求，直到额度用完后再一次性还款。银行家承诺每个客户最终都能获得自己需要的额度。所谓“最终”，是说银行家可以先挂起某个额度请求较大的客户的请求，优先满足小额度的请求，等小额度的请求还款后，再处理挂起的请求。这样，资金能够永远流通。所以银行家算法其核心是：保证银行家系统的资源数至少不小于一个客户的所需要的资源数。</p><p><strong>算法原理</strong></p><p>银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。每分配一次资源就测试一次是否安全，不是资源全部就位后才测试，注意理解checkError函数的循环顺序。</p><p>​    我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。 为保证资金的安全，银行家规定：</p><ol><li>当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客(试探性分配)；</li><li>顾客可以分期贷款，但贷款的总数不能超过最大需求量(可能一次并不能满足所需要的全部资源)；</li><li>当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款(不存在死锁)</li><li>当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金(运行后释放)。</li></ol><p>操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能存在安全状态，则按当前的申请量分配资源，否则也要推迟分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span>: <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">  <span class="number">2</span>: <span class="keyword">import</span> javax.swing.JOptionPane;</span><br><span class="line">  <span class="number">3</span>: </span><br><span class="line">  <span class="number">4</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banker</span> </span>&#123;</span><br><span class="line">  <span class="number">5</span>: </span><br><span class="line">  <span class="number">6</span>:   <span class="comment">/*</span></span><br><span class="line"><span class="comment">  7:    * 资源向量必须全部设置成static，因为可能</span></span><br><span class="line"><span class="comment">  8:    * 同一个线程多次输入才满足条件</span></span><br><span class="line"><span class="comment">  9:    */</span></span><br><span class="line"> <span class="number">10</span>:   <span class="comment">//每个线程需要的资源数</span></span><br><span class="line"> <span class="number">11</span>:   <span class="keyword">static</span> <span class="keyword">int</span> max[][] = &#123; &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span> &#125;, &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span> &#125;, &#123; <span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span> &#125;,</span><br><span class="line"> <span class="number">12</span>:     &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125;, &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span> &#125; &#125;;</span><br><span class="line"> <span class="number">13</span>:   <span class="comment">//系统可用资源数</span></span><br><span class="line"> <span class="number">14</span>:   <span class="keyword">static</span> <span class="keyword">int</span> avaliable[] = &#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"> <span class="number">15</span>:   <span class="comment">//已经分配资源</span></span><br><span class="line"> <span class="number">16</span>:   <span class="keyword">static</span> <span class="keyword">int</span> allocation[][] = &#123; &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line"> <span class="number">17</span>:     &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line"> <span class="number">18</span>:   <span class="comment">//每个进程还需要的资源数,初试一个资源也没分配；实际上应该等于max-avaliable</span></span><br><span class="line"> <span class="number">19</span>:   <span class="keyword">static</span> <span class="keyword">int</span> need[][] = Arrays.copyOf(max,max.length);</span><br><span class="line"> <span class="number">20</span>:   <span class="comment">//每次申请的资源数</span></span><br><span class="line"> <span class="number">21</span>:   <span class="keyword">static</span> <span class="keyword">int</span> request[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"> <span class="number">22</span>:   <span class="comment">//NUM个线程，N种资源</span></span><br><span class="line"> <span class="number">23</span>:   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">5</span>, N = <span class="number">3</span>;</span><br><span class="line"> <span class="number">24</span>:   <span class="keyword">static</span> Function function = <span class="keyword">new</span> Function();</span><br><span class="line"> <span class="number">25</span>:   </span><br><span class="line"> <span class="number">26</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="number">27</span>:     JOptionPane jpane = <span class="keyword">new</span> JOptionPane();</span><br><span class="line"> <span class="number">28</span>:     </span><br><span class="line"> <span class="number">29</span>:     <span class="comment">//是否进行模拟标志，没有布尔，因为从JOpotionpane输入</span></span><br><span class="line"> <span class="number">30</span>:     <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"> <span class="number">31</span>:     </span><br><span class="line"> <span class="number">32</span>:     <span class="keyword">while</span>(<span class="number">1</span>==flag) &#123;</span><br><span class="line"> <span class="number">33</span>:       <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 34:        * 用与判断线程号是否合法</span></span><br><span class="line"><span class="comment"> 35:        * 需要放在while内部，防止下次继续模拟时i还是上次输入的</span></span><br><span class="line"><span class="comment"> 36:        */</span></span><br><span class="line"> <span class="number">37</span>:       <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"> <span class="number">38</span>:       <span class="keyword">while</span>(i&lt;<span class="number">0</span>||i&gt;=NUM) &#123;</span><br><span class="line"> <span class="number">39</span>:         String str = jpane.showInputDialog(<span class="string">&quot;输入申请资源的线程号(0到4)：&quot;</span>);</span><br><span class="line"> <span class="number">40</span>:         i = Integer.parseInt(str);</span><br><span class="line"> <span class="number">41</span>:         <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=NUM) &#123;</span><br><span class="line"> <span class="number">42</span>:           JOptionPane.showMessageDialog(jpane, <span class="string">&quot;输入的线程号不合法！！！&quot;</span>);</span><br><span class="line"> <span class="number">43</span>:         &#125;</span><br><span class="line"> <span class="number">44</span>:       &#125;</span><br><span class="line"> <span class="number">45</span>:       <span class="comment">//资源输入有效性标志</span></span><br><span class="line"> <span class="number">46</span>:       <span class="keyword">boolean</span> tag = <span class="keyword">true</span>; </span><br><span class="line"> <span class="number">47</span>:       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123;</span><br><span class="line"> <span class="number">48</span>:         String str = jpane.showInputDialog(<span class="string">&quot;输入线程&quot;</span>+i+<span class="string">&quot;所申请的资源&quot;</span>+j+<span class="string">&quot;数目：&quot;</span>);</span><br><span class="line"> <span class="number">49</span>:         request[j] = Integer.parseInt(str);</span><br><span class="line"> <span class="number">50</span>:         <span class="comment">//有效性检查</span></span><br><span class="line"> <span class="number">51</span>:         <span class="keyword">if</span>(request[j]&gt;need[i][j]) &#123;</span><br><span class="line"> <span class="number">52</span>:           JOptionPane.showMessageDialog(jpane, <span class="string">&quot;输入的资源数大于需要资源数！！！&quot;</span>);</span><br><span class="line"> <span class="number">53</span>:           tag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">54</span>:           <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">55</span>:         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">56</span>:           <span class="keyword">if</span>(request[j]&gt;avaliable[j]) &#123;</span><br><span class="line"> <span class="number">57</span>:             JOptionPane.showMessageDialog(jpane, <span class="string">&quot;输入的资源数大于可用资源数！！！&quot;</span>);</span><br><span class="line"> <span class="number">58</span>:             tag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">59</span>:             <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">60</span>:           &#125;</span><br><span class="line"> <span class="number">61</span>:         &#125;</span><br><span class="line"> <span class="number">62</span>:       &#125;</span><br><span class="line"> <span class="number">63</span>:       <span class="comment">//是否存在安全序列</span></span><br><span class="line"> <span class="number">64</span>:       <span class="keyword">boolean</span> vis = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">65</span>:       <span class="keyword">if</span>(tag) &#123;</span><br><span class="line"> <span class="number">66</span>:         function.allocateK(i);</span><br><span class="line"> <span class="number">67</span>:         vis = function.checkError(i);</span><br><span class="line"> <span class="number">68</span>:         <span class="keyword">if</span>(<span class="keyword">false</span>==vis) &#123;</span><br><span class="line"> <span class="number">69</span>:           <span class="comment">//上面调用了allocateK，所以不仅需要释放，还需要恢复</span></span><br><span class="line"> <span class="number">70</span>:           function.freeKAndRestore(i);</span><br><span class="line"> <span class="number">71</span>:         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">72</span>:           <span class="comment">//测试是否全部资源到位</span></span><br><span class="line"> <span class="number">73</span>:           <span class="keyword">boolean</span> f = function.checkRun(i);</span><br><span class="line"> <span class="number">74</span>:           <span class="keyword">if</span>(<span class="keyword">true</span>==f) &#123;</span><br><span class="line"> <span class="number">75</span>:             JOptionPane.showMessageDialog(jpane</span><br><span class="line"> <span class="number">76</span>:                 ,<span class="string">&quot;进程&quot;</span>+i+<span class="string">&quot;全部资源到位！！！&quot;</span>+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;即将释放所占用资源&quot;</span>);</span><br><span class="line"> <span class="number">77</span>:             function.freeKNotRestore(i);</span><br><span class="line"> <span class="number">78</span>:           &#125;</span><br><span class="line"> <span class="number">79</span>:         &#125;</span><br><span class="line"> <span class="number">80</span>:       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">81</span>:         <span class="comment">//实际上没必要清空，因为该数组是输入的，只为了展示一种良好习惯</span></span><br><span class="line"> <span class="number">82</span>:         Arrays.fill(request,<span class="number">0</span>);</span><br><span class="line"> <span class="number">83</span>:       &#125;</span><br><span class="line"> <span class="number">84</span>:       String str = JOptionPane.showInputDialog(<span class="string">&quot;是否继续模拟(1表示是，0退出)？&quot;</span>);</span><br><span class="line"> <span class="number">85</span>:       flag = Integer.parseInt(str);</span><br><span class="line"> <span class="number">86</span>:     &#125;</span><br><span class="line"> <span class="number">87</span>:   &#125;</span><br><span class="line"> <span class="number">88</span>: &#125;</span><br><span class="line"> <span class="number">89</span>: </span><br><span class="line"> <span class="number">90</span>: <span class="class"><span class="keyword">class</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line"> <span class="number">91</span>:   <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 92:    * 实际上完全是静态的，没必要新new一个Banker</span></span><br><span class="line"><span class="comment"> 93:    */</span></span><br><span class="line"> <span class="number">94</span>:   Banker banker = <span class="keyword">new</span> Banker();</span><br><span class="line"> <span class="number">95</span>:   <span class="comment">//为线程k分配资源</span></span><br><span class="line"> <span class="number">96</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allocateK</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"> <span class="number">97</span>:     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;banker.N; i++) &#123;</span><br><span class="line"> <span class="number">98</span>:       banker.avaliable[i] -= banker.request[i];</span><br><span class="line"> <span class="number">99</span>:       banker.need[k][i] -= banker.request[i];</span><br><span class="line"><span class="number">100</span>:       banker.allocation[k][i] += banker.request[i];</span><br><span class="line"><span class="number">101</span>:     &#125;</span><br><span class="line"><span class="number">102</span>:   &#125;</span><br><span class="line"><span class="number">103</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkError</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="number">104</span>:     <span class="keyword">int</span> work = <span class="number">0</span>;</span><br><span class="line"><span class="number">105</span>:     <span class="comment">//存储所有线程是否安全</span></span><br><span class="line"><span class="number">106</span>:     <span class="keyword">boolean</span>[] finish = <span class="keyword">new</span> <span class="keyword">boolean</span>[banker.NUM];</span><br><span class="line"><span class="number">107</span>:     Arrays.fill(finish,<span class="keyword">false</span>);</span><br><span class="line"><span class="number">108</span>:     <span class="comment">//存储一个安全序列</span></span><br><span class="line"><span class="number">109</span>:     <span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[banker.NUM];</span><br><span class="line"><span class="number">110</span>:     Arrays.fill(temp,<span class="number">0</span>);</span><br><span class="line"><span class="number">111</span>:     <span class="comment">//temp数组下标</span></span><br><span class="line"><span class="number">112</span>:     <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="number">113</span>:     </span><br><span class="line"><span class="number">114</span>:     <span class="comment">//线程号参数是i</span></span><br><span class="line"><span class="number">115</span>:     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;banker.N; j++) &#123;</span><br><span class="line"><span class="number">116</span>:       work = banker.avaliable[j];</span><br><span class="line"><span class="number">117</span>:       <span class="keyword">int</span> k = i;</span><br><span class="line"><span class="number">118</span>:       </span><br><span class="line"><span class="number">119</span>:       <span class="keyword">while</span>(k&lt;banker.NUM) &#123;</span><br><span class="line"><span class="number">120</span>:         <span class="keyword">if</span>(finish[k]==<span class="keyword">false</span>&amp;&amp;work&gt;=banker.need[k][j]) &#123;</span><br><span class="line"><span class="number">121</span>:           <span class="comment">/*</span></span><br><span class="line"><span class="comment">122:            *  注意不是max数组，因为此时线程k</span></span><br><span class="line"><span class="comment">123:            *  所需资源不一定完全就位</span></span><br><span class="line"><span class="comment">124:            *  加的是allocation，因为进行此项检查前先试探性地</span></span><br><span class="line"><span class="comment">125:            *  分配给线程k资源了</span></span><br><span class="line"><span class="comment">126:            */</span></span><br><span class="line"><span class="number">127</span>:           <span class="comment">//满足该线程，回收该项资源，看是否满足其它线程</span></span><br><span class="line"><span class="number">128</span>:           work += banker.allocation[k][j];</span><br><span class="line"><span class="number">129</span>:           finish[k] = <span class="keyword">true</span>;</span><br><span class="line"><span class="number">130</span>:           temp[t++] = k;</span><br><span class="line"><span class="number">131</span>:           k = <span class="number">0</span>;</span><br><span class="line"><span class="number">132</span>:           </span><br><span class="line"><span class="number">133</span>:         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">134</span>:           k++;</span><br><span class="line"><span class="number">135</span>:         &#125;</span><br><span class="line"><span class="number">136</span>:       &#125;</span><br><span class="line"><span class="number">137</span>:       <span class="comment">//和while平级</span></span><br><span class="line"><span class="number">138</span>:       <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;banker.NUM; p++) &#123;</span><br><span class="line"><span class="number">139</span>:         <span class="keyword">if</span>(finish[p]==<span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="number">140</span>:           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">141</span>:         &#125;</span><br><span class="line"><span class="number">142</span>:       &#125;</span><br><span class="line"><span class="number">143</span>:     &#125;</span><br><span class="line"><span class="number">144</span>:     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">145</span>:   &#125;</span><br><span class="line"><span class="number">146</span>:   <span class="comment">//释放线程k所占用资源并恢复</span></span><br><span class="line"><span class="number">147</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeKAndRestore</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="number">148</span>:     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;banker.N; i++) &#123;</span><br><span class="line"><span class="number">149</span>:       banker.avaliable[i] += banker.request[i];</span><br><span class="line"><span class="number">150</span>:       banker.need[k][i] += banker.request[i];</span><br><span class="line"><span class="number">151</span>:       banker.allocation[k][i] -= banker.request[i];</span><br><span class="line"><span class="number">152</span>:     &#125;</span><br><span class="line"><span class="number">153</span>:   &#125;</span><br><span class="line"><span class="number">154</span>:   <span class="comment">//仅仅释放线程k所占用资源，仅在某线程全部得到资源运行后才调用</span></span><br><span class="line"><span class="number">155</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeKNotRestore</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="number">156</span>:     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;banker.N; i++) &#123;</span><br><span class="line"><span class="number">157</span>:       banker.avaliable[i] = banker.avaliable[i] + banker.allocation[k][i];</span><br><span class="line"><span class="number">158</span>:     &#125;</span><br><span class="line"><span class="number">159</span>:   &#125;</span><br><span class="line"><span class="number">160</span>:   <span class="comment">//三种资源是否全部到位</span></span><br><span class="line"><span class="number">161</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkRun</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="number">162</span>:     <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="number">163</span>:     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;banker.N; i++) &#123;</span><br><span class="line"><span class="number">164</span>:       <span class="keyword">if</span> (banker.need[k][i] == <span class="number">0</span>)</span><br><span class="line"><span class="number">165</span>:         n++;</span><br><span class="line"><span class="number">166</span>:     &#125;</span><br><span class="line"><span class="number">167</span>:     <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line"><span class="number">168</span>:       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">169</span>:     <span class="keyword">else</span></span><br><span class="line"><span class="number">170</span>:       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">171</span>:   &#125;</span><br><span class="line"><span class="number">172</span>: &#125;</span><br></pre></td></tr></table></figure><h2 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h2><ul><li>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻。</li><li>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻。</li><li>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li></ul><p><strong>区别：</strong></p><ul><li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</li><li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</li><li>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；</li><li>分段便于信息的保护和共享；分页的共享受到限制；</li><li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）。</li></ul><h2 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h2><p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存，但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p><p>虚拟内存的优点是让程序可以获得更多的可用内存。</p><p>虚拟内存的实现方式、页表/多级页表、缺页中断、不同的页面淘汰算法：<a href="https://imageslr.github.io/2020/07/08/tech-interview.html#virtual-memory">答案</a>。</p><h3 id="如何进行地址空间到物理内存的映射？"><a href="#如何进行地址空间到物理内存的映射？" class="headerlink" title="如何进行地址空间到物理内存的映射？"></a>如何进行地址空间到物理内存的映射？</h3><p><strong>内存管理单元</strong>（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）。每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。</p><h3 id="有哪些页面置换算法？"><a href="#有哪些页面置换算法？" class="headerlink" title="有哪些页面置换算法？"></a>有哪些页面置换算法？</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><ul><li><strong>最佳页面置换算法</strong>OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略。</li><li><strong>先进先出</strong>FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高。</li><li><strong>第二次机会算法</strong>SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0。</li><li><strong>时钟算法</strong> Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销。</li><li><strong>最近未使用算法</strong>NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）。</li><li><strong>最近最少使用算法</strong>LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</li><li><strong>最不经常使用算法</strong>NFU：置换出访问次数最少的页面。</li></ul><p><strong>局部性原理</strong></p><ul><li>时间上：最近被访问的页在不久的将来还会被访问；</li><li>空间上：内存中被访问的页周围的页也很可能被访问。</li></ul><p><strong>什么是颠簸现象</strong></p><p>颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：</p><ul><li>修改页面置换算法；</li><li>降低同时运行的程序的数量；</li><li>终止该进程或增加物理内存容量。</li></ul><h2 id="缓冲区溢出问题"><a href="#缓冲区溢出问题" class="headerlink" title="缓冲区溢出问题"></a>缓冲区溢出问题</h2><h3 id="什么是缓冲区溢出？"><a href="#什么是缓冲区溢出？" class="headerlink" title="什么是缓冲区溢出？"></a>什么是缓冲区溢出？</h3><p>C 语言使用运行时栈来存储过程信息。每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。C 对于数组引用不进行任何边界检查，因此<strong>对越界的数组元素的写操作会破坏存储在栈中的状态信息</strong>，这种现象称为缓冲区溢出。缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。</p><h3 id="缓冲区溢出的防范方式"><a href="#缓冲区溢出的防范方式" class="headerlink" title="缓冲区溢出的防范方式"></a>缓冲区溢出的防范方式</h3><p>防范缓冲区溢出攻击的机制有三种：随机化、栈保护和限制可执行代码区域。</p><ul><li>随机化：包括栈随机化（程序开始时在栈上分配一段随机大小的空间）和地址空间布局随机化（Address-Space Layout Randomization，ASLR，即每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域），但只能增加攻击一个系统的难度，不能完全保证安全。</li><li>栈保护：在每个函数的栈帧的局部变量和栈状态之间存储一个<strong>随机产生的</strong>特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。</li><li>限制可执行代码区域：内存页的访问形式有三种：可读、可写、可执行，只有编译器产生的那部分代码所处的内存才是可执行的，其他页限制为只允许读和写。</li></ul><blockquote><p>更详细的可以参考：<a href="https://imageslr.github.io/2020/07/08/tech-interview.html#stackoverflow">https://imageslr.github.io/2020/07/08/tech-interview.html#stackoverflow</a></p></blockquote><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：</p><ul><li>先来先服务</li><li>最短寻道时间优先</li><li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级—常用工具、日志、复制、综合案例</title>
      <link href="2021/04/08/MySQL%E9%AB%98%E7%BA%A7%E2%80%94%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/"/>
      <url>2021/04/08/MySQL%E9%AB%98%E7%BA%A7%E2%80%94%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL中常用工具"><a href="#MySQL中常用工具" class="headerlink" title="MySQL中常用工具"></a>MySQL中常用工具</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>该mysql不是指mysql服务，而是指mysql的客户端工具。语法 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql [options] [database]</span><br></pre></td></tr></table></figure><h4 id="连接选项"><a href="#连接选项" class="headerlink" title="连接选项"></a>连接选项</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数 ： </span><br><span class="line">-u, --user=name指定用户名</span><br><span class="line">-p, --password[=name]指定密码</span><br><span class="line">-h, --host=name指定服务器IP或域名</span><br><span class="line">-P, --port=#指定连接端口</span><br><span class="line"></span><br><span class="line">示例 ：</span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p</span><br><span class="line"></span><br><span class="line">mysql -h127.0.0.1 -P3306 -uroot -p123456</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="执行选项"><a href="#执行选项" class="headerlink" title="执行选项"></a>执行选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-e, --execute&#x3D;name执行SQL语句并退出</span><br></pre></td></tr></table></figure><p>此选项可以在MySQL客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：mysql -uroot -p123456 test -e &quot;select * from tb_book&quot;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519192733031.png" alt="image-20210519192733031" style="zoom: 67%;" /><h3 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h3><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><p>可以通过 ： mysqladmin –help  指令查看帮助文档 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 ：</span><br><span class="line">mysqladmin -uroot -p123456 create &#x27;test01&#x27;;  </span><br><span class="line">mysqladmin -uroot -p123456 drop &#x27;test01&#x27;;</span><br><span class="line">mysqladmin -uroot -p123456 version;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519193244305.png" alt="image-20210519193244305" style="zoom: 67%;" /><h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h3><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p><p>语法 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [options]  log-files1 log-files2 ...</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-d, --database=name : 指定数据库名称，只列出指定的数据库相关操作。</span><br><span class="line"></span><br><span class="line">-o, --offset=# : 忽略掉日志中的前n行命令。</span><br><span class="line"></span><br><span class="line">-r,--result-file=name : 将输出的文本格式日志输出到指定文件。</span><br><span class="line"></span><br><span class="line">-s, --short-form : 显示简单格式， 省略掉一些信息。</span><br><span class="line"></span><br><span class="line">--start-datatime=date1  --stop-datetime=date2 : 指定日期间隔内的所有日志。</span><br><span class="line"></span><br><span class="line">--start-position=pos1 --stop-position=pos2 : 指定位置间隔内的所有日志。</span><br></pre></td></tr></table></figure><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p><p>语法 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line"></span><br><span class="line">mysqldump [options] --database/-B db1 [db2 db3...]</span><br><span class="line"></span><br><span class="line">mysqldump [options] --all-databases/-A</span><br></pre></td></tr></table></figure><h4 id="连接选项-1"><a href="#连接选项-1" class="headerlink" title="连接选项"></a>连接选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数 ： </span><br><span class="line">-u, --user&#x3D;name指定用户名</span><br><span class="line">-p, --password[&#x3D;name]指定密码</span><br><span class="line">-h, --host&#x3D;name指定服务器IP或域名</span><br><span class="line">-P, --port&#x3D;#指定连接端口</span><br></pre></td></tr></table></figure><h4 id="输出内容选项"><a href="#输出内容选项" class="headerlink" title="输出内容选项"></a>输出内容选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">--add-drop-database在每个数据库创建语句前加上 Drop database 语句</span><br><span class="line">--add-drop-table在每个表创建语句前加上 Drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table)</span><br><span class="line"></span><br><span class="line">-n, --no-create-db不包含数据库的创建语句</span><br><span class="line">-t, --no-create-info不包含数据表的创建语句</span><br><span class="line">-d --no-data不包含数据</span><br><span class="line"></span><br><span class="line"> -T, --tab&#x3D;name自动生成两个文件：一个.sql文件，创建表结构的语句；</span><br><span class="line"> 一个.txt文件，数据文件，相当于select into outfile  </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 ： </span><br><span class="line">mysqldump -uroot -p123456 test tb_book --add-drop-database --add-drop-table &gt; a</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p123456 -T /tmp test city</span><br></pre></td></tr></table></figure><h3 id="mysqlimport-source"><a href="#mysqlimport-source" class="headerlink" title="mysqlimport/source"></a>mysqlimport/source</h3><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport [options]  db_name  textfile1  [textfile2...]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：mysqlimport -uroot -p123456 test /tmp/city.txt</span><br></pre></td></tr></table></figure><p>如果需要导入sql文件,可以使用mysql中的source 指令 : </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /root/tb_book.sql</span><br></pre></td></tr></table></figure><h3 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h3><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlshow [options] [db_name [table_name [col_name]]]</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--count显示数据库及表的统计信息（数据库，表 均可以不指定）</span><br><span class="line"></span><br><span class="line">-i显示指定数据库或者指定表的状态信息</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查询每个数据库的表的数量及表中记录的数量</span></span><br><span class="line">mysqlshow -uroot -p123456 --count</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查询<span class="built_in">test</span>库中每个表中的字段书，及行数</span></span><br><span class="line">mysqlshow -uroot -p123456 test --count</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查询<span class="built_in">test</span>库中book表的详细情况</span></span><br><span class="line">mysqlshow -uroot -p123456 test book --count</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519192733031.png" alt="image-20210519192733031" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519192627476.png" alt="image-20210519192627476" style="zoom:80%;" /><h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h2><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件。MySQL也不例外，在MySQL中，有 4 种不同的日志，分别是错误日志、二进制日志（BINLOG 日志）、查询日志和慢查询日志，这些日志记录着数据库在不同方面的踪迹。</p><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录, 默认的日志文件名为  hostname.err（hostname是主机名）。</p><p>查看日志位置指令 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name       <span class="operator">|</span> <span class="keyword">Value</span>                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> log_error           <span class="operator">|</span> .\LAPTOP<span class="number">-6</span>SEJGOUJ.err <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_error_verbosity <span class="operator">|</span> <span class="number">3</span>                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.09</span> sec)</span><br></pre></td></tr></table></figure><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。 </p><p>配置文件位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入MySQL的数据目录：</p><ul><li><p>Windows：C:\ProgramData\MySQL\MySQL Server 5.7\my.ini  </p></li><li><p>Linux：/usr/my.cnf</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002</span><br><span class="line">log_bin=mysqlbin</span><br><span class="line"></span><br><span class="line">#配置二进制日志的格式</span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><p><strong>STATEMENT</strong></p><p>该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过MySQL提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。</p><p><strong>ROW</strong></p><p>该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status=’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。</p><p><strong>MIXED</strong></p><p>这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。</p><h4 id="日志读取"><a href="#日志读取" class="headerlink" title="日志读取"></a>日志读取</h4><p>由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog log-file；</span><br></pre></td></tr></table></figure><p><strong>查看STATEMENT格式日志</strong> </p><p>执行插入语句 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Lucene&#x27;</span>,<span class="string">&#x27;2088-05-01&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><p> 查看日志文件 ：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519192007729.png" alt="image-20210519192007729"> </p><p>mysqlbin.index : 该文件是日志索引文件 ， 记录日志的文件名；而mysqlbing.000001 ：日志文件。</p><p>查看日志内容 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog mysqlbing.000001;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1554080016778.png" alt="1554080016778"> </p><p><strong>查看ROW格式日志</strong></p><p>配置 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002</span><br><span class="line">log_bin&#x3D;mysqlbin</span><br><span class="line"></span><br><span class="line">#配置二进制日志的格式</span><br><span class="line">binlog_format&#x3D;ROW</span><br></pre></td></tr></table></figure><p>插入数据 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;SpringCloud实战&#x27;</span>,<span class="string">&#x27;2088-05-05&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果日志格式是 ROW , 直接查看数据 , 是看不懂的 ; 可以在mysqlbinlog 后面加上参数 -vv  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>vv mysqlbin<span class="number">.000002</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1554095452022.png" alt="1554095452022"> </p><h4 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a>日志删除</h4><p>对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清楚，将会占用大量的磁盘空间。下面我们将会讲解几种删除日志的常见方法 ：</p><p><strong>方式一</strong> </p><p>通过 Reset Master 指令删除全部 binlog 日志，删除之后，日志编号，将从 xxxx.000001重新开始 。</p><p>执行删除日志指令： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reset Master</span><br></pre></td></tr></table></figure><p><strong>方式二</strong></p><p>执行指令 <code> purge  master logs to &#39;mysqlbin.******&#39;</code> ，该命令将删除  <code> ******</code> 编号之前的所有日志。 </p><p><strong>方式三</strong></p><p>执行指令 <code> purge master logs before &#39;yyyy-mm-dd hh24:mi:ss&#39;</code> ，该命令将删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志 。</p><p><strong>方式四</strong></p><p>设置参数 –expire_logs_days=# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。</p><p>配置如下 ： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_bin=mysqlbin</span><br><span class="line"></span><br><span class="line">binlog_format=ROW</span><br><span class="line"></span><br><span class="line">expire_logs_days=3 </span><br></pre></td></tr></table></figure><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 </span><br><span class="line">general_log=1</span><br><span class="line"></span><br><span class="line">#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log </span><br><span class="line">general_log_file=file_name</span><br></pre></td></tr></table></figure><p>在 mysql 的配置文件中配置如下内容 ： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#开启查询日志</span><br><span class="line">general-log=1</span><br><span class="line"></span><br><span class="line">#配置查询日志的文件名</span><br><span class="line">general_log_file=&quot;mysql_query.log&quot;</span><br></pre></td></tr></table></figure><p>配置完毕之后，在数据库执行以下操作 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">update tb_book <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;lucene入门指南&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>执行完毕之后， 再次来查询日志文件 ： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld.exe, Version: 5.7.32-log (MySQL Community Server (GPL)). started with:</span><br><span class="line">TCP Port: 3306, Named Pipe: (null)</span><br><span class="line">Time                 Id Command    Argument</span><br><span class="line">2021-05-19T12:19:36.603915Z    2 Connectroot@localhost on test using TCP&#x2F;IP</span><br><span class="line">2021-05-19T12:19:36.604924Z    2 QuerySET NAMES utf8mb4</span><br><span class="line">2021-05-19T12:19:36.605342Z    2 Init DBtest</span><br><span class="line">2021-05-19T12:19:36.607604Z    2 Queryselect * from tb_book</span><br><span class="line">2021-05-19T12:19:36.779978Z    2 Init DBtest</span><br><span class="line">2021-05-19T12:19:36.780489Z    2 Queryselect * from tb_book where id &#x3D; 1</span><br><span class="line">2021-05-19T12:19:36.919822Z    2 Init DBtest</span><br><span class="line">2021-05-19T12:19:36.956204Z    2 Queryupdate tb_book set name &#x3D; &#39;lucene入门指南&#39; where id &#x3D; 5</span><br><span class="line">2021-05-19T12:19:37.017167Z    2 Init DBtest</span><br><span class="line">2021-05-19T12:19:37.017970Z    2 Queryselect * from tb_book where id &lt; 8</span><br></pre></td></tr></table></figure><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。</p><h4 id="文件位置和格式"><a href="#文件位置和格式" class="headerlink" title="文件位置和格式"></a>文件位置和格式</h4><p>慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭</span><br><span class="line">slow_query_log=1 </span><br><span class="line"></span><br><span class="line"># 该参数用来指定慢查询日志的文件名</span><br><span class="line">slow_query_log_file=slow_query.log</span><br><span class="line"></span><br><span class="line"># 该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10s</span><br><span class="line">long_query_time=10</span><br></pre></td></tr></table></figure><h4 id="日志的读取"><a href="#日志的读取" class="headerlink" title="日志的读取"></a>日志的读取</h4><p>和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。</p><p>1） 查询long_query_time 的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.13</span> sec)</span><br></pre></td></tr></table></figure><p>2） 执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> title <span class="keyword">like</span> <span class="string">&#x27;%阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待165454%&#x27;</span> ;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1554130532577.png" alt="1554130532577"  /> <p>该SQL语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。</p><p>3） 查看慢查询日志文件</p><p>直接查询该日志文件 ： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519203330362.png" alt="image-20210519203330362"  /> <p>如果慢查询日志内容很多， 直接查看文件，比较麻烦， 这个时候可以借助于mysql自带的 mysqldumpslow 工具， 来对慢查询日志进行分类汇总。 </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519203426832.png" alt="image-20210519203426832" style="zoom:150%;" /> <h2 id="MySQL复制"><a href="#MySQL复制" class="headerlink" title="MySQL复制"></a>MySQL复制</h2><h3 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h3><p>复制是指将主数据库的 DDL和DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。</p><h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><p>MySQL 的主从复制原理如下。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519203834829.png" alt="image-20210519203834829"> </p><p>从上层来看，复制分成三步：</p><ul><li><p>Master主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。</p></li><li><p>主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log 。</p></li><li><p>slave重做中继日志中的事件，将改变反映给它自己的数据。</p></li></ul><h3 id="复制优势"><a href="#复制优势" class="headerlink" title="复制优势"></a>复制优势</h3><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li><p>主库出现问题，可以快速切换到从库提供服务。</p></li><li><p>可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。</p></li><li><p>可以在从库中执行备份，以避免备份期间影响主库的服务。</p></li></ul><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>1） 在master 的配置文件（/usr/my.cnf 或者 my.ini）中，配置如下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql 服务ID,保证整个集群环境中唯一</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql binlog 日志的存储路径和文件名 下面以Linux系统为例</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">/var/lib/mysql/mysqlbin </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#错误日志,默认已经开启</span></span><br><span class="line"><span class="comment">#log-err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的安装目录</span></span><br><span class="line"><span class="comment">#basedir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的临时目录</span></span><br><span class="line"><span class="comment">#tmpdir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的数据存放目录</span></span><br><span class="line"><span class="comment">#datadir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否只读,1 代表只读, 0 代表读写</span></span><br><span class="line"><span class="meta">read-only</span>=<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#忽略的数据, 指不需要同步的数据库</span></span><br><span class="line"><span class="meta">binlog-ignore-db</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-do-db=db01</span></span><br></pre></td></tr></table></figure><p>2） 执行完毕之后，需要重启Mysql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart ;</span><br></pre></td></tr></table></figure><p>3） 创建同步数据的账户，并且进行授权操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;mysql&#x27;</span>@<span class="string">&#x27;192.168.192.131&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>4） 查看master状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1554477759735.png" alt="1554477759735"> </p><p>字段含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File : 从哪个日志文件开始推送日志文件 </span><br><span class="line">Position ： 从哪个位置开始推送日志</span><br><span class="line">Binlog_Ignore_DB : 指定不需要同步的数据库</span><br></pre></td></tr></table></figure><h4 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h4><p>1） 在 slave 端配置文件中，配置如下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql服务端ID,唯一</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定binlog日志</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">/var/lib/mysql/mysqlbin</span></span><br></pre></td></tr></table></figure><p>2）  执行完毕之后，需要重启Mysql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart;</span><br></pre></td></tr></table></figure><p>3） 执行如下指令 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span> <span class="string">&#x27;192.168.192.130&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>, master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>, master_log_file<span class="operator">=</span><span class="string">&#x27;mysqlbin.000001&#x27;</span>, master_log_pos<span class="operator">=</span><span class="number">413</span>;</span><br></pre></td></tr></table></figure><p>指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。</p><p>4） 开启同步操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br><span class="line"></span><br><span class="line">show slave status;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519204321826.png" alt="image-20210519204321826"> </p><p>5） 停止同步操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure><h4 id="验证同步操作"><a href="#验证同步操作" class="headerlink" title="验证同步操作"></a>验证同步操作</h4><p>1） 在主库中创建数据库，创建表，并插入数据 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">user</span> db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">primary</span> key (id)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>2） 在从库中查询数据，进行验证 ：</p><p>在从库中，可以查看到刚才创建的数据库：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1554544658640.png" alt="1554544658640"> </p><p>在该数据库中，查询user表中的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1554544679538.png" alt="1554544679538"> </p><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>在业务系统中，需要记录当前业务系统的访问日志，该访问日志包含：操作人，操作时间，访问类，访问方法，请求参数，请求结果，请求结果类型，请求时长 等信息。记录详细的系统访问日志，主要便于对系统中的用户请求进行追踪，并且在系统 的管理后台可以查看到用户的访问记录。</p><p>记录系统中的日志信息，可以通过Spring 框架的AOP来实现。具体的请求处理流程，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523213639350.png" alt="image-20210523213639350"></p><h3 id="搭建案例环境"><a href="#搭建案例环境" class="headerlink" title="搭建案例环境"></a>搭建案例环境</h3><h4 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE mysql_demo <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 ；</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `brand` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;品牌名称&#x27;</span>,</span><br><span class="line">  `first_char` <span class="type">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;品牌首字母&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `item` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品id&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品标题&#x27;</span>,</span><br><span class="line">  `price` <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品价格，单位为：元&#x27;</span>,</span><br><span class="line">  `num` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存数量&#x27;</span>,</span><br><span class="line">  `categoryid` <span class="type">bigint</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;所属类目，叶子类目&#x27;</span>,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品状态，1-正常，2-下架，3-删除&#x27;</span>,</span><br><span class="line">  `sellerid` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商家ID&#x27;</span>,</span><br><span class="line">  `createtime` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updatetime` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `birthday` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `qq` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `operation_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  `operate_class` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作类&#x27;</span>,</span><br><span class="line">  `operate_method` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作方法&#x27;</span>,</span><br><span class="line">  `return_class` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;返回值类型&#x27;</span>,</span><br><span class="line">  `operate_user` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作用户&#x27;</span>,</span><br><span class="line">  `operate_time` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  `param_and_value` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;请求参数名及参数值&#x27;</span>,</span><br><span class="line">  `cost_time` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;执行方法耗时, 单位 ms&#x27;</span>,</span><br><span class="line">  `return_value` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;返回值&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 解决post乱码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>log-datalist.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="db-properties"><a href="#db-properties" class="headerlink" title="db.properties"></a>db.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://192.168.142.128:3306/mysql_demo</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">itcast</span></span><br></pre></td></tr></table></figure><h4 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 spring 创建容器时要扫描的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">context:exclude-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 MyBatis 的 Session 工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.pojo&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 Mapper 扫描器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务的注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="springmvc-xml"><a href="#springmvc-xml" class="headerlink" title="springmvc.xml"></a>springmvc.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast.controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="导入基础工程"><a href="#导入基础工程" class="headerlink" title="导入基础工程"></a>导入基础工程</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523213609159.png" alt="image-20210523213609159"></p><h3 id="通过AOP记录操作日志"><a href="#通过AOP记录操作日志" class="headerlink" title="通过AOP记录操作日志"></a>通过AOP记录操作日志</h3><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>通过自定义注解，来标示方法需不需要进行记录日志，如果该方法在访问时需要记录日志，则在该方法上标示该注解既可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OperateLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义通知类"><a href="#定义通知类" class="headerlink" title="定义通知类"></a>定义通知类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateAdvice</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Logger log = Logger.getLogger(OperateAdvice.class);</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OperationLogService operationLogService;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;execution(* cn.itcast.controller.*.*(..)) &amp;&amp; @annotation(operateLog)&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">insertLogAround</span><span class="params">(ProceedingJoinPoint pjp , OperateLog operateLog)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; ************************ 记录日志 [start]  ****************************** &quot;</span>);</span><br><span class="line">      </span><br><span class="line">      OperationLog op = <span class="keyword">new</span> OperationLog();</span><br><span class="line">      </span><br><span class="line">      DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">      op.setOperateTime(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">      op.setOperateUser(DataUtils.getRandStr(<span class="number">8</span>));</span><br><span class="line">      </span><br><span class="line">      op.setOperateClass(pjp.getTarget().getClass().getName());</span><br><span class="line">      op.setOperateMethod(pjp.getSignature().getName());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取方法调用时传递的参数</span></span><br><span class="line">      Object[] args = pjp.getArgs();</span><br><span class="line">      op.setParamAndValue(Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> start_time = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//放行</span></span><br><span class="line">      Object object = pjp.proceed();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> end_time = System.currentTimeMillis();</span><br><span class="line">      op.setCostTime(end_time - start_time);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(object != <span class="keyword">null</span>)&#123;</span><br><span class="line">         op.setReturnClass(object.getClass().getName());</span><br><span class="line">         op.setReturnValue(object.toString());</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         op.setReturnClass(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">         op.setParamAndValue(<span class="string">&quot;void&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      log.error(JsonUtils.obj2JsonString(op));</span><br><span class="line"></span><br><span class="line">      operationLogService.insert(op);</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">&quot; ************************** 记录日志 [end]  *************************** &quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法上加注解"><a href="#方法上加注解" class="headerlink" title="方法上加注解"></a>方法上加注解</h4><p>在需要记录日志的方法上加上注解@OperateLog。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OperateLog</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/insert&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">insert</span><span class="params">(<span class="meta">@RequestBody</span> Brand brand)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        brandService.insert(brand);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,<span class="string">&quot;操作成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志查询后端代码实现"><a href="#日志查询后端代码实现" class="headerlink" title="日志查询后端代码实现"></a>日志查询后端代码实现</h2><h4 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperationLogMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(OperationLog operationLog)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;OperationLog&gt; <span class="title">selectListByCondition</span><span class="params">(Map dataMap)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">countByCondition</span><span class="params">(Map dataMap)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mapper-xml-映射配置文件"><a href="#Mapper-xml-映射配置文件" class="headerlink" title="Mapper.xml 映射配置文件"></a>Mapper.xml 映射配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.itcast.mapper.OperationLogMapper&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;operationLog&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO operation_log(id,return_value,return_class,operate_user,operate_time,param_and_value,</span><br><span class="line">        operate_class,operate_method,cost_time)</span><br><span class="line">      VALUES(NULL,#&#123;returnValue&#125;,#&#123;returnClass&#125;,#&#123;operateUser&#125;,#&#123;operateTime&#125;,#&#123;paramAndValue&#125;,</span><br><span class="line">        #&#123;operateClass&#125;,#&#123;operateMethod&#125;,#&#123;costTime&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;operationLog&quot;</span>&gt;</span></span><br><span class="line">      select</span><br><span class="line">        id ,</span><br><span class="line">        operate_class as operateClass ,</span><br><span class="line">        operate_method as operateMethod,</span><br><span class="line">        return_class as returnClass,</span><br><span class="line">        operate_user as operateUser,</span><br><span class="line">        operate_time as operateTime,</span><br><span class="line">        param_and_value as paramAndValue,</span><br><span class="line">        cost_time as costTime,</span><br><span class="line">        return_value as returnValue</span><br><span class="line">      from operation_log</span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;oplog_where&quot;</span>/&gt;</span></span><br><span class="line">      limit #&#123;start&#125;,#&#123;size&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select count(*) from operation_log</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;oplog_where&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;oplog_where&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;operateClass != null and operateClass != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                and operate_class = #&#123;operateClass&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;operateMethod != null and operateMethod != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                and operate_method = #&#123;operateMethod&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;returnClass != null and returnClass != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                and return_class = #&#123;returnClass&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;costTime != null&quot;</span>&gt;</span></span><br><span class="line">                and cost_time =  #&#123;costTime&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationLogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static Logger logger = Logger.getLogger(OperationLogService.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OperationLogMapper operationLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(OperationLog operationLog)</span></span>&#123;</span><br><span class="line">        operationLogMapper.insert(operationLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据条件查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageResult <span class="title">selectListByCondition</span><span class="params">(Map dataMap, Integer pageNum , Integer pageSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(paramMap ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            paramMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        &#125;</span><br><span class="line">        paramMap.put(<span class="string">&quot;start&quot;</span> , (pageNum-<span class="number">1</span>)*rows);</span><br><span class="line">        paramMap.put(<span class="string">&quot;rows&quot;</span>,rows);</span><br><span class="line"></span><br><span class="line">        Object costTime = paramMap.get(<span class="string">&quot;costTime&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(costTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(costTime.toString()))&#123;</span><br><span class="line">                paramMap.put(<span class="string">&quot;costTime&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                paramMap.put(<span class="string">&quot;costTime&quot;</span>,<span class="keyword">new</span> Long(paramMap.get(<span class="string">&quot;costTime&quot;</span>).toString()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(dataMap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> countStart = System.currentTimeMillis();</span><br><span class="line">        Long count = operationLogMapper.countByCondition(dataMap);</span><br><span class="line">        <span class="keyword">long</span> countEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Count Cost Time : &quot;</span> + (countEnd-countStart)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;OperationLog&gt; list = operationLogMapper.selectListByCondition(dataMap);</span><br><span class="line">        <span class="keyword">long</span> queryEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Query Cost Time : &quot;</span> + (queryEnd-countEnd)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageResult(count,list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/operationLog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationLogController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OperationLogService operationLogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findList&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageResult <span class="title">findList</span><span class="params">(<span class="meta">@RequestBody</span> Map dataMap, Integer pageNum , Integer pageSize)</span></span>&#123;</span><br><span class="line">        PageResult page = operationLogService.selectListByCondition(dataMap, pageNum, pageSize);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志查询前端代码实现"><a href="#日志查询前端代码实现" class="headerlink" title="日志查询前端代码实现"></a>日志查询前端代码实现</h2><p>前端代码使用 BootStrap + AdminLTE 进行布局， 使用Vuejs 进行视图层展示。</p><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line">           dataList:[],</span><br><span class="line">           searchEntity:&#123;</span><br><span class="line"><span class="javascript">               operateClass:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">               operateMethod:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">               returnClass:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">               costTime:<span class="string">&#x27;&#x27;</span></span></span><br><span class="line">           &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">           page: <span class="number">1</span>,  <span class="comment">//显示的是哪一页</span></span></span><br><span class="line"><span class="javascript">           pageSize: <span class="number">10</span>, <span class="comment">//每一页显示的数据条数</span></span></span><br><span class="line"><span class="javascript">           total: <span class="number">150</span>, <span class="comment">//记录总数</span></span></span><br><span class="line"><span class="javascript">           maxPage:<span class="number">8</span>  <span class="comment">//最大页数</span></span></span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line"><span class="javascript">           pageHandler: <span class="function"><span class="keyword">function</span> (<span class="params">page</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.page = page;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.search();</span></span><br><span class="line">           &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">           search: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.showLoading();</span></span><br><span class="line"><span class="javascript">               axios.post(<span class="string">&#x27;/operationLog/findList.do?pageNum=&#x27;</span> + _this.page + <span class="string">&quot;&amp;pageSize=&quot;</span> + _this.pageSize, _this.searchEntity).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line">                   if (response) &#123;</span><br><span class="line">                       _this.dataList = response.data.dataList;</span><br><span class="line">                       _this.total = response.data.total;</span><br><span class="line">                       _this.hideLoading();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">           showLoading: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">               $(<span class="string">&#x27;#loadingModal&#x27;</span>).modal(&#123;<span class="attr">backdrop</span>: <span class="string">&#x27;static&#x27;</span>, <span class="attr">keyboard</span>: <span class="literal">false</span>&#125;);</span></span><br><span class="line">           &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">           hideLoading: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">               $(<span class="string">&#x27;#loadingModal&#x27;</span>).modal(<span class="string">&#x27;hide&#x27;</span>);</span></span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">       created:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">           <span class="built_in">this</span>.pageHandler(<span class="number">1</span>);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="列表数据展示"><a href="#列表数据展示" class="headerlink" title="列表数据展示"></a>列表数据展示</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;item in dataList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.operateClass&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.operateMethod&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.returnClass&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.returnValue&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.operateUser&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.operateTime&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.costTime&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn bg-olive btn-xs&quot;</span>&gt;</span>详情<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn bg-olive btn-xs&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zpagenav</span> <span class="attr">v-bind:page</span>=<span class="string">&quot;page&quot;</span> <span class="attr">v-bind:page-size</span>=<span class="string">&quot;pageSize&quot;</span> <span class="attr">v-bind:total</span>=<span class="string">&quot;total&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">v-bind:max-page</span>=<span class="string">&quot;maxPage&quot;</span>  <span class="attr">v-on:pagehandler</span>=<span class="string">&quot;pageHandler&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">zpagenav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="联调测试"><a href="#联调测试" class="headerlink" title="联调测试"></a>联调测试</h3><p>可以通过postman来访问业务系统，再查看数据库中的日志信息，验证能不能将用户的访问日志记录下来。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523213448735.png" alt="image-20210523213448735"></p><h3 id="分析性能问题"><a href="#分析性能问题" class="headerlink" title="分析性能问题"></a>分析性能问题</h3><p>系统中用户访问日志的数据量，随着时间的推移，这张表的数据量会越来越大，因此我们需要根据业务需求，来对日志查询模块的性能进行优化。</p><p>1） 分页查询优化：由于在进行日志查询时，是进行分页查询，那也就意味着，在查看时，至少需要查询两次：</p><ol><li><p>查询符合条件的总记录数。–&gt; count 操作</p></li><li><p>查询符合条件的列表数据。–&gt; 分页查询 limit 操作</p></li></ol><p>通常来说，count() 都需要扫描大量的行（意味着需要访问大量的数据）才能获得精确的结果，因此是很难对该SQL进行优化操作的。如果需要对count进行优化，可以采用另外一种思路，可以增加汇总表，或者redis缓存来专门记录该表对应的记录数，这样的话，就可以很轻松的实现汇总数据的查询，而且效率很高，但是这种统计并不能保证百分之百的准确 。对于数据库的操作，“快速、精确、实现简单”，三者永远只能满足其二，必须舍掉其中一个。</p><p>2） 条件查询优化：针对于条件查询,需要对查询条件,及排序字段建立索引。</p><p>3） 读写分离：通过主从复制集群，来完成读写分离，使写操作走主节点， 而读操作，走从节点。</p><p>4） MySQL服务器优化</p><p>5） 应用优化</p><h3 id="性能优化-分页"><a href="#性能优化-分页" class="headerlink" title="性能优化 - 分页"></a>性能优化 - 分页</h3><h4 id="优化count"><a href="#优化count" class="headerlink" title="优化count"></a>优化count</h4><p>创建一张表用来记录日志表的总数据量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> log_counter(</span><br><span class="line">logcount <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">)engine <span class="operator">=</span> innodb <span class="keyword">default</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure><p>在每次插入数据之后，更新该表 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateLogCounter&quot;</span> &gt;</span></span><br><span class="line">    update log_counter set logcount = logcount + 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在进行分页查询时, 获取总记录数，从该表中查询既可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countLogFromCounter&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">    select logcount from log_counter limit 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="优化-limit"><a href="#优化-limit" class="headerlink" title="优化 limit"></a>优化 limit</h4><p>在进行分页时，一般通过创建覆盖索引，能够比较好的提高性能。一个非常常见，而又非常头疼的分页场景就是 “limit 1000000,10” ，此时MySQL需要搜索出前1000010 条记录后，仅仅需要返回第 1000001 到 1000010 条记录，前1000000 记录会被抛弃，查询代价非常大。 </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523213403564.png" alt="image-20210523213403564"></p><p>当点击比较靠后的页码时，就会出现这个问题，查询效率非常慢。</p><p>优化SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> operation_log limit <span class="number">3000000</span> , <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>将上述SQL优化为 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> operation_log t , (<span class="keyword">select</span> id <span class="keyword">from</span> operation_log <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">3000000</span>,<span class="number">10</span>) b <span class="keyword">where</span> t.id <span class="operator">=</span> b.id ;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;operationLog&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    id ,</span><br><span class="line">    operate_class as operateClass ,</span><br><span class="line">    operate_method as operateMethod,</span><br><span class="line">    return_class as returnClass,</span><br><span class="line">    operate_user as operateUser,</span><br><span class="line">    operate_time as operateTime,</span><br><span class="line">    param_and_value as paramAndValue,</span><br><span class="line">    cost_time as costTime,</span><br><span class="line">    return_value as returnValue</span><br><span class="line">  from operation_log t,</span><br><span class="line">    </span><br><span class="line">  (select id from operation_log </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;oplog_where&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">  order by id limit #&#123;start&#125;,#&#123;rows&#125;) b  where t.id = b.id  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="性能优化-索引"><a href="#性能优化-索引" class="headerlink" title="性能优化 - 索引"></a>性能优化 - 索引</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523213331621.png" alt="image-20210523213331621"></p><p>当根据操作人进行查询时， 查询的效率很低，耗时比较长。原因就是因为在创建数据库表结构时，并没有针对于 操作人 字段建立索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_method_return_cost <span class="keyword">ON</span> operation_log(operate_user,operate_method,return_class,cost_time);</span><br></pre></td></tr></table></figure><p>同上 ， 为了查询效率高，我们也需要对 操作方法、返回值类型、操作耗时 等字段进行创建索引，以提高查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_optlog_method_return_cost <span class="keyword">ON</span> operation_log(operate_method,return_class,cost_time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_optlog_return_cost <span class="keyword">ON</span> operation_log(return_class,cost_time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_optlog_cost <span class="keyword">ON</span> operation_log(cost_time);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="性能优化-排序"><a href="#性能优化-排序" class="headerlink" title="性能优化 - 排序"></a>性能优化 - 排序</h3><p>在查询数据时，如果业务需求中需要我们对结果内容进行了排序处理 , 这个时候,我们还需要对排序的字段建立适当的索引, 来提高排序的效率 。</p><h3 id="性能优化-读写分离"><a href="#性能优化-读写分离" class="headerlink" title="性能优化 - 读写分离"></a>性能优化 - 读写分离</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>在MySQL主从复制的基础上，可以使用读写分离来降低单台MySQL节点的压力，从而来提高访问效率，读写分离的架构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523213306954.png" alt="image-20210523213306954"></p><p>对于读写分离的实现，可以通过Spring AOP 来进行动态的切换数据源，进行操作 ：</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>db.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.write.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.write.url</span>=<span class="string">jdbc:mysql://192.168.142.128:3306/mysql_demo</span></span><br><span class="line"><span class="meta">jdbc.write.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.write.password</span>=<span class="string">itcast</span></span><br><span class="line"></span><br><span class="line"><span class="meta">jdbc.read.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.read.url</span>=<span class="string">jdbc:mysql://192.168.142.129:3306/mysql_demo</span></span><br><span class="line"><span class="meta">jdbc.read.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.read.password</span>=<span class="string">itcast</span></span><br></pre></td></tr></table></figure><p>applicationContext-datasource.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 - Read --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;readDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.read.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.read.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.read.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.read.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 - Write --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;writeDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>  <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.write.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.write.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.write.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.write.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置动态分配的读写 数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.aop.datasource.ChooseDataSource&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;javax.sql.DataSource&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;write&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;writeDataSource&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;read&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;readDataSource&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultTargetDataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;writeDataSource&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodType&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;read&quot;</span> <span class="attr">value</span>=<span class="string">&quot;,get,select,count,list,query,find&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;write&quot;</span> <span class="attr">value</span>=<span class="string">&quot;,add,create,update,delete,remove,insert&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ChooseDataSource：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChooseDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; METHOD_TYPE_MAP = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现父类中的抽象方法，获取数据源名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceHandler.getDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置方法名前缀对应的数据源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodType</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            List&lt;String&gt; v = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            String[] types = map.get(key).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isEmpty(type)) &#123;</span><br><span class="line">                    v.add(type);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            METHOD_TYPE_MAP.put(key, v);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;METHOD_TYPE_MAP : &quot;</span>+METHOD_TYPE_MAP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSourceHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据源名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; holder = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在项目启动的时候将配置的读、写数据源加到holder中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putDataSource</span><span class="params">(String datasource)</span> </span>&#123;</span><br><span class="line">        holder.set(datasource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从holer中获取数据源字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSourceAspect：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(-9999)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置前置通知,使用在方法aspect()上注册的切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* cn.itcast.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="meta">@Order(-9999)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint point)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String className = point.getTarget().getClass().getName();</span><br><span class="line">        String method = point.getSignature().getName();</span><br><span class="line">        logger.info(className + <span class="string">&quot;.&quot;</span> + method + <span class="string">&quot;(&quot;</span> + Arrays.asList(point.getArgs())+ <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String key : ChooseDataSource.METHOD_TYPE_MAP.keySet()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String type : ChooseDataSource.METHOD_TYPE_MAP.get(key)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method.startsWith(type)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;key : &quot;</span> + key);</span><br><span class="line">                        DataSourceHandler.putDataSource(key);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @Order(-9999) 注解来控制事务管理器, 与该通知类的加载顺序 , 需要让通知类 , 先加载 , 来判定使用哪个数据源 。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在主库和从库中，执行如下SQL语句，来查看是否读的时候， 从从库中读取； 写入操作的时候，是否写入到主库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span> ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523213147982.png" alt="image-20210523213147982"></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210523213121482.png" alt="image-20210523213121482"></p><h3 id="性能优化-应用优化"><a href="#性能优化-应用优化" class="headerlink" title="性能优化 - 应用优化"></a>性能优化 - 应用优化</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>可以在业务系统中使用redis来做缓存，缓存一些基础性的数据，来降低关系型数据库的压力，提高访问效率。</p><h4 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h4><p>如果业务系统中的数据量比较大（达到千万级别），这个时候，如果再对数据库进行查询，特别是进行分页查询，速度将变得很慢（因为在分页时首先需要count求合计数），为了提高访问效率，这个时候，可以考虑加入Solr 或者 ElasticSearch全文检索服务，来提高访问效率。</p><h4 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h4><p>也可以考虑将非核心（重要）数据，存在 MongoDB 中，这样可以提高插入以及查询的效率。</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 工具 </tag>
            
            <tag> 日志 </tag>
            
            <tag> 综合案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级—存储引擎、SQL优化</title>
      <link href="2021/04/02/MySQL%E9%AB%98%E7%BA%A7%E2%80%94%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81SQL%E4%BC%98%E5%8C%96/"/>
      <url>2021/04/02/MySQL%E9%AB%98%E7%BA%A7%E2%80%94%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL的体系结构概览"><a href="#MySQL的体系结构概览" class="headerlink" title="MySQL的体系结构概览"></a>MySQL的体系结构概览</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/000001.jpg" alt="171214401286615"> </p><p>整个MySQL Server由以下组成</p><ul><li><p>Connection Pool : 连接池组件</p></li><li><p>Management Services &amp; Utilities : 管理服务和工具组件</p></li><li><p>SQL Interface : SQL接口组件</p></li><li><p>Parser : 查询分析器组件</p></li><li><p>Optimizer : 优化器组件</p></li><li><p>Caches &amp; Buffers : 缓冲池组件</p></li><li><p>Pluggable Storage Engines : 存储引擎</p></li><li><p>File System : 文件系统</p></li></ul><p>1）  连接层</p><p>最上层是一些客户端和链接服务，包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP 的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接，服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p>2） 服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化，如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>3） 引擎层</p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样可以根据自己的需要，来选取合适的存储引擎。</p><p>4）存储层</p><p>数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h3><p>​    1）和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。</p><p>​    2）Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。</p><p>​    3）MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。</p><p>可以通过指定 show engines ， 来查询当前数据库支持的存储引擎 ： </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509163411658.png" alt="image-20210509163411658"></p><p>创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。查看Mysql数据库默认的存储引擎 ， 指令 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span> ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span> ;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                    <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> default_storage_engine           <span class="operator">|</span> InnoDB <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> default_tmp_storage_engine       <span class="operator">|</span> InnoDB <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> disabled_storage_engines         <span class="operator">|</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> internal_tmp_disk_storage_engine <span class="operator">|</span> InnoDB <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="各种存储引擎特性"><a href="#各种存储引擎特性" class="headerlink" title="各种存储引擎特性"></a>各种存储引擎特性</h3><p>下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： </p><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>MERGE</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td><td>没有</td><td>有</td></tr><tr><td>事务安全</td><td><strong>支持</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td><strong>行锁(适合高并发)</strong></td><td><strong>表锁</strong></td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td><td></td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>数据索引</td><td>支持</td><td></td><td>支持</td><td></td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td><td>低</td><td>高</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td><strong>支持</strong></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>下面重点介绍最常使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。</p><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB存储引擎是MySQL的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p><p>InnoDB存储引擎不同于其他存储引擎的特点 ： </p><p><strong>事务控制</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods_innodb(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>innodb <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods_innodb(id,name)<span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Meta20&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span> transaction;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> goods_innodb(<span class="keyword">null</span>,<span class="string">&#x27;mate 20&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.04</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure><p>测试，发现在InnoDB中是存在事务的 ；</p><p><strong>外键约束</strong></p><p>​    MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。</p><p>​    下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> country_innodb(</span><br><span class="line">country_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    country_name <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(country_id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> city_innodb(</span><br><span class="line">city_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    city_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(city_id),</span><br><span class="line">    key idx_fk_country_id(country_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_city_country` <span class="keyword">FOREIGN</span> KEY(country_id) <span class="keyword">REFERENCES</span> country_innodb(country_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> UPDATE CASCADE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> country_innodb <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;China&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;America&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;Japan&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> city_innodb <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Xian&#x27;</span>,<span class="number">1</span>),(<span class="keyword">null</span>,<span class="string">&#x27;NewYork&#x27;</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="string">&#x27;BeiJing&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。</p></li><li><p>RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新；</p></li><li><p>CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录；</p></li><li><p>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。</p></li></ul><p>针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。</p><p>表中数据如下图所示 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> city_innodb;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----------+------------+</span></span><br><span class="line"><span class="operator">|</span> city_id <span class="operator">|</span> city_name <span class="operator">|</span> country_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----------+------------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span> Xian      <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span> NewYork   <span class="operator">|</span>          <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span> BeiJing   <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----------+------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.13</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> country_innodb;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> country_id <span class="operator">|</span> country_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+</span></span><br><span class="line"><span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> China        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>          <span class="number">2</span> <span class="operator">|</span> America      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>          <span class="number">3</span> <span class="operator">|</span> Japan        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.12</span> sec)</span><br></pre></td></tr></table></figure><p>外键信息可以使用如下两种方式查看 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> city_innodb ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">|</span> city_innodb <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `city_innodb` (</span><br><span class="line">  `city_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `city_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `country_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`city_id`),</span><br><span class="line">  KEY `idx_fk_country_id` (`country_id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_city_country` <span class="keyword">FOREIGN</span> KEY (`country_id`) <span class="keyword">REFERENCES</span> `country_innodb` (`country_id`) <span class="keyword">ON</span> UPDATE CASCADE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br></pre></td></tr></table></figure><p>删除country_id为1 的country数据： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> country_innodb <span class="keyword">where</span> country_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> country_innodb <span class="keyword">where</span> country_id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="number">1451</span> <span class="operator">-</span> Cannot <span class="keyword">delete</span> <span class="keyword">or</span> update a parent <span class="type">row</span>: a <span class="keyword">foreign</span> key <span class="keyword">constraint</span> fails (`test`.`city_innodb`, <span class="keyword">CONSTRAINT</span> `fk_city_country` <span class="keyword">FOREIGN</span> KEY (`country_id`) <span class="keyword">REFERENCES</span> `country_innodb` (`country_id`) <span class="keyword">ON</span> UPDATE CASCADE)</span><br></pre></td></tr></table></figure><p>更新主表country表的字段 country_id : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update country_innodb <span class="keyword">set</span> country_id <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> country_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> update country_innodb <span class="keyword">set</span> country_id <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> country_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.04</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>更新后， 子表的数据信息为 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> city_innodb;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----------+------------+</span></span><br><span class="line"><span class="operator">|</span> city_id <span class="operator">|</span> city_name <span class="operator">|</span> country_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----------+------------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span> Xian      <span class="operator">|</span>        <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span> NewYork   <span class="operator">|</span>          <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span> BeiJing   <span class="operator">|</span>        <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----------+------------+</span></span><br></pre></td></tr></table></figure><p><strong>存储方式</strong>    </p><p>InnoDB 存储表和索引有以下两种方式 ： </p><ol><li><p>使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。</p></li><li><p>使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。</p></li></ol><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>MyISAM <strong>不支持事务、也不支持外键</strong>，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： </p><p><strong>文件存储方式</strong></p><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： </p><p>.frm (存储表定义)；</p><p>.MYD(MYData , 存储数据)；</p><p>.MYI(MYIndex , 存储索引)；</p><h4 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h4><p>Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为它的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。</p><h4 id="MERGE"><a href="#MERGE" class="headerlink" title="MERGE"></a>MERGE</h4><p>​    MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。</p><p>​    对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519213313122.png" alt="image-20210519213313122"></p><p>下面是一个创建和使用MERGE表的示例 ： </p><p>1）创建3个测试表 order_1990, order_1991, order_all , 其中order_all是前两个表的MERGE表 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_1990(</span><br><span class="line">order_id <span class="type">int</span> ,</span><br><span class="line">order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">order_address <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line"><span class="keyword">primary</span> key (order_id)</span><br><span class="line">)engine <span class="operator">=</span> myisam <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_1991(</span><br><span class="line">order_id <span class="type">int</span> ,</span><br><span class="line">order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">order_address <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line"><span class="keyword">primary</span> key (order_id)</span><br><span class="line">)engine <span class="operator">=</span> myisam <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_all(</span><br><span class="line">order_id <span class="type">int</span> ,</span><br><span class="line">order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">order_address <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line"><span class="keyword">primary</span> key (order_id)</span><br><span class="line">)engine <span class="operator">=</span> <span class="keyword">merge</span> <span class="keyword">union</span> <span class="operator">=</span> (order_1990,order_1991) INSERT_METHOD<span class="operator">=</span><span class="keyword">LAST</span> <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）分别向两张表中插入记录 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">100.0</span>,<span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">100.0</span>,<span class="string">&#x27;上海&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">200.0</span>,<span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">200.0</span>,<span class="string">&#x27;上海&#x27;</span>);</span><br></pre></td></tr></table></figure><p>3）查询3张表中的数据。</p><p>order_1990中的数据 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_1990;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> order_id <span class="operator">|</span> order_money <span class="operator">|</span> order_address <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>      <span class="number">100.00</span> <span class="operator">|</span> 北京          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span>      <span class="number">100.00</span> <span class="operator">|</span> 上海          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.16</span> sec)</span><br></pre></td></tr></table></figure><p>order_1991中的数据 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_1991;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> order_id <span class="operator">|</span> order_money <span class="operator">|</span> order_address <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">10</span> <span class="operator">|</span>      <span class="number">200.00</span> <span class="operator">|</span> 北京          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">11</span> <span class="operator">|</span>      <span class="number">200.00</span> <span class="operator">|</span> 上海          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.16</span> sec)</span><br></pre></td></tr></table></figure><p>order_all中的数据 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_all;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> order_id <span class="operator">|</span> order_money <span class="operator">|</span> order_address <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>      <span class="number">100.00</span> <span class="operator">|</span> 北京          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span>      <span class="number">100.00</span> <span class="operator">|</span> 上海          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">10</span> <span class="operator">|</span>      <span class="number">200.00</span> <span class="operator">|</span> 北京          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">11</span> <span class="operator">|</span>      <span class="number">200.00</span> <span class="operator">|</span> 上海          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.14</span> sec)</span><br></pre></td></tr></table></figure><p>4）往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_all <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">10000.0</span>,<span class="string">&#x27;西安&#x27;</span>)；</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> order_all <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">10000.0</span>,<span class="string">&#x27;西安&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_1991;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> order_id <span class="operator">|</span> order_money <span class="operator">|</span> order_address <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">10</span> <span class="operator">|</span>      <span class="number">200.00</span> <span class="operator">|</span> 北京          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">11</span> <span class="operator">|</span>      <span class="number">200.00</span> <span class="operator">|</span> 上海          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">100</span> <span class="operator">|</span>    <span class="number">10000.00</span> <span class="operator">|</span> 西安          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+---------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.15</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。</p><ul><li>InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。</li><li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</li><li>MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。</li></ul><h2 id="优化SQL步骤"><a href="#优化SQL步骤" class="headerlink" title="优化SQL步骤"></a>优化SQL步骤</h2><p>在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。但是当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p><h3 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h3><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。</p><p>下面的命令显示了当前 session 中所有统计参数的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Com_binlog    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_commit    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_delete    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_insert    <span class="operator">|</span> <span class="number">19</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_repair    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_revoke    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_select    <span class="operator">|</span> <span class="number">11</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_signal    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_update    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_xa_end    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.21</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name        <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_deleted  <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_inserted <span class="operator">|</span> <span class="number">556</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_read     <span class="operator">|</span> <span class="number">760</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_updated  <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.14</span> sec)</span><br></pre></td></tr></table></figure><p>Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数：</p><table><thead><tr><th align="left">参数</th><th>含义</th></tr></thead><tbody><tr><td align="left">Com_select</td><td>执行 select 操作的次数，一次查询只累加 1。</td></tr><tr><td align="left">Com_insert</td><td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td></tr><tr><td align="left">Com_update</td><td>执行 UPDATE 操作的次数。</td></tr><tr><td align="left">Com_delete</td><td>执行 DELETE 操作的次数。</td></tr><tr><td align="left">Innodb_rows_read</td><td>select 查询返回的行数。</td></tr><tr><td align="left">Innodb_rows_inserted</td><td>执行 INSERT 操作插入的行数。</td></tr><tr><td align="left">Innodb_rows_updated</td><td>执行 UPDATE 操作更新的行数。</td></tr><tr><td align="left">Innodb_rows_deleted</td><td>执行 DELETE 操作删除的行数。</td></tr><tr><td align="left">Connections</td><td>试图连接 MySQL 服务器的次数。</td></tr><tr><td align="left">Uptime</td><td>服务器工作时间。</td></tr><tr><td align="left">Slow_queries</td><td>慢查询的次数。</td></tr></tbody></table><p>Com_***      :  这些参数对于所有存储引擎的表操作都会进行累计。</p><p>Innodb_*** :  这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。</p><h3 id="定位低效率执行SQL"><a href="#定位低效率执行SQL" class="headerlink" title="定位低效率执行SQL"></a>定位低效率执行SQL</h3><p>可以通过以下两种方式定位执行效率较低的 SQL 语句：</p><ul><li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以查看接下来的日志管理的相关部分。</li><li>show processlist  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+----------------+------+---------+------+----------+------------------+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> <span class="keyword">User</span> <span class="operator">|</span> Host           <span class="operator">|</span> db   <span class="operator">|</span> Command <span class="operator">|</span> <span class="type">Time</span> <span class="operator">|</span> State    <span class="operator">|</span> Info             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+----------------+------+---------+------+----------+------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> root <span class="operator">|</span> localhost:<span class="number">6018</span> <span class="operator">|</span> test <span class="operator">|</span> Query   <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> starting <span class="operator">|</span> <span class="keyword">show</span> processlist <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> root <span class="operator">|</span> localhost:<span class="number">6020</span> <span class="operator">|</span> test <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">6722</span> <span class="operator">|</span>          <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> root <span class="operator">|</span> localhost:<span class="number">6079</span> <span class="operator">|</span> test <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">6752</span> <span class="operator">|</span>          <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+----------------+------+---------+------+----------+------------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.13</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1） id列，用户登录mysql时，系统分配的&quot;connection_id&quot;，可以使用函数connection_id()查看</span><br><span class="line"></span><br><span class="line">2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</span><br><span class="line"></span><br><span class="line">3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户</span><br><span class="line"></span><br><span class="line">4） db列，显示这个进程目前连接的是哪个数据库</span><br><span class="line"></span><br><span class="line">5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等</span><br><span class="line"></span><br><span class="line">6） time列，显示这个状态持续的时间，单位是秒</span><br><span class="line"></span><br><span class="line">7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成</span><br><span class="line"></span><br><span class="line">8） info列，显示这个sql语句，是判断问题语句的一个重要依据</span><br></pre></td></tr></table></figure><h3 id="explain分析执行计划"><a href="#explain分析执行计划" class="headerlink" title="explain分析执行计划"></a>explain分析执行计划</h3><p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><p>查询SQL语句的执行计划 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> city <span class="keyword">where</span> city_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509173245040.png" alt="image-20210509173245040"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> city <span class="keyword">where</span> city_name<span class="operator">=</span> <span class="string">&#x27;西安&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509173334188.png" alt="image-20210509173334188">  </p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>type</td><td>表示表的连接类型，性能由好到差的连接类型为( system  —&gt;  const  —–&gt;  eq_ref  ——&gt;  ref  ——-&gt;  ref_or_null—-&gt;  index_merge  —&gt;  index_subquery  —–&gt;  range  —–&gt;  index  ——&gt; all )</td></tr><tr><td>possible_keys</td><td>表示查询时，可能使用的索引</td></tr><tr><td>key</td><td>表示实际使用的索引</td></tr><tr><td>key_len</td><td>索引字段的长度</td></tr><tr><td>rows</td><td>扫描行的数量</td></tr><tr><td>extra</td><td>执行情况的说明和描述</td></tr></tbody></table><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519213621991.png" alt="image-20210519213621991" style="zoom:80%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_role` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_code` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_role_name` (`role_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_user_username` (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_role` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment ,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `fk_ur_user_id` (`user_id`),</span><br><span class="line">  KEY `fk_ur_role_id` (`role_id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_ur_role_id` <span class="keyword">FOREIGN</span> KEY (`role_id`) <span class="keyword">REFERENCES</span> `t_role` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> UPDATE <span class="keyword">NO</span> ACTION,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_ur_user_id` <span class="keyword">FOREIGN</span> KEY (`user_id`) <span class="keyword">REFERENCES</span> `t_user` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> UPDATE <span class="keyword">NO</span> ACTION</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;系统管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#x27;</span>,<span class="string">&#x27;test02&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;stu1&#x27;</span>,<span class="string">&#x27;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa&#x27;</span>,<span class="string">&#x27;学生1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;stu2&#x27;</span>,<span class="string">&#x27;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm&#x27;</span>,<span class="string">&#x27;学生2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;t1&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;老师1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>,<span class="string">&#x27;student&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>,<span class="string">&#x27;teachmanager&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_role(id,user_id,role_id) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;5&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;7&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;9&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;10&#x27;</span>) ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="explain-之-id"><a href="#explain-之-id" class="headerlink" title="explain 之 id"></a>explain 之 id</h4><p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： </p><p>1） id 相同表示加载表的顺序是从上到下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_role r, t_user u, user_role ur <span class="keyword">where</span> r.id <span class="operator">=</span> ur.role_id <span class="keyword">and</span> u.id <span class="operator">=</span> ur.user_id ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509174342530.png" alt="image-20210509174342530"></p><p>2） id 不同id值越大，优先级越高，越先被执行。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role <span class="keyword">WHERE</span> id <span class="operator">=</span> (<span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> user_role <span class="keyword">WHERE</span> user_id <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;stu1&#x27;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509174457186.png" alt="image-20210509174457186"> </p><p>3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role r , (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_role ur <span class="keyword">WHERE</span> ur.`user_id` <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span>) a <span class="keyword">WHERE</span> r.id <span class="operator">=</span> a.role_id ; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509174615131.png" alt="image-20210509174615131"> </p><h4 id="explain-之-select-type"><a href="#explain-之-select-type" class="headerlink" title="explain 之 select_type"></a>explain 之 select_type</h4><p> 表示 SELECT 的类型，常见的取值，如下表所示：</p><table><thead><tr><th>select_type</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的select查询，查询中不包含子查询或者UNION。</td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td></tr><tr><td>SUBQUERY</td><td>在SELECT 或 WHERE 列表中包含了子查询。</td></tr><tr><td>DERIVED</td><td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED。</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT。</td></tr></tbody></table><h4 id="explain-之-table"><a href="#explain-之-table" class="headerlink" title="explain 之 table"></a>explain 之 table</h4><p>展示这一行的数据是关于哪一张表的 。</p><h4 id="explain-之-type"><a href="#explain-之-type" class="headerlink" title="explain 之 type"></a>explain 之 type</h4><p>type 显示的是访问类型，是较为重要的一个指标，可取值为： </p><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>MySQL不访问任何表，索引，直接返回结果。</td></tr><tr><td>system</td><td>表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现。</td></tr><tr><td>const</td><td>表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常量。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较。</td></tr><tr><td>eq_ref</td><td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td></tr><tr><td>ref</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td></tr><tr><td>range</td><td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。</td></tr><tr><td>index</td><td>index 与 ALL的区别为  index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</td></tr><tr><td>all</td><td>将遍历全表以找到匹配的行。</td></tr></tbody></table><p>结果值从最好到最坏以此是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure><p><strong>一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。</strong></p><h4 id="explain-之-key"><a href="#explain-之-key" class="headerlink" title="explain 之  key"></a>explain 之  key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">possible_keys : 显示可能应用在这张表的索引， 一个或多个。 </span><br><span class="line"></span><br><span class="line">key ： 实际使用的索引， 如果为NULL， 则没有使用索引。</span><br><span class="line"></span><br><span class="line">key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</span><br></pre></td></tr></table></figure><h4 id="explain-之-rows"><a href="#explain-之-rows" class="headerlink" title="explain 之 rows"></a>explain 之 rows</h4><p>扫描行的数量。</p><h4 id="explain-之-extra"><a href="#explain-之-extra" class="headerlink" title="explain 之 extra"></a>explain 之 extra</h4><p>其他的额外的执行计划信息，在该列展示 。</p><table><thead><tr><th>extra</th><th>含义</th></tr></thead><tbody><tr><td>using  filesort</td><td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。</td></tr><tr><td>using  temporary</td><td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低</td></tr><tr><td>using  index</td><td>表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。</td></tr></tbody></table><h3 id="show-profile分析SQL"><a href="#show-profile分析SQL" class="headerlink" title="show profile分析SQL"></a>show profile分析SQL</h3><p>MySQL从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@have</span>_profiling;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@have</span>_profiling <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> YES              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.17</span> sec)</span><br></pre></td></tr></table></figure><p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@profiling</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.15</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>开启profiling 开关；</span><br></pre></td></tr></table></figure><p>通过profile，我们能够更清楚地了解SQL执行的过程。首先，我们可以执行一系列的操作，如下图所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> city;</span><br></pre></td></tr></table></figure><p>执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">0.00094575</span> <span class="operator">|</span> <span class="keyword">show</span> databases     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">0.00037350</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> city <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+--------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.13</span> sec)</span><br></pre></td></tr></table></figure><p>通过show  profile for  query  query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span>  profile <span class="keyword">for</span>  query  <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status               <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting             <span class="operator">|</span> <span class="number">0.000057</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables       <span class="operator">|</span> <span class="number">0.000064</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                 <span class="operator">|</span> <span class="number">0.000010</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock          <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing           <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics           <span class="operator">|</span> <span class="number">0.000016</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing            <span class="operator">|</span> <span class="number">0.000018</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing            <span class="operator">|</span> <span class="number">0.000605</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sending data         <span class="operator">|</span> <span class="number">0.000036</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                  <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>            <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables       <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> removing tmp <span class="keyword">table</span>   <span class="operator">|</span> <span class="number">0.000013</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables       <span class="operator">|</span> <span class="number">0.000005</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items        <span class="operator">|</span> <span class="number">0.000072</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up          <span class="operator">|</span> <span class="number">0.000017</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIP ：</span><br><span class="line">Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。</span><br></pre></td></tr></table></figure><p>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。 </p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Status</td><td>sql 语句执行的状态</td></tr><tr><td>Duration</td><td>sql 执行过程中每一个步骤的耗时</td></tr><tr><td>CPU_user</td><td>当前用户占有的cpu</td></tr><tr><td>CPU_system</td><td>系统占有的cpu</td></tr></tbody></table><h3 id="trace分析优化器执行计划"><a href="#trace分析优化器执行计划" class="headerlink" title="trace分析优化器执行计划"></a>trace分析优化器执行计划</h3><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p><p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p>执行SQL语句 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> city <span class="keyword">where</span> city_id <span class="operator">&lt;</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">| select * from city where city_id &lt; 4 | &#123;</span><br><span class="line">  &quot;steps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;join_preparation&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;select#&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;steps&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;expanded_query&quot;</span>: <span class="string">&quot;/* select#1 */ select `city`.`city_id` AS `city_id`,`city`.`city_name` AS `city_name`,`city`.`country_id` AS `country_id` from `city` where (`city`.`city_id` &lt; 4)&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">      &#125; <span class="comment">/* join_preparation */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;join_optimization&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;select#&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;steps&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;condition_processing&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;condition&quot;</span>: <span class="string">&quot;WHERE&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;original_condition&quot;</span>: <span class="string">&quot;(`city`.`city_id` &lt; 4)&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;steps&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;transformation&quot;</span>: <span class="string">&quot;equality_propagation&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;resulting_condition&quot;</span>: <span class="string">&quot;(`city`.`city_id` &lt; 4)&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;transformation&quot;</span>: <span class="string">&quot;constant_propagation&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;resulting_condition&quot;</span>: <span class="string">&quot;(`city`.`city_id` &lt; 4)&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;transformation&quot;</span>: <span class="string">&quot;trivial_condition_removal&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;resulting_condition&quot;</span>: <span class="string">&quot;(`city`.`city_id` &lt; 4)&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">              ] <span class="comment">/* steps */</span></span><br><span class="line">            &#125; <span class="comment">/* condition_processing */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;substitute_generated_columns&quot;</span>: &#123;</span><br><span class="line">            &#125; <span class="comment">/* substitute_generated_columns */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;table_dependencies&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;`city`&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;row_may_be_null&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;map_bit&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;depends_on_map_bits&quot;</span>: [</span><br><span class="line">                ] <span class="comment">/* depends_on_map_bits */</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* table_dependencies */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;ref_optimizer_key_uses&quot;</span>: [</span><br><span class="line">            ] <span class="comment">/* ref_optimizer_key_uses */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;rows_estimation&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;`city`&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;range_analysis&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;table_scan&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;rows&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                    <span class="attr">&quot;cost&quot;</span>: <span class="number">3.9</span></span><br><span class="line">                  &#125; <span class="comment">/* table_scan */</span>,</span><br><span class="line">                  <span class="attr">&quot;potential_range_indexes&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;PRIMARY&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;usable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                      <span class="attr">&quot;key_parts&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;city_id&quot;</span></span><br><span class="line">                      ] <span class="comment">/* key_parts */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ] <span class="comment">/* potential_range_indexes */</span>,</span><br><span class="line">                  <span class="attr">&quot;setup_range_conditions&quot;</span>: [</span><br><span class="line">                  ] <span class="comment">/* setup_range_conditions */</span>,</span><br><span class="line">                  <span class="attr">&quot;group_index_range&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;chosen&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;cause&quot;</span>: <span class="string">&quot;not_group_by_or_distinct&quot;</span></span><br><span class="line">                  &#125; <span class="comment">/* group_index_range */</span>,</span><br><span class="line">                  <span class="attr">&quot;analyzing_range_alternatives&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;range_scan_alternatives&quot;</span>: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;PRIMARY&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;ranges&quot;</span>: [</span><br><span class="line">                          <span class="string">&quot;city_id &lt; 4&quot;</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="attr">&quot;index_dives_for_eq_ranges&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">&quot;rowid_ordered&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">&quot;using_mrr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">&quot;index_only&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">&quot;rows&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                        <span class="attr">&quot;cost&quot;</span>: <span class="number">1.6126</span>,</span><br><span class="line">                        <span class="attr">&quot;chosen&quot;</span>: <span class="literal">true</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    ] <span class="comment">/* range_scan_alternatives */</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzing_roworder_intersect&quot;</span>: &#123;</span><br><span class="line">                      <span class="attr">&quot;usable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                      <span class="attr">&quot;cause&quot;</span>: <span class="string">&quot;too_few_roworder_scans&quot;</span></span><br><span class="line">                    &#125; <span class="comment">/* analyzing_roworder_intersect */</span></span><br><span class="line">                  &#125; <span class="comment">/* analyzing_range_alternatives */</span>,</span><br><span class="line">                  <span class="attr">&quot;chosen_range_access_summary&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;range_access_plan&quot;</span>: &#123;</span><br><span class="line">                      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;range_scan&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;PRIMARY&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;rows&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                      <span class="attr">&quot;ranges&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;city_id &lt; 4&quot;</span></span><br><span class="line">                      ] <span class="comment">/* ranges */</span></span><br><span class="line">                    &#125; <span class="comment">/* range_access_plan */</span>,</span><br><span class="line">                    <span class="attr">&quot;rows_for_plan&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="attr">&quot;cost_for_plan&quot;</span>: <span class="number">1.6126</span>,</span><br><span class="line">                    <span class="attr">&quot;chosen&quot;</span>: <span class="literal">true</span></span><br><span class="line">                  &#125; <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">                &#125; <span class="comment">/* range_analysis */</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* rows_estimation */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;considered_execution_plans&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;plan_prefix&quot;</span>: [</span><br><span class="line">                ] <span class="comment">/* plan_prefix */</span>,</span><br><span class="line">                <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;`city`&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;best_access_path&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;considered_access_paths&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;rows_to_scan&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                      <span class="attr">&quot;access_type&quot;</span>: <span class="string">&quot;range&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;range_details&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;used_index&quot;</span>: <span class="string">&quot;PRIMARY&quot;</span></span><br><span class="line">                      &#125; <span class="comment">/* range_details */</span>,</span><br><span class="line">                      <span class="attr">&quot;resulting_rows&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                      <span class="attr">&quot;cost&quot;</span>: <span class="number">2.2126</span>,</span><br><span class="line">                      <span class="attr">&quot;chosen&quot;</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ] <span class="comment">/* considered_access_paths */</span></span><br><span class="line">                &#125; <span class="comment">/* best_access_path */</span>,</span><br><span class="line">                <span class="attr">&quot;condition_filtering_pct&quot;</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">&quot;rows_for_plan&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                <span class="attr">&quot;cost_for_plan&quot;</span>: <span class="number">2.2126</span>,</span><br><span class="line">                <span class="attr">&quot;chosen&quot;</span>: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* considered_execution_plans */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;attaching_conditions_to_tables&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;original_condition&quot;</span>: <span class="string">&quot;(`city`.`city_id` &lt; 4)&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;attached_conditions_computation&quot;</span>: [</span><br><span class="line">              ] <span class="comment">/* attached_conditions_computation */</span>,</span><br><span class="line">              <span class="attr">&quot;attached_conditions_summary&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;`city`&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;attached&quot;</span>: <span class="string">&quot;(`city`.`city_id` &lt; 4)&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">              ] <span class="comment">/* attached_conditions_summary */</span></span><br><span class="line">            &#125; <span class="comment">/* attaching_conditions_to_tables */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;refine_plan&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;`city`&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* refine_plan */</span></span><br><span class="line">          &#125;</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">      &#125; <span class="comment">/* join_optimization */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;join_execution&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;select#&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;steps&quot;</span>: [</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">      &#125; <span class="comment">/* join_execution */</span></span><br><span class="line">    &#125;</span><br><span class="line">  ] /* steps */</span><br><span class="line">&#125; |                                 0 |                       0 |</span><br></pre></td></tr></table></figure><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><p>索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</p><h3 id="验证索引提升查询效率"><a href="#验证索引提升查询效率" class="headerlink" title="验证索引提升查询效率"></a>验证索引提升查询效率</h3><p>创建表tb_item ， 并存储了 300 万条记录进行测试。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_item` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品id&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品标题&#x27;</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品价格，单位为：元&#x27;</span>,</span><br><span class="line">  `num` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存数量&#x27;</span>,</span><br><span class="line">  `categoryid` <span class="type">bigint</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;所属类目，叶子类目&#x27;</span>,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品状态，1-正常，2-下架，3-删除&#x27;</span>,</span><br><span class="line">  `sellerid` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商家ID&#x27;</span>,</span><br><span class="line">  `createtime` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updatetime` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span></span><br></pre></td></tr></table></figure><p>1） 根据ID查询 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1999</span>\G;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb item <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1999</span>\G; </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span>sec)</span><br></pre></td></tr></table></figure><p>查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引。</p><p>2）根据 title 进行精确查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> title <span class="operator">=</span> <span class="string">&#x27;iphoneX 移动3G 32G941&#x27;</span>\G; </span><br></pre></td></tr></table></figure><p>查看SQL语句的执行计划 ：发现没有使用索引，时间0.02s 。 处理方案 ， 针对title字段， 创建索引 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_item_title <span class="keyword">on</span> tb_item(title);</span><br></pre></td></tr></table></figure><p>索引创建完成之后，再次进行查询 ： 通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引 ，时间0.00s。</p><h3 id="索引的使用-1"><a href="#索引的使用-1" class="headerlink" title="索引的使用"></a>索引的使用</h3><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_seller` (</span><br><span class="line">`sellerid` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">`name` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">`nickname` <span class="type">varchar</span> (<span class="number">50</span>),</span><br><span class="line">`password` <span class="type">varchar</span> (<span class="number">60</span>),</span><br><span class="line">`status` <span class="type">varchar</span> (<span class="number">1</span>),</span><br><span class="line">`address` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">`createtime` datetime,</span><br><span class="line">    <span class="keyword">primary</span> key(`sellerid`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4; </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;alibaba&#x27;</span>,<span class="string">&#x27;阿里巴巴&#x27;</span>,<span class="string">&#x27;阿里小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;baidu&#x27;</span>,<span class="string">&#x27;百度科技有限公司&#x27;</span>,<span class="string">&#x27;百度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;huawei&#x27;</span>,<span class="string">&#x27;华为科技有限公司&#x27;</span>,<span class="string">&#x27;华为小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;传智播客教育科技有限公司&#x27;</span>,<span class="string">&#x27;传智播客&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itheima&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;luoji&#x27;</span>,<span class="string">&#x27;罗技科技有限公司&#x27;</span>,<span class="string">&#x27;罗技小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;OPPO科技有限公司&#x27;</span>,<span class="string">&#x27;OPPO官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;ourpalm&#x27;</span>,<span class="string">&#x27;掌趣科技股份有限公司&#x27;</span>,<span class="string">&#x27;掌趣小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;qiandu&#x27;</span>,<span class="string">&#x27;千度科技&#x27;</span>,<span class="string">&#x27;千度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;sina&#x27;</span>,<span class="string">&#x27;新浪科技有限公司&#x27;</span>,<span class="string">&#x27;新浪官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;小米科技&#x27;</span>,<span class="string">&#x27;小米官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;西安市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;yijia&#x27;</span>,<span class="string">&#x27;宜家家居&#x27;</span>,<span class="string">&#x27;宜家家居旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(name,status,address);</span><br></pre></td></tr></table></figure><h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><p>1）全值匹配 ，对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509203338500.png" alt="image-20210509203338500"></p><p>2）最左前缀法则</p><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509203628447.png" alt="image-20210509203628447">  </p><p>下面是违法最左前缀法则 ， 索引失效：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509203724612.png" alt="image-20210509203724612"> </p><p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效（索引看长度，判断索引生效情况，越长说明索引生效条件越多）：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509203843835.png" alt="image-20210509203843835"> </p><p>3）范围查询右边的列，不能使用索引 。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509204043053.png" alt="image-20210509204043053"> </p><p>根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p><p>4）不要在索引列上进行运算操作， 索引将失效。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509204200976.png" alt="image-20210509204200976"> </p><p>5）字符串不加单引号，造成索引失效。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509204350974.png" alt="image-20210509204350974"> </p><p>由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p><p>6）尽量使用覆盖索引，避免select *。尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509204827236.png" alt="image-20210509204827236"> </p><p>如果查询列，超出索引列，也会降低性能。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509205021064.png" alt="image-20210509205021064"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TIP : </span><br><span class="line"></span><br><span class="line">    using index ：使用覆盖索引的时候就会出现。</span><br><span class="line"></span><br><span class="line">    using where：在查找使用索引的情况下，需要回表去查询所需的数据。</span><br><span class="line"></span><br><span class="line">    using index condition：查找使用了索引，但是需要回表查询数据。</span><br><span class="line"></span><br><span class="line">    using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据。</span><br></pre></td></tr></table></figure><p>7）用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><p>示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;黑马程序员&#x27;</span> <span class="keyword">or</span> createtime <span class="operator">=</span> <span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509205323343.png" alt="image-20210509205323343"> </p><p>8）以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509205535034.png" alt="image-20210509205535034"></p><p>解决方案 ： </p><p>通过覆盖索引来解决 </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509205659983.png" alt="image-20210509205659983"> </p><p>9）如果MySQL评估使用索引比全表更慢，则不使用索引。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509205919382.png" alt="image-20210509205919382"> </p><p>10）is  NULL ， is NOT NULL  有时索引失效。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509210105140.png" alt="image-20210509210105140">  </p><p>11）in 走索引， not in 索引失效。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509210216407.png" alt="image-20210509210216407">  </p><p>12） 单列索引和复合索引。尽量使用复合索引，而少使用单列索引 。</p><p>创建复合索引 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_name_sta_address <span class="keyword">on</span> tb_seller(name, status, address);</span><br><span class="line"></span><br><span class="line">就相当于创建了三个索引 ： </span><br><span class="line">name</span><br><span class="line">name <span class="operator">+</span> status</span><br><span class="line">name <span class="operator">+</span> status <span class="operator">+</span> address</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建单列索引 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_name <span class="keyword">on</span> tb_seller(name);</span><br><span class="line"><span class="keyword">create</span> index idx_seller_status <span class="keyword">on</span> tb_seller(status);</span><br><span class="line"><span class="keyword">create</span> index idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><p>数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</p><h3 id="查看索引使用情况"><a href="#查看索引使用情况" class="headerlink" title="查看索引使用情况"></a>查看索引使用情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509210459808.png" alt="image-20210509210459808" style="zoom:67%;" /> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。</span><br><span class="line"></span><br><span class="line">Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。</span><br><span class="line"></span><br><span class="line">Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。</span><br><span class="line"></span><br><span class="line">Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。</span><br><span class="line"></span><br><span class="line">Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。</span><br><span class="line"></span><br><span class="line">Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</span><br></pre></td></tr></table></figure><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p>环境准备 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user_2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `birthday` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `qq` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户状态&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_user_username` (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br></pre></td></tr></table></figure><p>当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210519214106501.png" alt="image-20210519214106501"></p><p>对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</p><ul><li><p>主键顺序插入</p><p> 因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">脚本文件介绍 :</span><br><span class="line">sql1.log  ----&gt; 主键有序</span><br><span class="line">sql2.log  ----&gt; 主键无序</span><br></pre></td></tr></table></figure><p>插入ID顺序排列数据：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509211329166.png" alt="image-20210509211329166" style="zoom:67%;" /><p>插入ID无序排列数据：耗时将是有序插入的数倍。 </p><ul><li>关闭唯一性校验</li></ul><p>​    在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509212044212.png" alt="image-20210509212044212" style="zoom:67%;" /> <ul><li><p>手动提交事务</p><p> 如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p></li></ul><h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p><ul><li><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</p><p>示例， 原始方式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure><p>优化后的方案为 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>)，(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在事务中进行数据插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>数据有序插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tim&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Rose&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br></pre></td></tr></table></figure><p>优化后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tim&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Rose&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="优化-order-by-语句"><a href="#优化-order-by-语句" class="headerlink" title="优化 order by 语句"></a>优化 order by 语句</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emp` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;2300&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;Luci&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;2800&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;Jay&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;Tom2&#x27;</span>,<span class="string">&#x27;21&#x27;</span>,<span class="string">&#x27;2200&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;Jerry2&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;3300&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;Luci2&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;2700&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;Jay2&#x27;</span>,<span class="string">&#x27;33&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;Tom3&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;2400&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;Jerry3&#x27;</span>,<span class="string">&#x27;32&#x27;</span>,<span class="string">&#x27;3100&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;Luci3&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;2900&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;Jay3&#x27;</span>,<span class="string">&#x27;37&#x27;</span>,<span class="string">&#x27;4500&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index idx_emp_age_salary <span class="keyword">on</span> emp(age,salary);</span><br></pre></td></tr></table></figure><h4 id="两种排序方式"><a href="#两种排序方式" class="headerlink" title="两种排序方式"></a>两种排序方式</h4><ol><li>第一种是通过对返回数据进行排序，也就是通常说的 Filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509212327655.png" alt="image-20210509212327655"> </p><ol start="2"><li>第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509212455814.png" alt="image-20210509212455814"> </p><ol start="3"><li>多字段排序：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509212541120.png" alt="image-20210509212541120"> </p><p>​       了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和 Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order  by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。</p><h4 id="Filesort-的优化"><a href="#Filesort-的优化" class="headerlink" title="Filesort 的优化"></a>Filesort 的优化</h4><p>通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：</p><ol><li><p> 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。</p></li><li><p>一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。</p></li></ol><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。因此可以适当提高 sort_buffer_size  和 max_length_for_sort_data  系统变量，来增大排序区的大小，提高排序的效率。 </p><h3 id="优化-group-by-语句"><a href="#优化-group-by-语句" class="headerlink" title="优化 group by 语句"></a>优化 group by 语句</h3><p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index idx_emp_age_salary <span class="keyword">on</span> emp;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509212927039.png" alt="image-20210509212927039">  </p><p>优化后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509213003418.png" alt="image-20210509213003418">  </p><p>从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order  by  null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。</p><p>接下来创建索引 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_emp_age_salary <span class="keyword">on</span> emp(age,salary);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509213115281.png" alt="image-20210509213115281"> </p><h3 id="优化嵌套查询"><a href="#优化嵌套查询" class="headerlink" title="优化嵌套查询"></a>优化嵌套查询</h3><p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p><p>示例 ，查找有角色的所有的用户信息 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> user_role );</span><br></pre></td></tr></table></figure><p>执行计划为 : </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509213222193.png" alt="image-20210509213222193">   </p><p>优化后 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user u , user_role ur <span class="keyword">where</span> u.id <span class="operator">=</span> ur.user_id;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509213311534.png" alt="image-20210509213311534">   </p><p>连接(join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p><h3 id="优化OR条件"><a href="#优化OR条件" class="headerlink" title="优化OR条件"></a>优化OR条件</h3><p>对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。  </p><p>示例 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509213503375.png" alt="image-20210509213503375">  </p><p>建议使用 union 替换 or ： </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509213610094.png" alt="image-20210509213610094"> </p><p>下面比较下重要指标，发现主要差别是 type 和 ref 这两项，type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null  &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure><ul><li><p>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距。</p></li><li><p>UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快。</p></li><li><p>这两项的差距就说明了 UNION 要优于 OR 。</p></li></ul><h3 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h3><p>  一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10  ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。 </p><p>优化思路：</p><ol><li><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。 </p></li><li><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。 </p></li></ol><h3 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h3><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><h4 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h4><p>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_name <span class="keyword">on</span> tb_seller(name);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509214233341.png" alt="image-20210509214233341"> </p><h4 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h4><p>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller ignore index(idx_seller_name) <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;小米科技&#x27;</span>; </span><br></pre></td></tr></table></figure><h4 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h4><p>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 存储引擎 </tag>
            
            <tag> sql优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级—相关优化、锁、使用技巧</title>
      <link href="2021/03/26/MySQL%E9%AB%98%E7%BA%A7%E2%80%94%E4%BC%98%E5%8C%96%E3%80%81%E9%94%81%E3%80%81%E4%BD%BF%E7%94%A8/"/>
      <url>2021/03/26/MySQL%E9%AB%98%E7%BA%A7%E2%80%94%E4%BC%98%E5%8C%96%E3%80%81%E9%94%81%E3%80%81%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h2><p>前面章节，介绍了很多数据库的优化措施。但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。</p><h3 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h3><p>对于访问数据库来说，建立连接的代价是比较昂贵的，因为频繁的创建关闭连接，是比较耗费资源的，我们有必要建立数据库连接池，以提高访问的性能。</p><h3 id="减少对MySQL的访问"><a href="#减少对MySQL的访问" class="headerlink" title="减少对MySQL的访问"></a>减少对MySQL的访问</h3><h4 id="避免对数据进行重复检索"><a href="#避免对数据进行重复检索" class="headerlink" title="避免对数据进行重复检索"></a>避免对数据进行重复检索</h4><p>在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。比如 ，需要获取书籍的id 和name字段 ， 则查询如下： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id , name <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><p>之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id , status <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><p>这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name , status <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><h4 id="增加cache层"><a href="#增加cache层" class="headerlink" title="增加cache层"></a>增加cache层</h4><p>在应用中，我们可以在应用中增加缓存层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据 。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。</p><h4 id="利用MySQL复制分流查询"><a href="#利用MySQL复制分流查询" class="headerlink" title="利用MySQL复制分流查询"></a>利用MySQL复制分流查询</h4><p>通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1.jpg" alt="1"> </p><h4 id="采用分布式数据库架构"><a href="#采用分布式数据库架构" class="headerlink" title="采用分布式数据库架构"></a>采用分布式数据库架构</h4><p>分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。</p><h2 id="MySQL中查询缓存优化"><a href="#MySQL中查询缓存优化" class="headerlink" title="MySQL中查询缓存优化"></a>MySQL中查询缓存优化</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>开启MySQL的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。</p><blockquote><p>注：MySQL8取消了查询缓存。</p></blockquote><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20180919131632347.png" alt="20180919131632347"> </p><ol><li><p>客户端发送一条查询给服务器；</p></li><li><p>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</p></li><li><p>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</p></li><li><p>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</p></li><li><p>将结果返回给客户端。</p></li></ol><h3 id="查询缓存配置"><a href="#查询缓存配置" class="headerlink" title="查询缓存配置"></a>查询缓存配置</h3><ol><li><p>查看当前的MySQL数据库是否支持查询缓存：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;have_query_cache&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;have_query_cache&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> have_query_cache <span class="operator">|</span> YES   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>查看当前MySQL是否开启了查询缓存 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;query_cache_type&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;query_cache_type&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> query_cache_type <span class="operator">|</span> OFF   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>查看查询缓存的占用大小 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;query_cache_size&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;query_cache_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> query_cache_size <span class="operator">|</span> <span class="number">1048576</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>查看查询缓存的状态变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Qcache%&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Qcache%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Qcache_free_blocks      <span class="operator">|</span> <span class="number">1</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_free_memory      <span class="operator">|</span> <span class="number">1031872</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_hits             <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_inserts          <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_lowmem_prunes    <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_not_cached       <span class="operator">|</span> <span class="number">1</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_queries_in_cache <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_total_blocks     <span class="operator">|</span> <span class="number">1</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.09</span> sec)</span><br></pre></td></tr></table></figure><p>各个变量的含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Qcache_free_blocks</td><td>查询缓存中的可用内存块数</td></tr><tr><td>Qcache_free_memory</td><td>查询缓存的可用内存量</td></tr><tr><td>Qcache_hits</td><td>查询缓存命中数</td></tr><tr><td>Qcache_inserts</td><td>添加到查询缓存的查询数</td></tr><tr><td>Qcache_lowmen_prunes</td><td>由于内存不足而从查询缓存中删除的查询数</td></tr><tr><td>Qcache_not_cached</td><td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td></tr><tr><td>Qcache_queries_in_cache</td><td>查询缓存中注册的查询数</td></tr><tr><td>Qcache_total_blocks</td><td>查询缓存中的块总数</td></tr></tbody></table></li></ol><h3 id="开启查询缓存"><a href="#开启查询缓存" class="headerlink" title="开启查询缓存"></a>开启查询缓存</h3><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>OFF 或 0</td><td>查询缓存功能关闭</td></tr><tr><td>ON 或 1</td><td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存</td></tr><tr><td>DEMAND 或 2</td><td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存</td></tr></tbody></table><p>在如下配置文件中，增加以下配置 ： </p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518191941302.png" alt="image-20210518191941302" style="zoom:67%;" /> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type&#x3D;1</span><br></pre></td></tr></table></figure><p>配置完毕之后，重启服务既可生效 ；之后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user_2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.91</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user_2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.05</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Qcache%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Qcache_free_blocks      <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_free_memory      <span class="operator">|</span> <span class="number">875448</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_hits             <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_inserts          <span class="operator">|</span> <span class="number">2</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_lowmem_prunes    <span class="operator">|</span> <span class="number">0</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_not_cached       <span class="operator">|</span> <span class="number">5</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_queries_in_cache <span class="operator">|</span> <span class="number">2</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_total_blocks     <span class="operator">|</span> <span class="number">6</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+--------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.08</span> sec)</span><br></pre></td></tr></table></figure><p>从上面的结果可知，第二次查询已经走了查询缓存，并且命中次数也已经增加。</p><h3 id="查询缓存SELECT选项"><a href="#查询缓存SELECT选项" class="headerlink" title="查询缓存SELECT选项"></a>查询缓存SELECT选项</h3><p>可以在SELECT语句中指定两个与查询缓存相关的选项 ：</p><p>SQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。</p><p>SQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_CACHE city_id, city_name <span class="keyword">FROM</span> city;</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE city_id, city_name <span class="keyword">FROM</span> city;</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="查询缓存失效的情况"><a href="#查询缓存失效的情况" class="headerlink" title="查询缓存失效的情况"></a>查询缓存失效的情况</h3><p>1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致，大小写也必须一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL1 : <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line">SQL2 : <span class="keyword">Select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><p>2） 当查询语句中有一些不确定的属性，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQL1 : <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> updatetime <span class="operator">&lt;</span> now() limit <span class="number">1</span>;</span><br><span class="line">SQL2 : <span class="keyword">select</span> <span class="keyword">user</span>();</span><br><span class="line">SQL3 : <span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure><p>3） 不使用任何表查询语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p>4）  查询 mysql， information_schema或  performance_schema 数据库中的表时，不会走查询缓存。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.engines;</span><br></pre></td></tr></table></figure><p>5） 在存储的函数，触发器或事件的主体内执行的查询。</p><p>6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用<code>MERGE</code>映射到已更改表的表的查询。一个表可以被许多类型的语句改变，如被 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 改变。</p><h2 id="MySQL内存管理及优化"><a href="#MySQL内存管理及优化" class="headerlink" title="MySQL内存管理及优化"></a>MySQL内存管理及优化</h2><h3 id="内存优化原则"><a href="#内存优化原则" class="headerlink" title="内存优化原则"></a>内存优化原则</h3><ol><li><p>尽量多的将内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。</p></li><li><p>MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。</p></li><li><p>排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</p></li></ol><h3 id="MyISAM-内存优化"><a href="#MyISAM-内存优化" class="headerlink" title="MyISAM 内存优化"></a>MyISAM 内存优化</h3><p>myisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。</p><h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>key_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。</p><p>在上图所示的my配置文件中做如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_buffer_size=512M</span><br></pre></td></tr></table></figure><h4 id="read-buffer-size"><a href="#read-buffer-size" class="headerlink" title="read_buffer_size"></a>read_buffer_size</h4><p>如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h4 id="read-rn-buffer-size"><a href="#read-rn-buffer-size" class="headerlink" title="read_rn_buffer_size"></a>read_rn_buffer_size</h4><p>对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h3 id="InnoDB-内存优化"><a href="#InnoDB-内存优化" class="headerlink" title="InnoDB 内存优化"></a>InnoDB 内存优化</h3><p>innodb 用一块内存区做IO缓存池，该缓存池不仅用来缓存 innodb 的索引块，而且也用来缓存 innodb 的数据块。</p><h4 id="innodb-buffer-pool-size"><a href="#innodb-buffer-pool-size" class="headerlink" title="innodb_buffer_pool_size"></a>innodb_buffer_pool_size</h4><p>该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问 InnoDB 表需要的磁盘I/O 就越少，性能也就越高。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size=512M</span><br></pre></td></tr></table></figure><h4 id="innodb-log-buffer-size"><a href="#innodb-log-buffer-size" class="headerlink" title="innodb_log_buffer_size"></a>innodb_log_buffer_size</h4><p>决定了 innodb 重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加 innodb_log_buffer_size 的大小，可以避免 innodb 在事务提交前就执行不必要的日志写入磁盘操作。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_log_buffer_size=10M</span><br></pre></td></tr></table></figure><h2 id="MySQL并发参数调整"><a href="#MySQL并发参数调整" class="headerlink" title="MySQL并发参数调整"></a>MySQL并发参数调整</h2><p>从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在MySQL中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。</p><h3 id="max-connections"><a href="#max-connections" class="headerlink" title="max_connections"></a>max_connections</h3><p>采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。</p><p>MySQL 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p><h3 id="back-log"><a href="#back-log" class="headerlink" title="back_log"></a>back_log</h3><p>back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySQL的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p><h3 id="table-open-cache"><a href="#table-open-cache" class="headerlink" title="table_open_cache"></a>table_open_cache</h3><p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_connections x N ;</span><br></pre></td></tr></table></figure><h3 id="thread-cache-size"><a href="#thread-cache-size" class="headerlink" title="thread_cache_size"></a>thread_cache_size</h3><p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。</p><h3 id="innodb-lock-wait-timeout"><a href="#innodb-lock-wait-timeout" class="headerlink" title="innodb_lock_wait_timeout"></a>innodb_lock_wait_timeout</h3><p>该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。</p><h2 id="MySQL锁问题"><a href="#MySQL锁问题" class="headerlink" title="MySQL锁问题"></a>MySQL锁问题</h2><h3 id="锁概述及分类"><a href="#锁概述及分类" class="headerlink" title="锁概述及分类"></a>锁概述及分类</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>从对数据操作的粒度分 ： </p><ol><li><p>表锁：操作时，会锁定整个表。</p></li><li><p>行锁：操作时，会锁定当前操作行。</p></li></ol><p>从对数据操作的类型分：</p><ol><li><p>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p></li><li><p>写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</p></li></ol><h3 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h3><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中列出了各存储引擎对锁的支持情况：<br>| 存储引擎 | 表级锁 | 行级锁 | 页面锁 |<br>| ——– | —— | —— | —— |<br>| MyISAM   | 支持   | 不支持 | 不支持 |<br>| InnoDB   | 支持   | 支持   | 不支持 |<br>| MEMORY   | 支持   | 不支持 | 不支持 |<br>| BDB      | 支持   | 不支持 | 支持   |</p><p>MySQL这3种锁的特性可大致归纳如下 ：</p><table><thead><tr><th>锁类型</th><th>特点</th></tr></thead><tbody><tr><td>表级锁</td><td>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td></tr><tr><td>行级锁</td><td>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td></tr><tr><td>页面锁</td><td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td></tr></tbody></table><p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</p><h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。</p><h4 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h4><p>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p><p>显示加表锁语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加读锁 ： lock <span class="keyword">table</span> table_name read;</span><br><span class="line"></span><br><span class="line">加写锁 ： lock <span class="keyword">table</span> table_name write；</span><br></pre></td></tr></table></figure><h4 id="读锁案例"><a href="#读锁案例" class="headerlink" title="读锁案例"></a>读锁案例</h4><p>准备环境：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_book` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `publish_time` <span class="type">DATE</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>myisam <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;java编程思想&#x27;</span>,<span class="string">&#x27;2088-08-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;solr编程思想&#x27;</span>,<span class="string">&#x27;2088-08-08&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>myisam <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user (id, name) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;令狐冲&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user (id, name) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;田伯光&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端 一 ：</p><p>1）获得tb_book 表的读锁 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock <span class="keyword">table</span> tb_book read;</span><br></pre></td></tr></table></figure><p>2） 执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+--------------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> publish_time <span class="operator">|</span> status <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+--------------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> java编程思想 <span class="operator">|</span> <span class="number">2088</span><span class="number">-08</span><span class="number">-01</span>   <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> solr编程思想 <span class="operator">|</span> <span class="number">2088</span><span class="number">-08</span><span class="number">-08</span>   <span class="operator">|</span> <span class="number">0</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+--------------+--------+</span></span><br></pre></td></tr></table></figure><p>可以正常执行 ， 查询出数据。</p><p>客户端 二 ：</p><p>3） 执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+--------------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> publish_time <span class="operator">|</span> status <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+--------------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> java编程思想 <span class="operator">|</span> <span class="number">2088</span><span class="number">-08</span><span class="number">-01</span>   <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> solr编程思想 <span class="operator">|</span> <span class="number">2088</span><span class="number">-08</span><span class="number">-08</span>   <span class="operator">|</span> <span class="number">0</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+--------------+--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.05</span> sec)</span><br></pre></td></tr></table></figure><p>客户端 一 ：</p><p>4）查询未锁定的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> tb_seller;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> name <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="number">1100</span> <span class="operator">-</span> <span class="keyword">Table</span> <span class="string">&#x27;tb_seller&#x27;</span> was <span class="keyword">not</span> locked <span class="keyword">with</span> LOCK TABLES</span><br></pre></td></tr></table></figure><p>客户端 二 ：</p><p>5）查询未锁定的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> tb_seller;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> name <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> name                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> OPPO科技有限公司         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 传智播客教育科技有限公司 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 千度科技                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 华为科技有限公司         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 宜家家居                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 小米科技                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 掌趣科技股份有限公司     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 新浪科技有限公司         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 百度科技有限公司         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 罗技科技有限公司         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 阿里巴巴                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 黑马程序员               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br></pre></td></tr></table></figure><p>可以正常查询出未锁定的表；</p><p>客户端 一 ：</p><p>6） 执行插入操作 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Mysql高级&#x27;</span>,<span class="string">&#x27;2088-01-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Mysql高级&#x27;</span>,<span class="string">&#x27;2088-01-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="number">1099</span> <span class="operator">-</span> <span class="keyword">Table</span> <span class="string">&#x27;tb_book&#x27;</span> was locked <span class="keyword">with</span> a READ lock <span class="keyword">and</span> can<span class="string">&#x27;t be updated</span></span><br></pre></td></tr></table></figure><p>执行插入， 直接报错 ， 由于当前 tb_book 获得的是读锁， 不能执行更新操作。</p><p>客户端 二 ：</p><p>7） 执行插入操作 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Mysql高级&#x27;</span>,<span class="string">&#x27;2088-01-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518201017343.png" alt="image-20210518201017343" style="zoom: 50%;" /> <p>当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 inesrt 语句 ， 立即执行 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Mysql高级&#x27;</span>,<span class="string">&#x27;2088-01-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">86.41</span> sec)</span><br></pre></td></tr></table></figure><h4 id="写锁案例"><a href="#写锁案例" class="headerlink" title="写锁案例"></a>写锁案例</h4><p>客户端 一 :</p><p>1）获得tb_book 表的写锁 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock <span class="keyword">table</span> tb_book write ;</span><br></pre></td></tr></table></figure><p>2）执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book ;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+--------------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> publish_time <span class="operator">|</span> status <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+--------------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> java编程思想 <span class="operator">|</span> <span class="number">2088</span><span class="number">-08</span><span class="number">-01</span>   <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> solr编程思想 <span class="operator">|</span> <span class="number">2088</span><span class="number">-08</span><span class="number">-08</span>   <span class="operator">|</span> <span class="number">0</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Mysql高级    <span class="operator">|</span> <span class="number">2088</span><span class="number">-01</span><span class="number">-01</span>   <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+--------------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.10</span> sec)</span><br></pre></td></tr></table></figure><p>查询操作执行成功；</p><p>3）执行更新操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_book <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;java编程思想（第二版）&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> update tb_book <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;java编程思想（第二版）&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.04</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>更新操作执行成功 。</p><p>客户端 二 :</p><p>4）执行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_book ;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518201427139.png" alt="image-20210518201427139" style="zoom: 50%;" /> <p>当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 select 语句 ， 立即执行 ；</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518201459651.png" alt="image-20210518201459651" style="zoom: 50%;" /> <h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>锁模式的相互兼容性如表中所示：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1553905621992.png" alt="img" style="zoom: 80%;" /><p>由上表可见： </p><p>​    1. 对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</p><p>​    2. 对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</span><br></pre></td></tr></table></figure><p>此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h4 id="查看锁的争用情况"><a href="#查看锁的争用情况" class="headerlink" title="查看锁的争用情况"></a>查看锁的争用情况</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518202136787.png" alt="image-20210518202136787" style="zoom: 67%;" /><p>In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。</p><p>Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Table_locks%&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Table_locks%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Table_locks_immediate <span class="operator">|</span> <span class="number">114</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Table_locks_waited    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.15</span> sec)</span><br></pre></td></tr></table></figure><p>Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。</p><p>Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</p><h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><h4 id="行锁介绍"><a href="#行锁介绍" class="headerlink" title="行锁介绍"></a>行锁介绍</h4><p>行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是采用了行级锁。</p><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><p><strong>事务的ACID属性</strong></p><table><thead><tr><th>ACID属性</th><th>含义</th></tr></thead><tbody><tr><td>原子性（Atomicity）</td><td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。</td></tr><tr><td>一致性（Consistent）</td><td>在事务开始和完成时，数据都必须保持一致状态。</td></tr><tr><td>隔离性（Isolation）</td><td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。</td></tr><tr><td>持久性（Durable）</td><td>事务完成之后，对于数据的修改是永久的。</td></tr></tbody></table><p><strong>并发事务处理带来的问题</strong></p><table><thead><tr><th>问题</th><th>含义</th></tr></thead><tbody><tr><td>丢失更新（Lost Update）</td><td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。</td></tr><tr><td>脏读（Dirty Reads）</td><td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td></tr><tr><td>不可重复读（Non-Repeatable Reads）</td><td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。</td></tr><tr><td>幻读（Phantom Reads）</td><td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td></tr></tbody></table><p><strong>事务隔离级别</strong></p><p>为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。 </p><p>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>丢失更新</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read（默认）</td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><blockquote><p>备注 ： √  代表可能出现 ， × 代表不会出现 。</p></blockquote><p>MySQL的数据库的默认隔离级别为 Repeatable read ， 查看方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> tx_isolation  <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.12</span> sec)</span><br></pre></td></tr></table></figure><h4 id="InnoDB-的行锁模式"><a href="#InnoDB-的行锁模式" class="headerlink" title="InnoDB 的行锁模式"></a>InnoDB 的行锁模式</h4><p>InnoDB  实现了以下两种类型的行锁。</p><ul><li><p>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p></li><li><p>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p></li><li><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</p></li><li><p>对于普通SELECT语句，InnoDB不会加任何锁。</p></li></ul><p>可以通过以下语句显示给记录集加共享锁或排他锁 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line"></span><br><span class="line">排他锁（X) ：SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure><h4 id="案例准备工作"><a href="#案例准备工作" class="headerlink" title="案例准备工作"></a>案例准备工作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_innodb_lock(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>),</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">1</span>)</span><br><span class="line">)engine <span class="operator">=</span> innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;400&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;500&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;600&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;700&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">&#x27;800&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">&#x27;900&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;200&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index idx_test_innodb_lock_id <span class="keyword">on</span> test_innodb_lock(id);</span><br><span class="line"><span class="keyword">create</span> index idx_test_innodb_lock_name <span class="keyword">on</span> test_innodb_lock(name);</span><br></pre></td></tr></table></figure><h4 id="行锁基本演示"><a href="#行锁基本演示" class="headerlink" title="行锁基本演示"></a>行锁基本演示</h4><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210156129.png" alt="image-20210518210156129" style="zoom:67%;" /><br/>关闭自动提交功能</td><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210219856.png" alt="image-20210518210219856" style="zoom:67%;" />  <br/>关闭自动提交功能</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210332599.png" alt="image-20210518210332599" style="zoom:67%;" /> <br/>可以正常的查询出全部的数据</td><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210349824.png" alt="image-20210518210349824" style="zoom:67%;" /> <br/>可以正常的查询出全部的数据</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210426841.png" alt="image-20210518210426841" style="zoom:67%;" />查询id 为3的数据 ；</td><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210436934.png" alt="image-20210518210436934" style="zoom:67%;" />获取id为3的数据 ；</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210554412.png" alt="image-20210518210554412" style="zoom:67%;" /> 更新id为3的数据，但是不提交；</td><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518213328713.png" alt="image-20210518213328713" style="zoom:150%;" />更新id为3 的数据， 处于等待状态</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518211809494.png" alt="image-20210518211809494" style="zoom:150%;" /> 通过commit， 提交事务</td><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210717517.png" alt="image-20210518210717517" style="zoom:67%;" /> 解除阻塞，更新正常进行</td></tr><tr><td>以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ：</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210801669.png" alt="image-20210518210801669" style="zoom:150%;" /> 更新id为3数据，正常的获取到行锁 ， 执行更新 ；</td><td><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210831154.png" alt="image-20210518210831154" style="zoom:67%;" /> 由于与Session-1 操作不是同一行，获取当前行锁，执行更新；</td></tr></tbody></table><h4 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h4><p>如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p><p>查看当前表的索引 ： show  index  from test_innodb_lock ;</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518211018083.png" alt="image-20210518211018083"  /> <table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td>关闭事务的自动提交<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210156129.png" alt="image-20210518210156129" style="zoom: 50%;" /></td><td>关闭事务的自动提交<br/><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518210156129.png" alt="image-20210518210156129" style="zoom: 50%;" /></td></tr><tr><td>执行更新语句 ：<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518211639732.png" alt="image-20210518211639732" style="zoom: 200%;" /></td><td>执行更新语句， 但处于阻塞状态：<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518211748011.png" alt="image-20210518211748011" style="zoom: 200%;" /></td></tr><tr><td>提交事务：<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518211809494.png" alt="image-20210518211809494" style="zoom:150%;" /></td><td>解除阻塞，执行更新成功 ：<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518211826968.png" alt="image-20210518211826968"></td></tr><tr><td></td><td>执行提交操作 ：<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518211949350.png" alt="image-20210518211949350" style="zoom: 50%;" /></td></tr></tbody></table><p>由于 执行更新时 ， name字段本来为varchar类型， 这里是作为数组类型使用，存在类型转换，索引失效，最终行锁变为表锁 ；</p><h4 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h4><p>当用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。</p><h4 id="InnoDB-行锁争用情况"><a href="#InnoDB-行锁争用情况" class="headerlink" title="InnoDB 行锁争用情况"></a>InnoDB 行锁争用情况</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span>  status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210518211525007.png" alt="image-20210518211525007" style="zoom:67%;" /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Innodb_row_lock_current_waits: 当前正在等待锁定的数量</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_time: 从系统启动到现在锁定总时间长度</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_time_avg:每次等待所花平均时长</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_waits: 系统启动后到现在总共等待的次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p><p>优化建议：</p><ul><li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。</li><li>合理设计索引，尽量缩小锁的范围。</li><li>尽可能减少索引条件，及索引范围，避免间隙锁。</li><li>尽量控制事务大小，减少锁定资源量和时间长度。</li><li>尽可使用低级别事务隔离（但是需要业务层面满足需求）。</li></ul><h2 id="常用SQL技巧"><a href="#常用SQL技巧" class="headerlink" title="常用SQL技巧"></a>常用SQL技巧</h2><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><p>编写顺序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="operator">&lt;</span>left_table<span class="operator">&gt;</span> <span class="operator">&lt;</span>join_type<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line"><span class="operator">&lt;</span>right_table<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span></span><br><span class="line">LIMIT</span><br><span class="line"><span class="operator">&lt;</span>limit_params<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>执行顺序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span><span class="operator">&lt;</span>left_table<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>join_type<span class="operator">&gt;</span><span class="keyword">JOIN</span><span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span><span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">HAVING</span><span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span><span class="operator">&lt;</span><span class="keyword">select</span> list<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span><span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">LIMIT<span class="operator">&lt;</span>limit_params<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式使用"><a href="#正则表达式使用" class="headerlink" title="正则表达式使用"></a>正则表达式使用</h3><p>正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>在字符串开始处进行匹配</td></tr><tr><td>$</td><td>在字符串末尾处进行匹配</td></tr><tr><td>.</td><td>匹配任意单个字符, 包括换行符</td></tr><tr><td>[…]</td><td>匹配出括号内的任意字符</td></tr><tr><td>[^…]</td><td>匹配不出括号内的任意字符</td></tr><tr><td>a*</td><td>匹配零个或者多个a(包括空串)</td></tr><tr><td>a+</td><td>匹配一个或者多个a(不包括空串)</td></tr><tr><td>a?</td><td>匹配零个或者一个a</td></tr><tr><td>a1|a2</td><td>匹配a1或a2</td></tr><tr><td>a(m)</td><td>匹配m个a</td></tr><tr><td>a(m,)</td><td>至少匹配m个a</td></tr><tr><td>a(m,n)</td><td>匹配m个a 到 n个a</td></tr><tr><td>a(,n)</td><td>匹配0到n个a</td></tr><tr><td>(…)</td><td>将模式元素组成单一元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where name regexp &#39;^T&#39;;</span><br><span class="line"></span><br><span class="line">select * from emp where name regexp &#39;2$&#39;;</span><br><span class="line"></span><br><span class="line">select * from emp where name regexp &#39;[uvw]&#39;;</span><br></pre></td></tr></table></figure><h3 id="MySQL-常用函数"><a href="#MySQL-常用函数" class="headerlink" title="MySQL 常用函数"></a>MySQL 常用函数</h3><p>数字函数：</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>ABS</td><td>求绝对值</td></tr><tr><td>SQRT</td><td>求二次方根</td></tr><tr><td>MOD</td><td>求余数</td></tr><tr><td>CEIL 和 CEILING</td><td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td></tr><tr><td>FLOOR</td><td>向下取整，返回值转化为一个BIGINT</td></tr><tr><td>RAND</td><td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td></tr><tr><td>ROUND</td><td>对所传参数进行四舍五入</td></tr><tr><td>SIGN</td><td>返回参数的符号</td></tr><tr><td>POW 和 POWER</td><td>两个函数的功能相同，都是所传参数的次方的结果值</td></tr><tr><td>SIN</td><td>求正弦值</td></tr><tr><td>ASIN</td><td>求反正弦值，与函数 SIN 互为反函数</td></tr><tr><td>COS</td><td>求余弦值</td></tr><tr><td>ACOS</td><td>求反余弦值，与函数 COS 互为反函数</td></tr><tr><td>TAN</td><td>求正切值</td></tr><tr><td>ATAN</td><td>求反正切值，与函数 TAN 互为反函数</td></tr><tr><td>COT</td><td>求余切值</td></tr></tbody></table><p>字符串函数：</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>LENGTH</td><td>计算字符串长度函数，返回字符串的字节长度</td></tr><tr><td>CONCAT</td><td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td></tr><tr><td>INSERT</td><td>替换字符串函数</td></tr><tr><td>LOWER</td><td>将字符串中的字母转换为小写</td></tr><tr><td>UPPER</td><td>将字符串中的字母转换为大写</td></tr><tr><td>LEFT</td><td>从左侧字截取符串，返回字符串左边的若干个字符</td></tr><tr><td>RIGHT</td><td>从右侧字截取符串，返回字符串右边的若干个字符</td></tr><tr><td>TRIM</td><td>删除字符串左右两侧的空格</td></tr><tr><td>REPLACE</td><td>字符串替换函数，返回替换后的新字符串</td></tr><tr><td>SUBSTRING</td><td>截取字符串，返回从指定位置开始的指定长度的字符换</td></tr><tr><td>REVERSE</td><td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td></tr></tbody></table><p>日期函数：</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>CURDATE 和 CURRENT_DATE</td><td>两个函数作用相同，返回当前系统的日期值</td></tr><tr><td>CURTIME 和 CURRENT_TIME</td><td>两个函数作用相同，返回当前系统的时间值</td></tr><tr><td>NOW 和  SYSDATE</td><td>两个函数作用相同，返回当前系统的日期和时间值</td></tr><tr><td>MONTH</td><td>获取指定日期中的月份</td></tr><tr><td>MONTHNAME</td><td>获取指定日期中的月份英文名称</td></tr><tr><td>DAYNAME</td><td>获取指定曰期对应的星期几的英文名称</td></tr><tr><td>DAYOFWEEK</td><td>获取指定日期对应的一周的索引位置值</td></tr><tr><td>WEEK</td><td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td></tr><tr><td>DAYOFYEAR</td><td>获取指定曰期是一年中的第几天，返回值范围是1~366</td></tr><tr><td>DAYOFMONTH</td><td>获取指定日期是一个月中是第几天，返回值范围是1~31</td></tr><tr><td>YEAR</td><td>获取年份，返回值范围是 1970〜2069</td></tr><tr><td>TIME_TO_SEC</td><td>将时间参数转换为秒数</td></tr><tr><td>SEC_TO_TIME</td><td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td></tr><tr><td>DATE_ADD 和 ADDDATE</td><td>两个函数功能相同，都是向日期添加指定的时间间隔</td></tr><tr><td>DATE_SUB 和 SUBDATE</td><td>两个函数功能相同，都是向日期减去指定的时间间隔</td></tr><tr><td>ADDTIME</td><td>时间加法运算，在原始时间上添加指定的时间</td></tr><tr><td>SUBTIME</td><td>时间减法运算，在原始时间上减去指定的时间</td></tr><tr><td>DATEDIFF</td><td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td></tr><tr><td>DATE_FORMAT</td><td>格式化指定的日期，根据参数返回指定格式的值</td></tr><tr><td>WEEKDAY</td><td>获取指定日期在一周内的对应的工作日索引</td></tr></tbody></table><p>聚合函数：</p><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>MAX</td><td>查询指定列的最大值</td></tr><tr><td>MIN</td><td>查询指定列的最小值</td></tr><tr><td>COUNT</td><td>统计查询结果的行数</td></tr><tr><td>SUM</td><td>求和，返回指定列的总和</td></tr><tr><td>AVG</td><td>求平均值，返回指定列数据的平均值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> mysql </tag>
            
            <tag> 锁 </tag>
            
            <tag> 使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级—索引、视图、触发器</title>
      <link href="2021/03/20/MySQL%E9%AB%98%E7%BA%A7%E2%80%94%E7%B4%A2%E5%BC%95%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>2021/03/20/MySQL%E9%AB%98%E7%BA%A7%E2%80%94%E7%B4%A2%E5%BC%95%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第1条记录开始读完整个表，直到找出相关的行。表越大，查询数据所花费的时间越多。如果表中查询的列有一个索引，MySQL能快速到达某个位置去搜寻数据文件，而不必查看所有数据。</p><p><strong>MySQL</strong>官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的示意图所示 : </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/1555902055367.png" alt="img"></p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</p><h3 id="索引优势劣势"><a href="#索引优势劣势" class="headerlink" title="索引优势劣势"></a>索引优势劣势</h3><p><strong>优势</strong></p><ul><li><p>通过创建唯一索引，可以保证数据库表中每一行数据的唯一 性。</p></li><li><p>可以大大加快数据的查询速度，这也是创建索引的最主要的原因。</p></li><li><p>在实现数据的参考完整性方面，可以加速表和表之间的连接。</p></li><li><p>在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。</p></li><li><p>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p></li></ul><p><strong>劣势</strong></p><ul><li><p>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。而实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。</p></li><li><p>虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p></li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p><ul><li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li><li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li><li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li><li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li></ul><center><b>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</b></center><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。</p><h4 id="BTREE-结构"><a href="#BTREE-结构" class="headerlink" title="BTREE 结构"></a>BTREE 结构</h4><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p><ul><li>树中每个节点最多包含m个孩子。</li><li>除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。</li><li>若根节点不是叶子节点，则至少有两个孩子。</li><li>所有的叶子节点都在同一层。</li><li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1 </li></ul><p>以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。</p><p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p><p><strong>演变过程如下：</strong></p><p>1). 插入前4个字母 C N G A </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509150725663.png" alt="image-20210509150725663"></p><p>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509151445248.png" alt="image-20210509151445248"></p><p>3). 插入E，K，Q不需要分裂</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509151405735.png" alt="image-20210509151405735"></p><p>4). 插入M，中间元素M字母向上分裂到父节点G</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509151524511.png" alt="image-20210509151524511"></p><p>5). 插入F，W，L，T不需要分裂</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509151610632.png" alt="image-20210509151610632"></p><p>6). 插入Z，中间元素T向上分裂到父节点中 </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509151637065.png" alt="image-20210509151637065"></p><p>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509151704163.png" alt="image-20210509151704163"></p><p>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509151732707.png" alt="image-20210509151732707"></p><p>到此，该BTREE树就已经构建完成了， BTREE树和二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</p><h4 id="B-TREE-结构"><a href="#B-TREE-结构" class="headerlink" title="B+TREE 结构"></a>B+TREE 结构</h4><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p><ol><li><p> n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。</p></li><li><p>B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。</p></li><li><p>所有的非叶子节点都可以看作是key的索引部分。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509152053832.png" alt="image-20210509152053832"></p><p>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。</p><h4 id="MySQL中的B-Tree"><a href="#MySQL中的B-Tree" class="headerlink" title="MySQL中的B+Tree"></a>MySQL中的B+Tree</h4><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p>MySQL中的 B+Tree 索引结构示意图: </p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210509152148351.png" alt="image-20210509152148351"></p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ol><li><p>单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引。</p></li><li><p>唯一索引 ：索引列的值必须唯一，但允许有空值。</p></li><li><p>复合索引 ：即一个索引包含多个列。</p></li><li><p>全文索引：在定义索引的列上支持值的全文查找，允许在这些索引列插入重复值和空值。</p></li></ol><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p><p>准备环境:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database demo_01 <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `city` (</span><br><span class="line">  `city_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `city_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `country_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`city_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `country` (</span><br><span class="line">  `country_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `country_name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`country_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;西安&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;China&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;America&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Japan&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;UK&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>语法 ：     </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL]  INDEX index_name </span><br><span class="line">[<span class="keyword">USING</span>  index_type]</span><br><span class="line"><span class="keyword">ON</span> tbl_name(index_col_name,...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index_col_name : column_name[(length)][<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p>示例 ： 为city表中的city_name字段创建索引 ；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> index idx_city_name <span class="keyword">on</span> city(city_name);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.07</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><p>语法： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index  <span class="keyword">from</span>  table_name;</span><br></pre></td></tr></table></figure><p>示例：查看city表中的索引信息；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> index <span class="keyword">from</span> city;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name      <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> city  <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> city_id     <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">4</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> city  <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_city_name <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> city_name   <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.14</span> sec)</span><br></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>语法 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  INDEX  index_name  <span class="keyword">ON</span>  tbl_name;</span><br></pre></td></tr></table></figure><p>示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">drop</span> index idx_city_name <span class="keyword">on</span> city;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="ALTER命令"><a href="#ALTER命令" class="headerlink" title="ALTER命令"></a>ALTER命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  <span class="keyword">primary</span>  key(column_list); </span><br><span class="line"></span><br><span class="line">该语句添加一个主键，这意味着索引值必须是唯一的，且不能为<span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) <span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  <span class="keyword">unique</span> index_name(column_list);</span><br><span class="line"></span><br><span class="line">这条语句创建索引的值必须是唯一的（除了<span class="keyword">NULL</span>外，<span class="keyword">NULL</span>可能会出现多次）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) <span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  index index_name(column_list);</span><br><span class="line"></span><br><span class="line">添加普通索引， 索引值可以出现多次。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) <span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  fulltext  index_name(column_list);</span><br><span class="line"></span><br><span class="line">该语句指定了索引为FULLTEXT， 用于全文索引</span><br></pre></td></tr></table></figure><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p>​    索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p><ul><li><p>对查询频次较高，且数据量比较大的表建立索引。</p></li><li><p>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</p></li><li><p>使用唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</p></li><li><p>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。</p></li><li><p>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建复合索引:</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_email_status <span class="keyword">ON</span> tb_seller(NAME,email,STATUS);</span><br><span class="line"></span><br><span class="line">就相当于</span><br><span class="line">对name 创建索引 ;</span><br><span class="line">对name , email 创建了索引 ;</span><br><span class="line">对name , email, status 创建了索引 ;</span><br></pre></td></tr></table></figure></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图概述"><a href="#视图概述" class="headerlink" title="视图概述"></a>视图概述</h3><p>视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><p>视图相对于普通的表的优势主要包括以下几项。</p><ul><li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</li><li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li><li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</li></ul><h3 id="创建或者修改视图"><a href="#创建或者修改视图" class="headerlink" title="创建或者修改视图"></a>创建或者修改视图</h3><p>创建视图的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line"></span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><p>修改视图的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line"></span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选项 : </span><br><span class="line"><span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION 决定了是否允许更新数据使记录不再满足视图的条件。</span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCAL</span> ： 只要满足本视图的条件就可以更新。</span><br><span class="line"><span class="keyword">CASCADED</span> ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.</span><br></pre></td></tr></table></figure><p>示例 , 创建city_country_view视图 , 执行如下SQL : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> city_country_view </span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> t.<span class="operator">*</span>,c.country_name <span class="keyword">from</span> country c , city t <span class="keyword">where</span> c.country_id <span class="operator">=</span> t.country_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询视图 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> city_country_view;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----------+------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> city_id <span class="operator">|</span> city_name <span class="operator">|</span> country_id <span class="operator">|</span> country_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----------+------------+--------------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span> 西安      <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> China        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span> 北京      <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> China        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span> 上海      <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> China        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span> 上海      <span class="operator">|</span>          <span class="number">2</span> <span class="operator">|</span> America      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----------+------------+--------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.17</span> sec)</span><br></pre></td></tr></table></figure><h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><p>从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_test    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> accout            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> book              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> books             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> city              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> city_country_view <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> country           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> customers         <span class="operator">|</span></span><br></pre></td></tr></table></figure><p>同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">table</span> status;</span><br><span class="line"> Name              <span class="operator">|</span> Engine <span class="operator">|</span> Version <span class="operator">|</span> Row_format <span class="operator">|</span> <span class="keyword">Rows</span> <span class="operator">|</span> Avg_row_length <span class="operator">|</span> Data_length <span class="operator">|</span> Max_data_length <span class="operator">|</span> Index_length <span class="operator">|</span> Data_free <span class="operator">|</span> Auto_increment <span class="operator">|</span> Create_time         <span class="operator">|</span> Update_time         <span class="operator">|</span> Check_time <span class="operator">|</span> <span class="keyword">Collation</span>       <span class="operator">|</span> Checksum <span class="operator">|</span> Create_options <span class="operator">|</span> Comment <span class="operator">|</span></span><br><span class="line"> </span><br><span class="line"> city_country_view <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>           <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span>      <span class="operator">|</span> <span class="keyword">NULL</span>   </span><br></pre></td></tr></table></figure><p>如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> city_country_view;;</span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">View</span>              <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">View</span>                                                                                                                                                                                                                                                                                                                    <span class="operator">|</span> character_set_client <span class="operator">|</span> collation_connection <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+</span></span><br><span class="line"><span class="operator">|</span> city_country_view <span class="operator">|</span> <span class="keyword">CREATE</span> ALGORITHM<span class="operator">=</span>UNDEFINED DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">SQL</span> SECURITY DEFINER <span class="keyword">VIEW</span> `city_country_view` <span class="keyword">AS</span> <span class="keyword">select</span> `t`.`city_id` <span class="keyword">AS</span> `city_id`,`t`.`city_name` <span class="keyword">AS</span> `city_name`,`t`.`country_id` <span class="keyword">AS</span> `country_id`,`c`.`country_name` <span class="keyword">AS</span> `country_name` <span class="keyword">from</span> (`country` `c` <span class="keyword">join</span> `city` `t`) <span class="keyword">where</span> (`c`.`country_id` <span class="operator">=</span> `t`.`country_id`) <span class="operator">|</span> utf8mb4              <span class="operator">|</span> utf8mb4_general_ci   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.15</span> sec)</span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>语法 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name [, view_name] ...[RESTRICT <span class="operator">|</span> CASCADE];</span><br></pre></td></tr></table></figure><p>示例 , 删除视图city_country_view :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> city_country_view ;</span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p><p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD的使用</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name </span><br><span class="line"></span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span>update<span class="operator">/</span><span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> tbl_name </span><br><span class="line"></span><br><span class="line">[ <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> ]  <span class="comment">-- 行级触发器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">trigger_stmt ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>示例需求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;</span><br></pre></td></tr></table></figure><p>首先创建一张日志表 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_logs(</span><br><span class="line">  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">  operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作类型, insert/update/delete&#x27;</span>,</span><br><span class="line">  operate_time datetime <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  operate_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作表的ID&#x27;</span>,</span><br><span class="line">  operate_params <span class="type">varchar</span>(<span class="number">500</span>) comment <span class="string">&#x27;操作参数&#x27;</span>,</span><br><span class="line">  <span class="keyword">primary</span> key(`id`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>创建 insert 型触发器，完成插入数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_insert_trigger</span><br><span class="line">after <span class="keyword">insert</span> </span><br><span class="line"><span class="keyword">on</span> emp </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;插入后(id:&#x27;</span>,new.id,<span class="string">&#x27;, name:&#x27;</span>,new.name,<span class="string">&#x27;, age:&#x27;</span>,new.age,<span class="string">&#x27;, salary:&#x27;</span>,new.salary,<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建 update 型触发器，完成更新数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_update_trigger</span><br><span class="line">after update </span><br><span class="line"><span class="keyword">on</span> emp </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;修改前(id:&#x27;</span>,old.id,<span class="string">&#x27;, name:&#x27;</span>,old.name,<span class="string">&#x27;, age:&#x27;</span>,old.age,<span class="string">&#x27;, salary:&#x27;</span>,old.salary,<span class="string">&#x27;) , 修改后(id&#x27;</span>,new.id, <span class="string">&#x27;name:&#x27;</span>,new.name,<span class="string">&#x27;, age:&#x27;</span>,new.age,<span class="string">&#x27;, salary:&#x27;</span>,new.salary,<span class="string">&#x27;)&#x27;</span>));                                                                      </span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建delete 行的触发器 , 完成删除数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_delete_trigger</span><br><span class="line">after <span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">on</span> emp </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;delete&#x27;</span>,now(),old.id,concat(<span class="string">&#x27;删除前(id:&#x27;</span>,old.id,<span class="string">&#x27;, name:&#x27;</span>,old.name,<span class="string">&#x27;, age:&#x27;</span>,old.age,<span class="string">&#x27;, salary:&#x27;</span>,old.salary,<span class="string">&#x27;)&#x27;</span>));                                                                      </span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="string">&#x27;光明左使&#x27;</span>,<span class="number">30</span>,<span class="number">3500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="string">&#x27;光明右使&#x27;</span>,<span class="number">33</span>,<span class="number">3200</span>);</span><br><span class="line"></span><br><span class="line">update emp <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">39</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name;</span><br></pre></td></tr></table></figure><p>如果没有指定 schema_name，默认为当前数据库 。</p><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><p>可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。</p><p>语法结构 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers ;</span><br></pre></td></tr></table></figure><h3 id="触发器注意"><a href="#触发器注意" class="headerlink" title="触发器注意"></a>触发器注意</h3><ol><li><p>在使用触发器的时候需要注意，对于相同的表，相同的事件只能创建一个触发器。</p></li><li><p>及时删除不再需要的触发器。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 索引 </tag>
            
            <tag> 视图 </tag>
            
            <tag> 触发器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库面试题</title>
      <link href="2021/03/14/Database/"/>
      <url>2021/03/14/Database/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="数据库事务的概念和特性？"><a href="#数据库事务的概念和特性？" class="headerlink" title="数据库事务的概念和特性？"></a>数据库事务的概念和特性？</h2><p><strong>概念</strong>：事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束。</p><p><strong>特性（ACID）：</strong></p><ul><li><strong>原子性</strong>（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）。</li><li><strong>一致性</strong>（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li><li><strong>隔离性</strong>（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）。</li><li><strong>持久性</strong>（Durability）：一旦事务提交成功，对数据的修改是永久性的。</li></ul><h2 id="数据库会出现哪些并发一致性问题？"><a href="#数据库会出现哪些并发一致性问题？" class="headerlink" title="数据库会出现哪些并发一致性问题？"></a>数据库会出现哪些并发一致性问题？</h2><ul><li><strong>丢失修改</strong>：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改。</li><li><strong>脏读</strong>（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致。</li><li><strong>不可重复读</strong>（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对<strong>update</strong>操作）。</li><li><strong>幻读</strong>（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对<strong>insert/delete</strong>操作）。</li></ul><h2 id="数据库的四种隔离级别？"><a href="#数据库的四种隔离级别？" class="headerlink" title="数据库的四种隔离级别？"></a>数据库的四种隔离级别？</h2><ul><li><strong>未提交读</strong>（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读。</li><li><strong>提交读</strong>（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题。</li><li><strong>可重复读</strong>（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读。</li><li><strong>可串行化</strong>（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题，可能导致大量的超时现象和锁竞争，实际很少使用。</li></ul><h2 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h2><ul><li><strong>悲观锁</strong>：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据。应用于<strong>数据更新比较频繁</strong>的场景。</li><li><strong>乐观锁</strong>：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试。适用于<strong>读多写少</strong>的场景。乐观锁的实现方式有：<ul><li>加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段。</li><li>先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。</li></ul></li></ul><h2 id="数据库常见的封锁类型？"><a href="#数据库常见的封锁类型？" class="headerlink" title="数据库常见的封锁类型？"></a>数据库常见的封锁类型？</h2><p>意向锁是 InnoDB 自动加的， 不需用户干预。 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)；<br>对于普通 SELECT 语句，InnoDB 不会加任何锁。</p><p>事务可以通过以下语句显式给记录集加共享锁或排他锁：</p><ol><li><p>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</p></li><li><p>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁。</p></li></ol><ul><li><strong>排它锁</strong>（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁。</li><li><strong>共享锁</strong>（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁。</li><li><strong>意向锁</strong>（Intention Locks）：<ul><li>一个事务在获得某个<strong>数据行</strong>对象的 S 锁之前，必须先获得<strong>整个表</strong>的 IS 锁或更强的锁。</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁。</li><li>IS/IX 锁之间都是兼容的。</li><li>好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了。</li></ul></li></ul><blockquote><p><strong>锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性</strong>。</p></blockquote><p><strong>封锁粒度的概念</strong></p><p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p><p>封锁粒度小：</p><ul><li>好处：锁定的数据量越少，发生锁争用的可能就越小，系统的<strong>并发程度</strong>就越高。</li><li>坏处：<strong>系统开销</strong>大（加锁、释放锁、检查锁的状态都需要消耗资源）。</li></ul><h2 id="什么是三级封锁协议？"><a href="#什么是三级封锁协议？" class="headerlink" title="什么是三级封锁协议？"></a>什么是三级封锁协议？</h2><ul><li>一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）。</li><li>二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）。</li><li>三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）。</li></ul><h2 id="什么是两段锁协议？"><a href="#什么是两段锁协议？" class="headerlink" title="什么是两段锁协议？"></a>什么是两段锁协议？</h2><p>事务必须严格分为两个阶段对数据进行<strong>加锁和解锁</strong>的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。</p><p><strong>可串行化调度</strong>是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。</p><h2 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h2><p><strong>多版本并发控制</strong>（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储<strong>创建版本号</strong>和<strong>删除版本号</strong>。</p><ul><li>创建版本号：创建一个数据行时的事务版本号（<strong>事务版本号</strong>：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）。</li><li>删除版本号：删除操作时的事务版本号。</li><li>各种操作：<ul><li>插入操作时，记录创建版本号；</li><li>删除操作时，记录删除版本号；</li><li>更新操作时，先记录删除版本号，再新增一行记录创建版本号；</li><li>查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）。</li></ul></li></ul><p>通过版本号减少了锁的争用，<strong>提高了系统性能</strong>。可以实现<strong>提交读</strong>和<strong>可重复读</strong>两种隔离级别，未提交读无需使用MVCC。</p><p><strong>快照读与当前读</strong></p><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure><p>当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> update;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line">update;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h2 id="数据库的范式？"><a href="#数据库的范式？" class="headerlink" title="数据库的范式？"></a>数据库的范式？</h2><ul><li><strong>第一范式</strong>（1NF，Normal Form）：<strong>属性不应该是可分的</strong>。举例：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话…如果将“移动电话”作为一个属性，就符合1NF。</li><li><strong>第二范式</strong> 2NF：每个非主属性<strong>完全依赖</strong>于主属性集（候选键集）：<ul><li>B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集。</li><li>主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性。</li><li>可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余；<br>满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情。</li></ul></li><li><strong>第三范式</strong> 3NF：在 2NF 的基础上，非主属性<strong>不传递依赖</strong>于主属性。<ul><li>传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A。</li><li>3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）。</li></ul></li></ul><p><strong>不符合范式会出现哪些异常？</strong></p><ul><li>冗余数据：某些同样的数据多次出现（如学生姓名）。</li><li>修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）。</li><li>插入异常：无法插入（插入一个还没有课程信息的学生）。</li></ul><h2 id="列举几种表连接方式？"><a href="#列举几种表连接方式？" class="headerlink" title="列举几种表连接方式？"></a>列举几种表连接方式？</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20191207081711185_20242.png" alt="SQL连接"></p><ul><li>内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集。<ul><li>自然连接：只考虑属性相同的元组对；</li><li>等值连接：给定条件进行查询。</li></ul></li><li>外连接（Outer Join）<ul><li>左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；</li><li>右连接：和左连接相反；</li><li>全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据。</li></ul></li><li>交叉连接（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）。</li></ul><h2 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h2><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。</p><p><strong>优点：</strong></p><ul><li>预先编译，而不需要每次运行时编译，提高了数据库执行<strong>效率</strong>；</li><li>封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以<strong>减少网络通信量</strong>；</li><li>具有<strong>可复用性</strong>，减少了数据库开发的工作量；</li><li><strong>安全性高</strong>，可以让没有权限的用户通过存储过程间接操作数据库；</li><li>更<strong>易于维护</strong>。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>可移植性差</strong>，存储过程将应用程序绑定到了数据库上；</li><li><strong>开发调试复杂</strong>：没有好的IDE；</li><li><strong>修改复杂</strong>，需要重新编译，有时还需要更新程序中的代码以更新调用。</li></ul><h2 id="Drop-Delete-Truncate的区别？"><a href="#Drop-Delete-Truncate的区别？" class="headerlink" title="Drop/Delete/Truncate的区别？"></a>Drop/Delete/Truncate的区别？</h2><ul><li><strong>Delete</strong>用来删除表的全部或者<strong>部分数据</strong>，执行delete之后，用户<strong>需要提交</strong>之后才会执行，会触发表上的DELETE<strong>触发器</strong>（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据。</li><li><strong>Truncate</strong>删除表中的所有数据，这个操作<strong>不能回滚</strong>，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1。</li><li><strong>Drop</strong>命令从数据库中<strong>删除表</strong>，所有的数据行，索引和约束都会被删除。不能回滚，不会触发触发器。</li></ul><p><strong>约束（Constraint）类型</strong>：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束。</p><h2 id="什么是视图？什么是游标？"><a href="#什么是视图？什么是游标？" class="headerlink" title="什么是视图？什么是游标？"></a>什么是视图？什么是游标？</h2><ul><li><strong>视图：</strong>从数据库的基本表中通过查询选取出来的数据组成的<strong>虚拟表</strong>（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）。可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)，如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。</li><li><strong>好处：</strong><ul><li>通过只给用户访问视图的权限，保证数据的<strong>安全性</strong>。</li><li><strong>简化</strong>复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）。</li></ul></li><li><strong>游标（Cursor）</strong>：用于定位在查询返回的<strong>结果集的特定行</strong>，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。</li></ul><hr><h2 id="数据库索引的实现原理（B-树）"><a href="#数据库索引的实现原理（B-树）" class="headerlink" title="数据库索引的实现原理（B+树）"></a>数据库索引的实现原理（B+树）</h2><h3 id="使用B树和B-树的比较"><a href="#使用B树和B-树的比较" class="headerlink" title="使用B树和B+树的比较"></a>使用B树和B+树的比较</h3><p>InnoDB的索引使用的是B+树实现，B+树对比B树的好处：</p><ul><li>IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖。</li><li>范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表。</li><li>查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多。</li></ul><h3 id="使用B树索引和哈希索引的比较"><a href="#使用B树索引和哈希索引的比较" class="headerlink" title="使用B树索引和哈希索引的比较"></a>使用B树索引和哈希索引的比较</h3><p>哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。</p><h3 id="使用索引的优点"><a href="#使用索引的优点" class="headerlink" title="使用索引的优点"></a>使用索引的优点</h3><ul><li>大大加快了数据的<strong>检索速度</strong>。</li><li>可以显著减少查询中<strong>分组和排序</strong>的时间。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>将随机 I/O 变为<strong>顺序 I/O</strong>（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><p><strong>缺点</strong>：建立和维护索引耗费时间空间，更新索引很慢。</p><h3 id="哪些情况下索引会失效？"><a href="#哪些情况下索引会失效？" class="headerlink" title="哪些情况下索引会失效？"></a>哪些情况下索引会失效？</h3><ul><li>以“%(表示任意0个或多个字符)”开头的LIKE语句；</li><li>OR语句前后没有同时使用索引；</li><li>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</li><li>对于多列索引，必须满足<strong>最左匹配原则</strong>/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；</li><li>如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）。</li></ul><h3 id="在哪些地方适合创建索引？"><a href="#在哪些地方适合创建索引？" class="headerlink" title="在哪些地方适合创建索引？"></a>在哪些地方适合创建索引？</h3><ul><li>某列经常作为最大最小值；</li><li>经常被查询的字段；</li><li>经常用作表连接的字段；</li><li>经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段。</li></ul><h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul><li>只应建立在<strong>小字段</strong>上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）；</li><li>建立索引的字段应该<strong>非空</strong>，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；</li><li>选择<strong>数据密度大</strong>（唯一值占总数的百分比很大）的字段作索引。</li></ul><h3 id="索引的分类？"><a href="#索引的分类？" class="headerlink" title="索引的分类？"></a>索引的分类？</h3><ul><li>普通索引</li><li>唯一索引 UNIQUE：索引列的值必须唯一，但允许有空值。</li><li>主键索引 PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）。</li><li>单列索引和多列索引/复合索引（Composite）：索引的列数。</li><li>覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据。</li><li>聚集（Clustered）索引/非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序。</li><li>分区索引（？）</li><li>虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用。</li></ul><h2 id="MySQL的两种存储引擎-InnoDB-和-MyISAM-的区别？"><a href="#MySQL的两种存储引擎-InnoDB-和-MyISAM-的区别？" class="headerlink" title="MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？"></a>MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？</h2><ul><li>InnoDB<strong>支持事务</strong>，可以进行Commit和Rollback。</li><li>MyISAM 只支持表级锁，而 InnoDB 还<strong>支持行级锁</strong>，提高了并发操作的性能。</li><li>InnoDB <strong>支持外键</strong>。</li><li>MyISAM <strong>崩溃</strong>后发生损坏的概率比 InnoDB 高很多，而且<strong>恢复的速度</strong>也更慢。</li><li>MyISAM 支持<strong>压缩</strong>表和空间数据索引，InnoDB需要更多的内存和存储。</li><li>InnoDB 支持在线<strong>热备份</strong>。</li></ul><p><strong>应用场景</strong></p><ul><li><strong>MyISAM</strong> 管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM。</li><li><strong>InnoDB</strong> 支持事务，并发情况下有很好的性能，基本可以替代MyISAM。</li></ul><p><strong>热备份和冷备份</strong></p><ul><li>热备份：在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错。</li><li>冷备份：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单。</li></ul><blockquote><p>更详细的可以参考：<a href="https://imageslr.github.io/2020/db-engine.html">MySQL 数据库的存储引擎与适用场景 - Images</a></p></blockquote><h2 id="如何优化数据库？"><a href="#如何优化数据库？" class="headerlink" title="如何优化数据库？"></a>如何优化数据库？</h2><h3 id="SQL-语句的优化"><a href="#SQL-语句的优化" class="headerlink" title="SQL 语句的优化"></a><strong>SQL 语句的优化</strong></h3><blockquote><p>分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句，通过日志去找出IO大的SQL以及发现未命中索引的SQL。</p></blockquote><blockquote><p>使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、<strong>哪些索引被实际使用</strong>、表之间的引用以及<strong>被扫描的行数</strong>等问题。</p></blockquote><ul><li>应尽量避免在 where 子句中使用<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>操作符或对字段进行null值判断，否则将引擎放弃使用索引而进行全表扫描。</li><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：<ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用；</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询；</li><li>减少锁竞争。</li></ul></li></ul><h3 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a><strong>索引的优化</strong></h3><p>注意会引起索引失效的情况，以及在适合的地方建立索引。</p><h3 id="数据库表结构的优化"><a href="#数据库表结构的优化" class="headerlink" title="数据库表结构的优化"></a><strong>数据库表结构的优化</strong></h3><ul><li>设计表时遵循<strong>三大范式</strong>；</li><li>选择合适的<strong>数据类型</strong>：尽可能不要存储NULL字段；使用简单的数据类型（int, varchar/ text）；</li><li>表的<strong>水平切分</strong>（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据ID范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力；</li><li>表的<strong>垂直切分</strong>：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单。</li></ul><h3 id="系统配置的优化"><a href="#系统配置的优化" class="headerlink" title="系统配置的优化"></a><strong>系统配置的优化</strong></h3><ul><li>操作系统：增加TCP支持的队列数；</li><li>MySQL配置文件优化：缓存池大小和个数设置</li></ul><h3 id="硬件的优化"><a href="#硬件的优化" class="headerlink" title="硬件的优化"></a><strong>硬件的优化</strong></h3><ul><li>磁盘性能：固态硬盘；</li><li>CPU：多核且高频；</li><li>内存：增大内存。</li></ul><h2 id="什么是主从复制？实现原理是什么？"><a href="#什么是主从复制？实现原理是什么？" class="headerlink" title="什么是主从复制？实现原理是什么？"></a>什么是主从复制？实现原理是什么？</h2><p>主从复制（Replication）是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。</p><p><strong>实现原理：</strong></p><ul><li>主服务器 <strong>binary log dump 线程</strong>：将主服务器中的数据更改（增删改）日志写入 Binary log 中。</li><li>从服务器 <strong>I/O 线程</strong>：负责从主服务器读取binary log，并写入本地的 Relay log。</li><li>从服务器 <strong>SQL 线程</strong>：负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性。</li></ul><h3 id="为什么要主从复制？"><a href="#为什么要主从复制？" class="headerlink" title="为什么要主从复制？"></a>为什么要主从复制？</h3><ul><li>读写分离：主服务器负责写，从服务器负责读<ul><li>缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性</li></ul></li><li>数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换</li><li>降低单个服务器磁盘I/O访问的频率，提高单个机器的I/O性能</li></ul><h2 id="Redis-面试"><a href="#Redis-面试" class="headerlink" title="Redis 面试"></a>Redis 面试</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md">CyC2018</a></li><li><a href="https://blog.csdn.net/Butterfly_resting/article/details/89668661">几率大的Redis面试题（含答案） - CSDN</a></li><li><a href="https://www.jianshu.com/p/65765dd10671">Redis面试题总结 - 简书</a></li><li><a href="https://www.cnblogs.com/jasontec/p/9699242.html">Redis常见面试题 - 博客园</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码分析</title>
      <link href="2021/03/08/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>2021/03/08/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="ConcurrentHashMap的理解"><a href="#ConcurrentHashMap的理解" class="headerlink" title="ConcurrentHashMap的理解"></a><strong>ConcurrentHashMap的理解</strong></h2><p>HashMap在多线程情况下，通过put方法进行插入操作时，如果元素超过了容量（由负载因子决定）的范围就会触发扩容操作，重新将原数组的内容重新hash到新的扩容数组中。在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示时，造成闭环，导致在get时会出现死循环，此外，put的时候也可能导致多线程数据不一致，所以HashMap是线程不安全的。</p><p>HashTable是线程安全的，它在所有涉及到多线程操作的都加上了synchronized关键字来锁住整个table，这就意味着所有的线程都在竞争一把锁，在多线程的环境下，它是安全的，但是无疑是效率低下的。</p><p>其实HashTable有很多的优化空间，锁住整个table这么粗暴的方法可以变得柔和点，比如在多线程的环境下，对不同的数据集进行操作时其实根本就不需要去竞争一个锁，因为它们操作不同hash值，不会因为rehash造成线程不安全，所以互不影响，这就是锁分离技术，将锁的粒度降低，利用多个锁来控制多个小的table。</p><h3 id="JDK1-7-ConcurrentHashMap实现原理"><a href="#JDK1-7-ConcurrentHashMap实现原理" class="headerlink" title="JDK1.7 ConcurrentHashMap实现原理"></a><strong>JDK1.7 ConcurrentHashMap实现原理</strong></h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h4><p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210803151156372.png" alt="image-20210803151156372"></p><p>Segment数组的意义就是将一个大的数组分割成多个小的数组来进行加锁，即锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，相当于一个HashMap的数据结构。Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。单一的Segment如下：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210803151330638.png" alt="image-20210803151330638" style="zoom:67%;" /><p>像这样的Segment对象，在ConcurrentHashMap集合中有多少个呢？有2的N次方个，共同保存在一个名为segments的数组(这个数组是不会扩容的)当中。因此整个ConcurrentHashMap的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210803151455164.png" alt="image-20210803151455164"></p><ul><li><p>ConcurrentHashMap当中<strong>每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。</strong></p></li><li><p>HashEntry大小的计算也是2的N次方（cap &lt;&lt;=1），cap的初始值为1，所以HashEntry最小的容量为2。</p></li><li><p>另外核心数据 value，以及链表都是volatile修饰的，保证了获取时的可见性。</p></li><li><p>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的Segment。</p></li></ul><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a><strong>put操作</strong></h4><ul><li><p>对于ConcurrentHashMap的数据插入，这里要进行两次hash去定位数据的存储位置。</p></li><li><p>从上面Segment的继承体系可以看出，Segment实现了ReentrantLock，也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值；</p></li><li><p>然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock()方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock()方法去获取锁，超过指定次数就挂起，等待唤醒。</p></li></ul><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a><strong>get操作</strong></h4><ul><li><p>ConcurrentHashMap的get操作跟HashMap类似，只是ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null。</p></li><li><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p></li><li><p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</p></li></ul><h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a><strong>size操作</strong></h4><p>计算ConcurrentHashMap的元素大小是一个有趣的问题，因为它是并发操作的，就是在你计算size的时候，它还在并发的插入数据，可能会导致你计算出来的size和你实际的size有相差（在你return size的时候，插入了多个数据），要解决这个问题，JDK1.7版本用两种方案：</p><ul><li>第一种方案会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。</li><li>如果第一种方案不符合，它就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回。</li></ul><h3 id="JDK1-8-ConcurrentHashMap实现原理"><a href="#JDK1-8-ConcurrentHashMap实现原理" class="headerlink" title="JDK1.8 ConcurrentHashMap实现原理"></a><strong>JDK1.8 ConcurrentHashMap实现原理</strong></h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h4><p>JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，<strong>并发控制使用Synchronized和CAS来操作</strong>，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p><p>另外，将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。其中的 val、next 都用了 volatile 修饰，保证了可见性。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210803152506845.png" alt="image-20210803152506845"></p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a><strong>put()方法</strong></h4><p>这个put的过程很清晰，对当前的table进行无条件自循环直到put成功，可以分成以下六步流程来概述：</p><ul><li>如果没有初始化就先调用initTable（）方法来进行初始化过程；</li><li>如果没有hash冲突就直接调用Unsafe的方法CAS插入该元素；</li><li>如果还在进行扩容操作就先进行扩容；</li><li>如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；</li><li>最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环；</li><li>如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容。</li></ul><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a><strong>get()方法</strong></h4><p>ConcurrentHashMap的get操作的流程很简单，也很清晰，可以分为三个步骤来描述：</p><ul><li><p>计算hash值，定位到该table索引位置，如果是首节点符合就返回；</p></li><li><p>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回（会让 get 操作在新</p><p>table 进行搜索）；</p></li><li><p>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null。</p></li></ul><h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h4><p>size 计算实际发生在 put，remove 改变集合元素的操作之中：</p><ul><li>没有竞争发生，向 baseCount 累加计数；</li><li>有竞争发生，新建 counterCells，向其中的一个 cell 累加计数。</li></ul><p>使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount。因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数。</p><h3 id="1-7和1-8的区别"><a href="#1-7和1-8的区别" class="headerlink" title="1.7和1.8的区别"></a>1.7和1.8的区别</h3><ol><li><p><strong>JDK1.7：ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。</strong></p><ol><li>Segment实际继承自可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。<br>一个ConcurrentHashMap里包含一个Segment数组，每个Segment里包含一个HashEntry数组，我们称之为table，每个HashEntry是一个链表结构的元素。</li><li>初始化有三个参数：initialCapacity：初始容量大小 ，默认16。loadFactor, 扩容因子，默认0.75，当一个Segment存储的元素数量大于initialCapacity* loadFactor时，该Segment会进行一次扩容。</li><li>concurrencyLevel 并发度，默认16。并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，即ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</li></ol></li><li><p><strong>JDK1.8：已摒弃Segment的概念，直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，是优化过且线程安全的HashMap</strong>。<strong>在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本。</strong></p><ol><li>JDK1.8取消了segment数组，直接用table保存数据，锁的粒度更小，减少并发冲突的概率。</li><li>JDK1.8存储数据时采用了链表+红黑树的形式，纯链表的形式时间复杂度为O(n)，红黑树则为O（logn），性能提升很大；<br>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）；</li><li>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，使用synchronized来进行同步，由于粒度的降低，实现的复杂度增加；</li><li>JDK1.8使用内置锁synchronized来代替重入锁ReentrantLock。</li></ol></li></ol><h3 id="JDK-8-ConcurrentHashMap源码分析"><a href="#JDK-8-ConcurrentHashMap源码分析" class="headerlink" title="JDK 8 ConcurrentHashMap源码分析"></a><strong>JDK 8 ConcurrentHashMap源码分析</strong></h3><h4 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a><strong>重要属性和内部类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a><strong>重要方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span></span></span><br></pre></td></tr></table></figure><h4 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a><strong>构造器分析</strong></h4><p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"> <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel) <span class="comment">// Use at least as many bins</span></span><br><span class="line"> initialCapacity = concurrencyLevel; <span class="comment">// as estimated threads</span></span><br><span class="line"> <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line"> <span class="comment">// tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ... </span></span><br><span class="line"> <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line"> MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line"><span class="keyword">this</span>.sizeCtl = cap; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-流程"><a href="#get-流程" class="headerlink" title="get 流程"></a><strong>get</strong> <strong>流程</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"> Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line"> <span class="comment">// spread 方法能确保返回结果是正数</span></span><br><span class="line"> <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"> <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line"> (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 如果头结点已经是要查找的 key</span></span><br><span class="line"> <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line"> <span class="keyword">return</span> e.val;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"> <span class="comment">// 正常遍历链表, 用 equals 比较</span></span><br><span class="line"> <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line"> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line"> <span class="keyword">return</span> e.val;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put-流程"><a href="#put-流程" class="headerlink" title="put 流程"></a><strong>put</strong> <strong>流程</strong></h4><p>以下数组简称（table），链表简称（bin）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//onlyIfAbsent  如果当前位置已存在一个值，是否替换，false是替换，true是不替换</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> <span class="comment">// 其中 spread 方法会综合高位低位, 具有更好的 hash 性</span></span><br><span class="line"> <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line"> <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line"> <span class="comment">// f 是链表头节点</span></span><br><span class="line"> <span class="comment">// fh 是链表头结点的 hash</span></span><br><span class="line"> <span class="comment">// i 是链表在 table 中的下标</span></span><br><span class="line"> Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"> <span class="comment">// 要创建 table</span></span><br><span class="line"> <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"> <span class="comment">// 初始化 table 使用了 cas, 无需 synchronized 创建成功, 进入下一轮循环</span></span><br><span class="line"> tab = initTable();</span><br><span class="line"> <span class="comment">// 要创建链表头节点</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 添加链表头使用了 cas, 无需 synchronized</span></span><br><span class="line"> <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line"> <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 帮忙扩容</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line"> <span class="comment">// 帮忙之后, 进入下一轮循环</span></span><br><span class="line"> tab = helpTransfer(tab, f);</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> V oldVal = <span class="keyword">null</span>;</span><br><span class="line"> <span class="comment">// 锁住链表头节点</span></span><br><span class="line"> <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line"> <span class="comment">// 再次确认链表头节点没有被移动</span></span><br><span class="line"> <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"> <span class="comment">// 链表</span></span><br><span class="line"> <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> binCount = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 遍历链表</span></span><br><span class="line"> <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line"> K ek;</span><br><span class="line"> <span class="comment">// 找到相同的 key</span></span><br><span class="line"> <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"> ((ek = e.key) == key ||</span><br><span class="line"> (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line"> oldVal = e.val;</span><br><span class="line"> <span class="comment">// 更新</span></span><br><span class="line"> <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line"> e.val = value;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Node&lt;K,V&gt; pred = e;</span><br><span class="line"> <span class="comment">// 已经是最后的节点了, 新增 Node, 追加至链表尾</span></span><br><span class="line"> <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,value, <span class="keyword">null</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 红黑树</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line"> Node&lt;K,V&gt; p;</span><br><span class="line"> binCount = <span class="number">2</span>;</span><br><span class="line"> <span class="comment">// putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode</span></span><br><span class="line"> <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"> oldVal = p.val;</span><br><span class="line"> <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line"> p.val = value;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 释放链表头节点的锁</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line"> <span class="comment">// 如果链表长度 &gt;= 树化阈值(8), 进行链表转为红黑树</span></span><br><span class="line"> treeifyBin(tab, i);</span><br><span class="line"> <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line"> <span class="keyword">return</span> oldVal;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 增加 size 计数</span></span><br><span class="line"> addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line"> Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line"> <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line"> Thread.yield();</span><br><span class="line"> <span class="comment">// 尝试将 sizeCtl 设置为 -1（表示初始化 table）</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line"> <span class="comment">// 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"> Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line"> table = tab = nt;</span><br><span class="line"> sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sizeCtl = sc;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> tab; </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// check 是之前 binCount 的个数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line"> CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line"> <span class="keyword">if</span> (</span><br><span class="line"> <span class="comment">// 已经有了 counterCells, 向 cell 累加</span></span><br><span class="line"> (as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line"> <span class="comment">// 还没有, 向 baseCount 累加</span></span><br><span class="line"> !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)</span><br><span class="line"> ) &#123;</span><br><span class="line"> CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line"> <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">if</span> (</span><br><span class="line"> <span class="comment">// 还没有 counterCells</span></span><br><span class="line"> as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line"> <span class="comment">// 还没有 cell</span></span><br><span class="line"> (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line"> <span class="comment">// cell cas 增加计数失败</span></span><br><span class="line"> !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line"> ) &#123;</span><br><span class="line"> <span class="comment">// 创建累加单元数组和cell, 累加重试</span></span><br><span class="line"> fullAddCount(x, uncontended);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> <span class="comment">// 获取元素个数</span></span><br><span class="line"> s = sumCount();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line"> <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line"> (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"> <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"> <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line"> sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line"> transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="comment">// newtable 已经创建了，帮忙扩容</span></span><br><span class="line"> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line"> transfer(tab, nt);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 需要扩容，这时 newtable 未创建</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,(rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line"> transfer(tab, <span class="keyword">null</span>);</span><br><span class="line"> s = sumCount();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="size-计算流程"><a href="#size-计算流程" class="headerlink" title="size 计算流程"></a><strong>size</strong> <strong>计算流程</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">long</span> n = sumCount();</span><br><span class="line"> <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line"> (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line"> (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line"> <span class="comment">// 将 baseCount 计数与所有 cell 计数累加</span></span><br><span class="line"> <span class="keyword">long</span> sum = baseCount;</span><br><span class="line"> <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line"> sum += a.value;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 8</strong> 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）。</p><ul><li><p>初始化，使用 cas 来保证并发安全，懒惰初始化 table；</p></li><li><p>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头；</p></li><li><p>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部；</p></li><li><p>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新table 进行搜索；</p></li><li><p>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中</p></li><li><p>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树原理</title>
      <link href="2021/03/01/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>2021/03/01/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="二叉搜索树的定义"><a href="#二叉搜索树的定义" class="headerlink" title="二叉搜索树的定义"></a>二叉搜索树的定义</h3><p>二叉搜索树（Binary Search Tree），它或者是一棵空树，或者是具有下列性质的二叉树： </p><ul><li>若它的左子树不空，则<strong>左子树</strong>上所有结点的值<strong>均小于它的根结点的值</strong>； </li><li>若它的右子树不空，则<strong>右子树</strong>上所有结点的值<strong>均大于它的根结点的值</strong>； </li><li>它的左、右子树也分别为二叉排序树。</li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604212421939.png" alt="image-20210604212421939" style="zoom:50%;" /><ol><li>二叉搜索树：通俗地讲，以当前节点为根，其左右子树的特点：<strong>左小右大</strong>。当前节点为50时，其左子树所有节点均小于50，右子树所有节点均大于50：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604212537415.png" alt="image-20210604212537415" style="zoom:50%;" /><ol start="2"><li>节点50的左右子树也同样符合这种特点，以左子树为例（以30为根的树）：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604212624535.png" alt="image-20210604212624535" style="zoom:50%;" /><ol start="3"><li>同样的，其他的子树、子树的子树等均符合该规律（类似递归）。</li></ol><h3 id="二叉搜索树的查找"><a href="#二叉搜索树的查找" class="headerlink" title="二叉搜索树的查找"></a>二叉搜索树的查找</h3><p>根据左小右大的特点，查找一个元素时，从根节点出发：</p><ol><li>如果查找的元素比当前节点小，则到左子树找；</li><li>如果查找的元素比当前节点大，则到右子树找；</li><li>如果查找的元素等于当前节点，说明找到了；</li><li>如果直至叶子节点都找不到对应的，说明该元素不存在该树中。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604213153624.png" alt="image-20210604213153624" style="zoom:45%;" /><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604213236420.png" alt="image-20210604213236420" style="zoom:50%;" /><h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><p>插入元素时，主要是找到合适的位置进行插入（类似查找）：</p><ol><li>插入的树为空树（无节点），直接创建节点即可；</li><li>插入的树非空树：<ul><li>如果插入的元素比当前节点小，则到左子树插入；如果左子树/节点为null，插入该处；</li><li>如果插入的元素比当前节点大，则到右子树插入；如果右子树/节点为null，插入该处；</li><li>如果插入的元素和当前节点相等，说明该元素已经存在了，直接返回。</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604213438652.png" alt="image-20210604213438652" style="zoom: 45%;" /><p>插入节点的例子：</p><img src="C:\Users\14982\AppData\Roaming\Typora\typora-user-images\image-20210604213541369.png" alt="image-20210604213541369" style="zoom:50%;" /><h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h3><h4 id="前继节点和后继节点"><a href="#前继节点和后继节点" class="headerlink" title="前继节点和后继节点"></a>前继节点和后继节点</h4><p>二叉搜索树因为自身的特性（左小右大），中序遍历的结果必然是有序的。比如以下这棵树，其遍历的结果为：【20, 30, 35, 40, 45, 50, 55, 60, 65 70, 80】</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604213631098.png" alt="image-20210604213631098" style="zoom: 45%;" /><p>在二叉搜索树中，前继节点表示比当前节点小的最大值，后继节点表示比当前节点大的最小值，看例子就很容易明白：比如上面【20, 30, 35, 40, <strong>45</strong>, <strong>50</strong>, <strong>55</strong>, 60, 65 70, 80】中，节点50的前继节点为45，后继节点为55。在二叉搜索树中，寻找前后继节点很简单：</p><ol><li>寻找前继节点，当前节点左转一下，然后右转一直走到底（右子节点为null时终止）：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604213827013.png" alt="image-20210604213827013" style="zoom:45%;" /><ol start="2"><li>寻找后继节点，当前节点右转一下，然后左转一直走到底（左子节点为null时终止）：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604213936309.png" alt="image-20210604213936309" style="zoom:45%;" /><h4 id="根据子节点数量进行删除处理"><a href="#根据子节点数量进行删除处理" class="headerlink" title="根据子节点数量进行删除处理"></a>根据子节点数量进行删除处理</h4><p>删除前首先要找到该节点，如果找不到，直接结束即可。找到后，可以分为以下三种情景：</p><ol><li><p>无子节点，即叶子节点，直接删除即可；</p></li><li><p>只有一个子节点，用该子节点接到删除节点的父节点即可；</p></li><li><p>有两个子节点，使用前或后继节点作为替换节点，对删除节点进行数据替换，然后转移至删除替换节点即可。而此时删除后继节点时，必然是情景1或2了。如下图：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604215052103.png" alt="image-20210604215052103" style="zoom:50%;" /></li></ol><p>情景1：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604215126921.png" alt="image-20210604215126921" style="zoom:50%;" /><p>情景2：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604215316458.png" alt="image-20210604215316458" style="zoom:50%;" /><p>情景3 ：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604215342745.png" alt="image-20210604215342745" style="zoom: 40%;" /><p>关于情景3，无论使用前继节点还是后继节点，均可以达到同样的目的，选其一即可。</p><h3 id="二叉搜索树的问题"><a href="#二叉搜索树的问题" class="headerlink" title="二叉搜索树的问题"></a>二叉搜索树的问题</h3><ol><li>极端时，搜索的时间复杂度将会降低到 O(n)，比如以下这个例子，连续插入10,20,30,40,50：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604214218409.png" alt="image-20210604214218409" style="zoom:33%;" /><ol start="2"><li>而平衡二叉搜索树（AVL树、红黑树等）就是为了解决这个问题：平衡二叉树在进行插入、删除后，会进行自平衡，从而保证其查询的时间复杂度接近于O(log2n)。如红黑树连续插入10,20,30,40,50：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210604214241912.png" alt="image-20210604214241912" style="zoom:50%;" /><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h3><p>红黑树在二叉搜索树的基础上，还要求有以下性质：</p><ol><li>节点是红色或黑色；</li><li>根节点是黑色；</li><li>不能有连续的两个红色节点。</li><li>从任一节点到其每个叶子的简单路径都包含相同数目的黑色节点。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621213429942.png" alt="image-20210621213429942" style="zoom:50%;" /><ul><li><p>性质3表明：红色节点的父、左子、右子只能是黑色节点，红色和红色不能直接连一起；而黑色无论红黑都可以连一起。（红色暴脾气互不相容，黑色和蔼可亲谁来都行）</p></li><li><p>性质4表明：随便选一个节点，不论从怎么走，走到最后叶子节点时，其经过路径的黑色节点数量都是相等的（所谓完全黑平衡）。</p></li><li><p>性质3和4共同决定了：<strong>最长路径的节点总数量不会超过最短路径的两倍</strong>。因为黑色节点数量要一样，红色不能连着来，从而路径全黑时最短，红黑交替时最长。</p></li><li><p>因为路径长度/高度差有了一定限制，所以称红黑树是有一定平衡性的，不会出现极端倾斜的情况。</p></li><li><p>有一些红黑树定义（比如维基百科），还有一个性质：“叶子是黑色的NULL节点”。如下所示：</p></li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621214018831.png" alt="image-20210621214018831" style="zoom:50%;" /><p>引入黑色的NULL节点并不会对之前的定义产生影响（各路径都增加一个黑色节点，黑色数量依然相等），其目的更多是为了简化平衡操作的情况，平衡时可以认为：null就是黑色节点。此时只需要考虑红和黑这两种情况就行，而不用考虑非红非黑的null。</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>说插入之前，先来看看旋转：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621214159638.png" alt="image-20210621214159638" style="zoom:60%;" /><ul><li><p>旋转后，原来“左小右大”的特点不会受到影响，影响的是左右子树的高度，右旋左子树高度-1，右子树+1；左旋右子树高度-1，左子树+1。</p></li><li><p>比如某棵树的左子树高度已经达到3，而右子树只有1，只需要右旋一下，左右子树高度都将调整为2。整棵树来看，高度就相当于降低了1（3 -&gt; 2），这就是高度的“平衡”。</p></li><li><p>旋转前首先要确定<strong>旋转的节点</strong>（姑且叫支点）是哪个，这个非常重要。比如上图右旋前，要<strong>以X为支点</strong>才能转成右侧那样，如果选择Y作为支点，则要往下一层看了（X节点将以P的角色出现）。</p></li><li><p>另外留意一下b：</p><ul><li>右旋前，b是挂在Y的右子，而右旋后，挂到了X的左子了；</li><li> 左旋前，b是挂在X的左子，而左旋后，挂到了Y的右子了。</li></ul></li></ul><h3 id="插入平衡"><a href="#插入平衡" class="headerlink" title="插入平衡"></a>插入平衡</h3><p>开始之前，我们先约定一下名称：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621214521836.png" alt="image-20210621214521836" style="zoom:50%;" /><p>红黑树属于二叉搜索树，插入动作也与二叉搜索树一致，只不过红黑树在插入之后，多了平衡动作（旋转与涂色）。</p><p>新插入的节点均为<strong>红色节点</strong>，因为红色不会影响路径上黑色节点的数量，保持性质4。如果父节点为黑色，就直接结束了；如果父节点为红色，则需要另外处理了。</p><p>以新插入的节点为当前平衡节点N，插入平衡大体上分为以下情形：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621214712328.png" alt="image-20210621214712328" style="zoom:50%;" /><h3 id="情形1-N为根节点（父节点为NULL）"><a href="#情形1-N为根节点（父节点为NULL）" class="headerlink" title="情形1. N为根节点（父节点为NULL）"></a>情形1. N为根节点（父节点为NULL）</h3><p>当前平衡节点N为根节点时，直接涂黑根节点即可。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621214829285.png" alt="image-20210621214829285" style="zoom:50%;" /><h3 id="情形2-父黑"><a href="#情形2-父黑" class="headerlink" title="情形2. 父黑"></a>情形2. 父黑</h3><p>父节点为黑色时，无需其他操作，已然平衡。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621214904348.png" alt="image-20210621214904348" style="zoom:50%;" /><h3 id="情形3-父红-叔红"><a href="#情形3-父红-叔红" class="headerlink" title="情形3. 父红-叔红"></a>情形3. 父红-叔红</h3><p>父红-叔红时，将父/叔节(P/U)点涂黑，祖父节点(GP)涂红；而后以祖父节点(GP)作为新的平衡节点N，递归执行平衡操作。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621214954969.png" alt="image-20210621214954969" style="zoom:50%;" /><h3 id="情形4-父红-叔黑"><a href="#情形4-父红-叔黑" class="headerlink" title="情形4. 父红-叔黑"></a>情形4. 父红-叔黑</h3><h4 id="情形4-1-父节点和N同一边"><a href="#情形4-1-父节点和N同一边" class="headerlink" title="情形4.1 父节点和N同一边"></a><strong>情形4.1 父节点和N同一边</strong></h4><p><strong>情形4.1.1 父N同左</strong></p><p>“父N同左”指的是：<strong>父节点为祖父节点的左子，N为父节点的左子</strong>。此时以<strong>祖父节点(GP)<strong>为支点进行</strong>右旋</strong>；然后将P涂黑，将GP涂红。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621215515564.png" alt="image-20210621215515564" style="zoom:50%;" /><p>旋转后，P涂黑是因为要涂为原GP的黑色（往上兼容GP的父节点）；而GP涂红则是因为右旋后，经过U的路径的黑色节点数量+1，涂红进行数量平衡；下同。</p><p><strong>情形4.1.2 父N同右</strong></p><p>“父N同右”指的是：<strong>父节点是祖父节点的右子，N为父节点的右子</strong>。此时以<strong>祖父节点(GP)<strong>为支点进行</strong>左旋</strong>；将P涂黑，将GP涂红。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621215640141.png" alt="image-20210621215640141" style="zoom:50%;" /><h4 id="情形4-2-父节点和N不在同一边"><a href="#情形4-2-父节点和N不在同一边" class="headerlink" title="情形4.2 父节点和N不在同一边"></a>情形4.2 父节点和N不在同一边</h4><p><strong>情形4.2.1 父左N右</strong></p><p>“父左N右”指的是：<strong>父节点是祖父节点的左子，N为父节点的右子</strong>。此时，以<strong>父节点(P)<strong>进行</strong>左旋</strong>，旋转后，以P作为新的平衡节点N，转至 [情形4.1.1 父N同左] 处理。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621215721671.png" alt="image-20210621215721671" style="zoom:50%;" /><p><strong>情形4.2.2 父右N左</strong></p><p>“父右N左”指的是：<strong>父节点是祖父节点的右子，N为父节点的左子</strong>。 此时，以<strong>父节点(P)<strong>进行</strong>右旋</strong>，旋转后，以P作为新的平衡节点，此时再进行【情形4.1.2 父N同右】处理。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621215751709.png" alt="image-20210621215751709" style="zoom:50%;" /><h3 id="插入总结与实例"><a href="#插入总结与实例" class="headerlink" title="插入总结与实例"></a>插入总结与实例</h3><p>首先是将节点先插入再说，插入后，以刚插入的节点作为当前平衡节点N，进行平衡操作。现在回头看插入平衡的这几种情形，其实并不复杂：</p><ol><li>N为根：涂黑完事；</li><li>父黑：啥事不用管；</li><li>父红叔红：父/叔涂黑，祖父涂红，然后把祖父当成新的平衡节点递归处理（我们下面平衡了，让他老人家和上面沟通吧）；</li><li>父红叔黑：父节点和新插入节点同一边的话，扭一下就完事了（同左右旋，同右左旋，顺便涂色）；不在同一边的话，先扭到同一边吧。</li></ol><p>实例说明：为了简化，图中没有画出null的黑色节点。插入 <strong>10、20、15、30、5、8</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210621220104464.png" alt="image-20210621220104464"></p><h3 id="红黑树删除动作"><a href="#红黑树删除动作" class="headerlink" title="红黑树删除动作"></a>红黑树删除动作</h3><p>红黑树和二叉搜索树的删除类似，只不过加上颜色属性（<strong>这里的子节点均指非NULL节点</strong>）：</p><ol><li>无子节点时，删除节点可能为红色或者黑色：<ol><li>如果为红色，直接删除即可，不会影响黑色节点的数量；</li><li>如果为黑色，则需要进行删除平衡的操作了。</li></ol></li><li>只有一个子节点时，删除节点只能是黑色，其子节点为红色，无法满足红黑树的性质了。 此时用删除节点的子节点接到父节点，且将子节点颜色涂黑，保证黑色数量。</li><li>有两个子节点时，与二叉搜索树一样，使用后继节点作为替换的删除节点，情形转至为1或2处理。</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623183154785.png" alt="image-20210623183154785" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623183306766.png" alt="image-20210623183306766" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623183338156.png" alt="image-20210623183338156"></p><p>我们发现，删除情形3总是会转换为情形1和2，而情形1.1和情形2处理平衡非常简单，本文主要讨论的是情形1.2：删除<strong>黑色的叶子节点</strong>。因为一旦该节点被拿掉，红黑树中通过该节点的路径黑色节点数量将会减1，而且无法像情形2那样将子节点涂黑来达到平衡。此时只能自底向上进行平衡操作。</p><blockquote><p>这里的图特意将黑色的NULL节点给加上，这是因为删除节点被摘掉后，我们可以用一个黑色的节点接上，从而进行统一处理。</p></blockquote><h3 id="删除后的平衡"><a href="#删除后的平衡" class="headerlink" title="删除后的平衡"></a>删除后的平衡</h3><p>我们先约定一下节点名称：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623183553595.png" alt="image-20210623183553595" style="zoom:50%;" /><p>h(A-&gt;B-&gt;叶子)表示从A走到B再走到某一个叶子路径的黑色节点数量（A与B，B与叶子之间可能间隔了多个节点）。</p><hr><p>本文余下内容均指的是<strong>删除黑色的叶子节点后</strong>引发的一系列平衡操作。比如P-&gt;D-&gt;N，删除D（黑色）后，N接至父节点：P-&gt;N。</p><p>因为删除了一个黑色节点（N的父节点D），经过N的路径的黑色数量减1，即h(P-&gt;N-&gt;叶子) 比 h(P-&gt;S-&gt;叶子) 少1。平衡的方式有：</p><ol><li>h(P-&gt;N-&gt;叶子)不变，h(P-&gt;S-&gt;叶子)减1，此时已经子平衡，然而h(GP-&gt;P-&gt;叶子)还是会比h(GP -&gt; U -&gt;叶子)少1，此时需要将P当作新的N，向上递归处理；</li><li>h(P-&gt;N-&gt;叶子)加1，h(P-&gt;S-&gt;叶子)不变，也就是恢复了原来的状态，此时已经平衡，因为h(GP-&gt;P-&gt;叶子)=h(GP -&gt; U -&gt;叶子)。</li></ol><p>本文下面平衡的思路主要就是基于以上两种方式，另外要注意的是，红色和红色不能连一起的约束也不能违反。理解这个比较重要。</p><blockquote><p>GP-&gt;P-&gt;叶子 的路径，要么经过N，要么经过S，如果h(P-&gt;N-&gt;叶子)和h(P-&gt;S-&gt;叶子)均少1了，自然h(GP-&gt;P-&gt;叶子)会少1。</p></blockquote><p>删除平衡情形，主要根据 [兄节点的位置/颜色]、[兄的子节点的颜色]、[父节点颜色] 进行分类：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623184415756.png" alt="image-20210623184415756" style="zoom:50%;" /><p>N节点的位置知道后，S的位置自然也就知道了，相反亦可；这里以S位置作为分类，主要是为了便于理解和记忆。</p><h3 id="情形1-当前节点为根节点（父节点为NULL）"><a href="#情形1-当前节点为根节点（父节点为NULL）" class="headerlink" title="情形1 当前节点为根节点（父节点为NULL）"></a>情形1 当前节点为根节点（父节点为NULL）</h3><p>比较特殊的情况，无需平衡操作。因为经过根节点的黑色数量少一个，意味着所有路径都少一个，已然平衡。</p><h3 id="情形2-兄弟节点为黑色（S-黑）"><a href="#情形2-兄弟节点为黑色（S-黑）" class="headerlink" title="情形2 兄弟节点为黑色（S=黑）"></a>情形2 兄弟节点为黑色（S=黑）</h3><h4 id="情形2-1-兄弟的子节点全黑"><a href="#情形2-1-兄弟的子节点全黑" class="headerlink" title="情形2.1 兄弟的子节点全黑"></a>情形2.1 兄弟的子节点全黑</h4><p>兄弟节点的子节点全为黑色（SL/SR=黑），也就意味着兄弟节点（S）可以涂红而不会和子冲突。S涂红后，也就实现了子平衡， 这时候我们看父节点是红是黑，再做处理。</p><p><strong>情形2.1.1 父节点为黑色（P=黑）</strong></p><p>此时将S涂红，父节点作为新的平衡节点N，递归上去处理。这个也就是之前提到的h(P-&gt;N-&gt;叶子)不变，h(P-&gt;S-&gt;叶子)减1，而h(GP-&gt;P-&gt;叶子)，依然会比h(GP -&gt; U -&gt;叶子)少1，所以要递归上去处理。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623190829319.png" alt="image-20210623190829319" style="zoom:50%;" />!</p><p><strong>情形2.1.2 父节点为红色（P=红）</strong></p><p>此时将S涂红，P涂黑，平衡结束。S涂红后，h(P-&gt;N-&gt;叶子)不变，h(P-&gt;S-&gt;叶子)-1，实现子平衡，因为P节点是红色的，如果将它涂黑，h(P-&gt;N-&gt;叶子)和h(P-&gt;S-&gt;叶子)均会+1，就可以恢复原来的状态了，而不用递归上去。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623190829319.png" alt="image-20210623190829319" style="zoom:50%;" /><h4 id="情形2-2-兄弟的子节点不全黑"><a href="#情形2-2-兄弟的子节点不全黑" class="headerlink" title="情形2.2 兄弟的子节点不全黑"></a>情形2.2 兄弟的子节点不全黑</h4><p>所谓的不全黑包括：[SL红, SR红]、[SL黑，SR红]、[SL红，SR黑]。如果其中一个为黑，另外一个肯定是红。以全黑/非全黑作为分类，是因为全黑时无论N是在左子还是右子，其处理方式是一样的。而非全黑则要看N所处的位置（或者说<strong>S所处的位置</strong>）进行特定方向的旋转。</p><p>为了方便理解和记忆，以S进行分组：</p><ul><li><p>S为左子时（即N为右子），主要分两组 [SL=红]、[SL=黑]；</p></li><li><p>S为右子时（即N为左子），主要分两组 [SR=红]、[SR=黑]。</p></li><li><p>【S为左子，SL红】与【S为右子，SR红】处理方式对称； 【S为左子，SL黑】与【S为右子，SR黑】处理方式对称。</p></li><li><p> 【S为左子，SL黑】与【S为右子，SR黑】处理方式对称。</p></li></ul><p><strong>情形2.2.1 S为左子，SL红；S为右子，SR红</strong></p><p>情形(1) S为黑色，<strong>S为左子</strong>，<strong>SL红</strong>时：以<strong>P</strong>为支点<strong>右旋</strong>，交换P和S颜色，<strong>SL涂黑</strong>；平衡结束。</p><p>这里的平衡思路其实就是：h(P-&gt;S-&gt;叶子)不变（因为SL涂黑补回来了），h(P-&gt;N-&gt;叶子)+1（因为多了个黑色P）。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623221308231.png" alt="image-20210623221308231" style="zoom:80%;" /><p>通常旋转后，新的P节点往往都会涂成原P的颜色：一是为了让GP-P不会颜色冲突；二是保持经过P的路径黑色数量不变。</p><hr><p>对称的情形(2)：S为黑色，<strong>S为右子</strong>，<strong>SR红</strong>时：以<strong>P</strong>为支点<strong>左旋</strong>；交换P和S颜色（S涂为P原颜色，P涂黑），<strong>SR涂黑</strong>；平衡结束。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623221406479.png" alt="image-20210623221406479" style="zoom:100%;" /><p><strong>情形2.2.2 S为左子，SL黑；S为右子，SR黑</strong></p><p>情形(1) S为黑色，<strong>S为左子</strong>，<strong>SL黑</strong>：以<strong>S</strong>为支点<strong>左旋</strong>，交换S和SR颜色（SR涂黑，S涂红） ，此时转至情形2.2.1-(1) S左-SL红 进行处理。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623221450536.png" alt="image-20210623221450536" style="zoom:50%;" /><blockquote><p>S涂红是为了使h(原S-&gt;SR-&gt;叶子)不变。</p></blockquote><hr><p>对称的情形(2) S为黑色，<strong>S为右子</strong>，<strong>SR黑</strong>：以<strong>S</strong>为支点<strong>右旋</strong>，交换S和SL颜色（SL涂黑，S涂红），此时转至2.2.1-(1) S右-SR红进行处理。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623221734614.png" alt="image-20210623221734614" style="zoom:50%;" /><h3 id="情形3-兄弟节点为红色（S-红）"><a href="#情形3-兄弟节点为红色（S-红）" class="headerlink" title="情形3 兄弟节点为红色（S=红）"></a>情形3 兄弟节点为红色（S=红）</h3><ol><li><p>情形(1) S为左子时，以P进行右旋；</p></li><li><p>情形(2) S为右子时，以P进行左旋。</p></li><li><p>旋转后交换P和S的颜色（S涂黑，P涂红），N兄弟节点变为黑色，进入情形2-兄弟节点为黑色进行处理。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623221954959.png" alt="image-20210623221954959" style="zoom:50%;" /></li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623222010038.png" alt="image-20210623222010038" style="zoom:50%;" /><h3 id="删除总结与实例"><a href="#删除总结与实例" class="headerlink" title="删除总结与实例"></a>删除总结与实例</h3><ol><li>删除动作（移除节点）之后，看看这个节点是不是黑色的叶子节点，如果不是，简单处理就可以达到平衡了；</li><li>先看N是不是根节点，是的话啥都不用管；不是的话看兄弟什么颜色：<ol><li>兄弟是红色：进行旋转涂色，去到兄弟为黑色那里处理；</li><li>兄弟是黑色，看看兄弟子节点是不是全部都是黑。<ul><li>全黑的话，看父什么颜色进行对应处理；</li><li>不全黑，看兄在的位置，兄在左的话，看兄的左子是不是红色，进行对应处理；兄在右的话，看兄的右子是不是红色，进行对应处理。</li></ul></li></ol></li></ol><p>现在我们有一颗红黑树：</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623222138635.png" alt="image-20210623222138635" style="zoom: 33%;" /><ol><li>删除50，删除动作-情形3 –&gt; 删除动作-情形2，简单处理即可：</li></ol><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623222210858.png" alt="image-20210623222210858" style="zoom:100%;" /><ol start="2"><li>删除70，即黑色叶子节点，进行平衡：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623222321254.png" alt="image-20210623222321254"></p><ol start="3"><li>删除60：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623222358615.png" alt="image-20210623222358615"></p><ol start="4"><li>删除10：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623222421588.png" alt="image-20210623222421588"></p><ol start="5"><li>删除20：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210623222442466.png" alt="image-20210623222442466"></p>]]></content>
      
      
      <categories>
          
          <category> Collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap1.7与1.8源码的区别</title>
      <link href="2021/02/25/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>2021/02/25/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a><strong>类定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">         <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="主要简介"><a href="#主要简介" class="headerlink" title="主要简介"></a><strong>主要简介</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-086b58aeee2d00cb.png" alt="img"></p><h2 id="数据结构：引入了-红黑树"><a href="#数据结构：引入了-红黑树" class="headerlink" title="数据结构：引入了 红黑树"></a>数据结构：引入了 红黑树</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-98178707855677bc.jpg" alt="img"></p><h3 id="存储流程"><a href="#存储流程" class="headerlink" title="存储流程"></a>存储流程</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-441706c5a99e02a3.png" alt="img"></p><h3 id="数组元素-amp-链表节点的-实现类"><a href="#数组元素-amp-链表节点的-实现类" class="headerlink" title="数组元素 &amp; 链表节点的 实现类"></a>数组元素 &amp; 链表节点的 实现类</h3><ul><li><p><code>HashMap</code>中的数组元素 &amp; 链表节点采用 <code>Node</code>类 实现。</p></li><li><p>与 <code>JDK 1.7</code> 的对比（<code>Entry</code>类），仅仅只是换了名字。</p></li><li><p>该类的源码分析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * Node  = HashMap的内部类，实现了Map.Entry接口，本质是 = 一个映射(键值对)</span></span><br><span class="line"><span class="comment">  * 实现了getKey()、getValue()、equals(Object o)和hashCode()等方法</span></span><br><span class="line"><span class="comment">  **/</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// 哈希值，HashMap根据该值确定记录的位置</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">// key</span></span><br><span class="line">        V value; <span class="comment">// value</span></span><br><span class="line">        Node&lt;K,V&gt; next;<span class="comment">// 链表下一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;   <span class="comment">// 返回 与 此项 对应的键</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 返回 与 此项 对应的值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * hashCode（） </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * equals（）</span></span><br><span class="line"><span class="comment">        * 作用：判断2个Entry是否相等，必须key和value都相等，才返回true  </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="红黑树节点实现类"><a href="#红黑树节点实现类" class="headerlink" title="红黑树节点实现类"></a>红黑树节点实现类</h3><ul><li><p><code>HashMap</code>中的红黑树节点采用 <code>TreeNode</code> 类 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树节点 实现类：继承自LinkedHashMap.Entry&lt;K,V&gt;类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 属性 = 父节点、左子树、右子树、删除辅助节点 + 颜色</span></span><br><span class="line">   TreeNode&lt;K,V&gt; parent;  </span><br><span class="line">   TreeNode&lt;K,V&gt; left;   </span><br><span class="line">   TreeNode&lt;K,V&gt; right;</span><br><span class="line">   TreeNode&lt;K,V&gt; prev;   </span><br><span class="line">   <span class="keyword">boolean</span> red;   </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 构造函数</span></span><br><span class="line">   TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;  </span><br><span class="line">       <span class="keyword">super</span>(hash, key, val, next);  </span><br><span class="line">   &#125;  </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 返回当前节点的根节点  </span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;  </span><br><span class="line">           <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)  </span><br><span class="line">               <span class="keyword">return</span> r;  </span><br><span class="line">           r = p;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure></li></ul><h2 id="具体方法使用"><a href="#具体方法使用" class="headerlink" title="具体方法使用"></a>具体方法使用</h2><h3 id="主要使用API（方法、函数）"><a href="#主要使用API（方法、函数）" class="headerlink" title="主要使用API（方法、函数）"></a>主要使用API（方法、函数）</h3><blockquote><p>与 <code>JDK 1.7</code> 基本相同。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>; <span class="comment">// 获得指定键的值</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;  <span class="comment">// 添加键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;  <span class="comment">// 将指定Map中的键值对 复制到 此Map中</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;  <span class="comment">// 删除该键值对</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">// 判断是否存在该键的键值对；是 则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;  <span class="comment">// 判断是否存在该值的键值对；是 则返回true</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;  <span class="comment">// 单独抽取key序列，将所有key生成一个Set</span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;  <span class="comment">// 单独value序列，将所有value生成一个Collection</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清除哈希表中的所有键值对</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;  <span class="comment">// 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断HashMap是否为空；size == 0时 表示为 空 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><blockquote><p>与 <code>JDK 1.7</code> 基本相同</p></blockquote><p><strong>在具体使用时，主要流程是：</strong></p><ol><li>声明1个 <code>HashMap</code>的对象；</li><li>向 <code>HashMap</code> 添加数据（成对 放入 键 - 值对）；</li><li>获取 <code>HashMap</code> 的某个数据；</li><li>获取 <code>HashMap</code> 的全部数据：遍历<code>HashMap</code>。</li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1. 声明1个 HashMap的对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 2. 向HashMap添加数据（成对 放入 键 - 值对）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.put(<span class="string">&quot;Android&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;iOS&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;数据挖掘&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">&quot;产品经理&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 3. 获取 HashMap 的某个数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;key = 产品经理时的值为：&quot;</span> + map.get(<span class="string">&quot;产品经理&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 4. 获取 HashMap 的全部数据：遍历HashMap</span></span><br><span class="line"><span class="comment">        * 核心思想：</span></span><br><span class="line"><span class="comment">        * 步骤1：获得key-value对（Entry） 或 key 或 value的Set集合</span></span><br><span class="line"><span class="comment">        * 步骤2：遍历上述Set集合(使用for循环 、 迭代器（Iterator）均可)</span></span><br><span class="line"><span class="comment">        * 方法共有3种：分别针对 key-value对（Entry） 或 key 或 value</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法1：获得key-value的Set集合 再遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法1&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 获得key-value对（Entry）的Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历Set集合，从而获取key-value</span></span><br><span class="line">        <span class="comment">// 2.1 通过for循环</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entrySet)&#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.2 通过迭代器：先获得key-value对（Entry）的Iterator，再循环遍历</span></span><br><span class="line">        Iterator iter1 = entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter1.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 遍历时，需先获取entry，再分别获取key、value</span></span><br><span class="line">            Map.Entry entry = (Map.Entry) iter1.next();</span><br><span class="line">            System.out.print((String) entry.getKey());</span><br><span class="line">            System.out.println((Integer) entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法2：获得key的Set集合 再遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获得key的Set集合</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历Set集合，从而获取key，再获取value</span></span><br><span class="line">        <span class="comment">// 2.1 通过for循环</span></span><br><span class="line">        <span class="keyword">for</span>(String key : keySet)&#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 通过迭代器：先获得key的Iterator，再循环遍历</span></span><br><span class="line">        Iterator iter2 = keySet.iterator();</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">            key = (String)iter2.next();</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法3：获得value的Set集合 再遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获得value的Set集合</span></span><br><span class="line">        Collection valueSet = map.values();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历Set集合，从而获取value</span></span><br><span class="line">        <span class="comment">// 2.1 获得values 的Iterator</span></span><br><span class="line">        Iterator iter3 = valueSet.iterator();</span><br><span class="line">        <span class="comment">// 2.2 通过遍历，直接获取value</span></span><br><span class="line">        <span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter3.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：对于遍历方式，推荐使用针对 key-value对（Entry）的方式：效率高</span></span><br><span class="line"><span class="comment">// 原因：</span></span><br><span class="line">   <span class="comment">// 1. 对于 遍历keySet 、valueSet，实质上 = 遍历了2次：1 = 转为 iterator 迭代器遍历、2 = 从 HashMap 中取出 key 的 value 操作（通过 key 值 hashCode 和 equals 索引）</span></span><br><span class="line">   <span class="comment">// 2. 对于 遍历 entrySet ，实质 = 遍历了1次 = 获取存储实体Entry（存储了key 和 value ）</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span></span><br><span class="line">Java2</span><br><span class="line">iOS3</span><br><span class="line">数据挖掘<span class="number">4</span></span><br><span class="line">Android1</span><br><span class="line">产品经理<span class="number">5</span></span><br><span class="line">----------</span><br><span class="line">Java2</span><br><span class="line">iOS3</span><br><span class="line">数据挖掘<span class="number">4</span></span><br><span class="line">Android1</span><br><span class="line">产品经理<span class="number">5</span></span><br><span class="line">方法<span class="number">2</span></span><br><span class="line">Java2</span><br><span class="line">iOS3</span><br><span class="line">数据挖掘<span class="number">4</span></span><br><span class="line">Android1</span><br><span class="line">产品经理<span class="number">5</span></span><br><span class="line">----------</span><br><span class="line">Java2</span><br><span class="line">iOS3</span><br><span class="line">数据挖掘<span class="number">4</span></span><br><span class="line">Android1</span><br><span class="line">产品经理<span class="number">5</span></span><br><span class="line">方法<span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="HashMap中的重要参数（变量）"><a href="#HashMap中的重要参数（变量）" class="headerlink" title="HashMap中的重要参数（变量）"></a>HashMap中的重要参数（变量）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 主要参数 同  JDK 1.7 </span></span><br><span class="line"><span class="comment">  * 即：容量、加载因子、扩容阈值（要求、范围均相同）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 1. 容量（capacity）： 必须是2的幂 &amp; &lt;最大容量（2的30次方）</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认容量 = 16 = 1&lt;&lt;4 = 00001中的1向左移4位 = 10000 = 十进制的2^4=16</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 最大容量 =  2的30次方（若传入的容量过大，将被最大值替换）</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2. 加载因子(Load factor)：HashMap在其容量自动增加前可达到多满的一种尺度 </span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 实际加载因子</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 默认加载因子 = 0.75</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3. 扩容阈值（threshold）：当哈希表的大小 ≥ 扩容阈值时，就会扩容哈希表（即扩充HashMap的容量） </span></span><br><span class="line"> <span class="comment">// a. 扩容 = 对哈希表进行resize操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数</span></span><br><span class="line"> <span class="comment">// b. 扩容阈值 = 容量 x 加载因子</span></span><br><span class="line"> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4. 其他</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;  <span class="comment">// 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">// HashMap的大小，即 HashMap中存储的键值对的数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 与红黑树相关的参数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 1. 桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 &gt; 该值时，则将链表转换成红黑树</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line">  <span class="comment">// 2. 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt; 6时，则将 红黑树转换成链表</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 3. 最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）</span></span><br><span class="line">  <span class="comment">// 否则，若桶内元素太多时，则直接扩容，而不是树形化</span></span><br><span class="line">  <span class="comment">// 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h3 id="加载因子"><a href="#加载因子" class="headerlink" title="加载因子"></a><strong>加载因子</strong></h3><blockquote><p>同 <code>JDK 1.7</code>，但由于其重要性，故此处再次说明。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-b85819e2f8a3c30a.jpg" alt="img"></p><p>总结 数据结构 &amp; 参数方面与 <code>JDK 1.7</code>的区别：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-67768bc4f0d23d69.png" alt="img"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>本次的源码分析主要是根据 <strong>使用步骤</strong> 进行相关函数的详细分析，主要分析内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-43ee4c315b6f82d8.png" alt="img"></p><h3 id="源码中数据结构-amp-主要参数"><a href="#源码中数据结构-amp-主要参数" class="headerlink" title="源码中数据结构 &amp; 主要参数"></a>源码中数据结构 &amp; 主要参数</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-38b76323d9e4ceb7.png" alt="img"></p><h3 id="步骤1：声明1个-HashMap的对象"><a href="#步骤1：声明1个-HashMap的对象" class="headerlink" title="步骤1：声明1个 HashMap的对象"></a>步骤1：声明1个 HashMap的对象</h3><p>此处主要分析的构造函数类似 <code>JDK 1.7</code>。</p><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数使用原型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析：主要是HashMap的构造函数 = 4个</span></span><br><span class="line"><span class="comment">   * 仅贴出关于HashMap构造函数的源码</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略上节阐述的参数</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数1：默认构造函数（无参）</span></span><br><span class="line"><span class="comment">     * 加载因子 &amp; 容量 = 默认 = 0.75、16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数2：指定“容量大小”的构造函数</span></span><br><span class="line"><span class="comment">     * 加载因子 = 默认 = 0.75 、容量 = 指定大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际上是调用指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line">        <span class="comment">// 只是在传入的加载因子参数 = 默认加载因子</span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数3：指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="comment">     * 加载因子 &amp; 容量 = 自己指定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定初始容量必须非负，否则报错  </span></span><br><span class="line">         <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +  </span><br><span class="line">                                           initialCapacity); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY，哪怕传入的 &gt; 最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充比必须为正  </span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +  </span><br><span class="line">                                           loadFactor);  </span><br><span class="line">        <span class="comment">// 设置 加载因子</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 扩容阈值</span></span><br><span class="line">        <span class="comment">// 注：此处不是真正的阈值，仅仅只是将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂，该阈值后面会重新计算</span></span><br><span class="line">        <span class="comment">// 下面会详细讲解 -&gt;&gt; 分析1</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数4：包含“子Map”的构造函数</span></span><br><span class="line"><span class="comment">     * 即 构造出来的HashMap包含传入Map的映射关系</span></span><br><span class="line"><span class="comment">     * 加载因子 &amp; 容量 = 默认</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置容量大小 &amp; 加载因子 = 默认</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入的子Map中的全部元素逐个添加到HashMap中</span></span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析1：tableSizeFor(initialCapacity)</span></span><br><span class="line"><span class="comment">     * 作用：将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂</span></span><br><span class="line"><span class="comment">     * 与JDK 1.7对比：类似于JDK 1.7 中 inflateTable()里的 roundUpToPowerOf2(toSize)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">     <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：（同<code>JDK 1.7</code>类似）</strong></p><ol><li>此处仅用于接收初始容量大小（<code>capacity</code>）、加载因子(<code>Load factor</code>)，但仍无真正初始化哈希表，即初始化存储数组<code>table</code>。</li><li>此处先给出结论：<strong>真正初始化哈希表（初始化存储数组<code>table</code>）是在第1次添加键值对时，即第1次调用<code>put（）</code>时。下面会详细说明</strong>。</li></ol><h3 id="步骤2：向HashMap添加数据（成对-放入-键-值对）"><a href="#步骤2：向HashMap添加数据（成对-放入-键-值对）" class="headerlink" title="步骤2：向HashMap添加数据（成对 放入 键 - 值对）"></a>步骤2：向HashMap添加数据（成对 放入 键 - 值对）</h3><p>在该步骤中，与<code>JDK 1.7</code>的差别较大：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-45ec8c640c5e5363.png" alt="img"></p><p><strong>添加数据的流程如下：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-2914343d292dc7e0.png" alt="img"></p><p><strong>源码分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数使用原型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  map.put(<span class="string">&quot;Android&quot;</span>, <span class="number">1</span>);</span><br><span class="line">       map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">       map.put(<span class="string">&quot;iOS&quot;</span>, <span class="number">3</span>);</span><br><span class="line">       map.put(<span class="string">&quot;数据挖掘&quot;</span>, <span class="number">4</span>);</span><br><span class="line">       map.put(<span class="string">&quot;产品经理&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 源码分析：主要分析HashMap的put函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 1. 对传入数组的键Key计算Hash值 -&gt;&gt;分析1</span></span><br><span class="line">       <span class="comment">// 2. 再调用putVal（）添加数据进去 -&gt;&gt;分析2</span></span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="分析1：hash（key）"><a href="#分析1：hash（key）" class="headerlink" title="分析1：hash（key）"></a><strong>分析1：hash（key）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：hash(key)</span></span><br><span class="line"><span class="comment">  * 作用：计算传入数据的哈希码（哈希值、Hash值）</span></span><br><span class="line"><span class="comment">  * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</span></span><br><span class="line"><span class="comment">  * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算</span></span><br><span class="line"><span class="comment">  * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">     h ^= k.hashCode(); </span><br><span class="line">     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span></span><br><span class="line">   <span class="comment">// 1. 取hashCode值： h = key.hashCode() </span></span><br><span class="line">   <span class="comment">// 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">         <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">         <span class="comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span></span><br><span class="line">         <span class="comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span></span><br><span class="line">         <span class="comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 计算存储位置的函数分析：indexFor(hash, table.length)</span></span><br><span class="line"><span class="comment">  * 注：该函数仅存在于JDK 1.7 ，JDK 1.8中实际上无该函数（直接用1条语句判断写出），但原理相同</span></span><br><span class="line"><span class="comment">  * 为了方便讲解，故提前到此讲解</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); </span><br><span class="line">       <span class="comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>计算存放在数组 table 中的位置（即数组下标、索引）的过程：</strong></p><ol><li>此处与 <code>JDK 1.7</code>的区别在于：<code>hash</code>值的求解过程中哈希码的二次处理方式（扰动处理）。</li><li>步骤1、2 = <code>hash</code>值的求解过程。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-4eec328e8dd3d7e7.png" alt="img"></p><p><strong>计算示意图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-1f13afa0cd516356.png" alt="img"></p><p>在了解如何计算存放数组<code>table</code> 中的位置 后，所谓 <strong>知其然而需知其所以然</strong>，下面讲解为什么要这样计算，即主要解答以下3个问题：</p><ol><li>为什么不直接采用经过<code>hashCode（）</code>处理的哈希码作为存储数组<code>table</code>的下标位置？</li><li>为什么采用 哈希码 <strong>与运算(&amp;)</strong> （数组长度-1） 计算数组下标？</li><li>为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？</li></ol><blockquote><p>在回答这3个问题前，请大家记住一个核心思想：<strong>所有处理的根本目的，都是为了提高存储<code>key-value</code>的数组下标位置的随机性 &amp; 分布均匀性，尽量避免出现hash值冲突</strong>。即：对于不同<code>key</code>，存储的数组下标位置要尽可能不一样。</p></blockquote><ol><li><p><strong>为什么不直接采用经过hashCode（）处理的哈希码作为存储数组table的下标位置？</strong></p><p>结论：容易出现哈希码与数组大小范围不匹配的情况，即计算出来的哈希码可能不在数组大小范围内，从而导致无法匹配存储位置。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-d18ee0697a1a1b53.png" alt="img"></p><p>为了解决 “哈希码与数组大小范围不匹配” 的问题，<code>HashMap</code>给出了解决方案：<strong>哈希码与运算（&amp;） （数组长度-1）</strong>，即问题3。</p><ol start="2"><li><p><strong>为什么采用哈希码与运算(&amp;) （数组长度-1） 计算数组下标？</strong></p><p>结论：根据HashMap的容量大小（数组长度），按需取哈希码一定数量的低位作为存储的数组下标位置，从而 解决“哈希码与数组大小范围不匹配”的问题。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-04658793bae1ed90.png" alt="img"></p><ol start="3"><li><p><strong>为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？</strong></p><p>结论：加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性 &amp; 均匀性，最终减少Hash冲突。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-20d396364b968713.png" alt="img"></p><h4 id="分析2：putVal-hash-key-key-value-false-true"><a href="#分析2：putVal-hash-key-key-value-false-true" class="headerlink" title="分析2：putVal(hash(key), key, value, false, true)"></a><strong>分析2：putVal(hash(key), key, value, false, true)</strong></h4><ul><li>计算完存储位置后，具体该如何存放数据到哈希表中。</li><li>具体如何扩容，即 <strong>扩容机制</strong>。</li></ul><p>由于数据结构中加入了红黑树，所以在存放数据到哈希表中时，需进行多次数据结构的判断：<strong>数组、红黑树、链表</strong>。</p><blockquote><p>与 <code>JDK 1.7</code>的区别： <code>JDK 1.7</code>只需判断 数组 &amp; 链表。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-53b07522b343ebe9.png" alt="img"></p><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析2：putVal(hash(key), key, value, false, true)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//onlyIfAbsent：插入的值是否存在，存在就不插了。</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 若哈希表的数组tab为空，则 通过resize() 创建</span></span><br><span class="line">        <span class="comment">// 所以，初始化哈希表的时机 = 第1次调用put函数时，即调用resize() 初始化创建</span></span><br><span class="line">        <span class="comment">// 关于resize（）的源码分析将在下面讲解扩容时详细分析，此处先跳过</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算插入存储的数组索引i：根据键值key计算的hash值 得到</span></span><br><span class="line">        <span class="comment">// 此处的数组下标计算方式 = i = (n - 1) &amp; hash，同JDK 1.7中的indexFor（），上面已详细描述</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 插入时，需判断是否存在Hash冲突：</span></span><br><span class="line">        <span class="comment">// 若不存在（即当前table[i] == null），则直接在该数组位置新建节点，插入完毕</span></span><br><span class="line">        <span class="comment">// 否则，代表存在Hash冲突，即当前存储位置已存在节点，则依次往下判断：a. 当前位置的key是否与需插入的key相同、b. 判断需插入的数据结构是否为红黑树 or 链表</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);  <span class="comment">// newNode(hash, key, value, null)的源码 = new Node&lt;&gt;(hash, key, value, next)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. 判断 table[i]的元素的key是否与 需插入的key一样，若相同则 直接用新value 覆盖 旧value</span></span><br><span class="line">        <span class="comment">// 判断原则：equals（）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. 继续判断：需插入的数据结构是否为红黑树 or 链表</span></span><br><span class="line">        <span class="comment">// 若是红黑树，则直接在树中插入 or 更新键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); -&gt;&gt;分析<span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若是链表,则在链表中插入 or 更新键值对</span></span><br><span class="line">        <span class="comment">// i.  遍历table[i]，判断Key是否已存在：采用equals（） 对比当前遍历节点的key 与 需插入数据的key：若已存在，则直接用新value 覆盖 旧value</span></span><br><span class="line">        <span class="comment">// ii. 遍历完毕后仍无发现上述情况，则直接在链表尾部插入数据</span></span><br><span class="line">        <span class="comment">// 注：新增节点后，需判断链表长度是否&gt;8（8 = 桶的树化阈值）：若是，则把链表转换为红黑树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 对于ii：若数组的下1个位置，表示已到表尾也没有找到key值相同节点，则新建节点 = 插入节点</span></span><br><span class="line">                <span class="comment">// 注：此处是从链表尾插入，与JDK 1.7不同（从链表头插入，即永远都是添加到数组的位置，原来数组位置的数据则往后移）</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 插入节点后，若链表节点&gt;树阈值，则将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 树化操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于i</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新p指向下一个节点，继续遍历</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对i情况的后续操作：发现key已存在，直接用新value 覆盖 旧value &amp; 返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">// 替换旧值时会调用的方法（默认实现为空）</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount; <span class="comment">//表示散列表结构被修改的次数，替换Node元素的value不计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入成功后，判断实际存在的键值对数量size &gt; 最大容量threshold</span></span><br><span class="line">    <span class="comment">// 若 &gt; ，则进行扩容 -&gt;&gt;分析4（但单独讲解，请直接跳出该代码块）</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"></span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 插入成功时会调用的方法（默认实现为空）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析3：putTreeVal(this, tab, hash, key, value)</span></span><br><span class="line"><span class="comment">     * 作用：向红黑树插入 or 更新数据（键值对）</span></span><br><span class="line"><span class="comment">     * 过程：遍历红黑树判断该节点的key是否与需插入的key 相同：</span></span><br><span class="line"><span class="comment">     *      a. 若相同，则新value覆盖旧value</span></span><br><span class="line"><span class="comment">     *      b. 若不相同，则插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>put流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-4f700e47dda01f7f.png" alt="img"></p><h3 id="扩容机制（即-resize（）函数方法）"><a href="#扩容机制（即-resize（）函数方法）" class="headerlink" title="扩容机制（即 resize（）函数方法）"></a><strong>扩容机制（即 resize（）函数方法）</strong></h3><p><strong>扩容流程如下：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-9fb3fec07a0764ec.png" alt="img"></p><p><strong>源码分析：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//为什么需要扩容？ 元素太多就会导致查询效率由O(1)-&gt;O(n) 扩容后使得元素更加分散，查询效率更高</span></span><br><span class="line">   <span class="comment">//为了解决哈希冲突导致的链化影响查询效率的问题，扩容会缓解该问题</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析4：resize（）</span></span><br><span class="line"><span class="comment">     * 该函数有2种使用情况：1.初始化哈希表 2.当前数组容量过小，需扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   final Node&lt;K,V&gt;[] <span class="function"><span class="title">resize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 扩容前的数组（当前数组）</span></span><br><span class="line">    int oldCap = (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 扩容前的数组的容量 = 长度</span></span><br><span class="line">    int oldThr = threshold;<span class="comment">// 扩容前的数组的阈值</span></span><br><span class="line">    int newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对情况2：若扩容前的数组容量超过最大值，则不再扩充</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 针对情况2：若无超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 通过右移扩充2倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对情况1：初始化哈希表（采用指定 or 默认值）</span></span><br><span class="line">    <span class="comment">/*oldCap == 0 ，说明hashMap中的散列表是null</span></span><br><span class="line"><span class="comment">*1. new HashMap(initCap,loadFactor);</span></span><br><span class="line"><span class="comment">    *   2. new HashMap(intiCap);</span></span><br><span class="line"><span class="comment">    *   3. new HashMap(map);并且这个map有数据 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">&quot;rawtypes&quot;</span>,<span class="string">&quot;unchecked&quot;</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line"><span class="comment">//第三种情况：桶位已经形成链表</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//低位链表：存放扩容之前的数组下标位置，与当期位置的下标位置一致</span></span><br><span class="line">                <span class="comment">//高位链表：存放扩容之后的数组下标位置为 当前数组下标位置 + 扩容之后数组的长度</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩容流程（含 与 <code>JDK 1.7</code> 的对比）：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-a31e51b24f135d7c.png" alt="img"></p><blockquote><p>这里主要是<code>JDK 1.8</code>扩容时，数据存储位置重新计算的方式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708221831834.png" alt="image-20210708221831834"></p><p><strong>结论示意图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-2466f5db47fd7685.png" alt="img"></p><p><strong>数组位置转换的示意图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708214220642.png" alt="image-20210708214220642"></p><blockquote><p><code>JDK 1.8</code>根据此结论作出的新元素存储位置计算规则非常简单，提高了扩容效率，具体如下图。</p><p>这与 <code>JDK 1.7</code>在计算新元素的存储位置有很大区别：<code>JDK 1.7</code>在扩容后，都需按照原来方法重新计算，即<br> <code>hashCode（）</code>-&gt;&gt; 扰动处理 -&gt;&gt;<code>（h &amp; length-1）</code>）。</p></blockquote><p><strong>与 <code>JDK 1.7</code>的区别：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-e706a4817a35b021.png" alt="img"></p><h3 id="步骤3：从HashMap中获取数据"><a href="#步骤3：从HashMap中获取数据" class="headerlink" title="步骤3：从HashMap中获取数据"></a>步骤3：从HashMap中获取数据</h3><ul><li><p>假如理解了上述<code>put（）</code>函数的原理，那么<code>get（）</code>函数非常好理解，因为二者的过程原理几乎相同。</p></li><li><p><code>get（）</code>函数的流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-a02a9b827efebe30.png" alt="img"></p></li><li><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 函数原型</span></span><br><span class="line"><span class="comment">   * 作用：根据键key，向HashMap获取对应的值</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   map.get(key)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1. 计算需获取数据的hash值</span></span><br><span class="line">    <span class="comment">// 2. 通过getNode（）获取所查询的数据 -&gt;&gt;分析1</span></span><br><span class="line">    <span class="comment">// 3. 获取后，判断数据是否为空</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1：getNode(hash(key), key))</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 计算存放在数组table中的位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 通过该函数，依次在数组、红黑树、链表中查找（通过equals（）判断）</span></span><br><span class="line">        <span class="comment">// a. 先在数组中找，若存在，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. 若数组中没有，则到红黑树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// c. 若红黑树中也没有，则通过遍历，到链表中寻找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="步骤4：对HashMap的其他操作"><a href="#步骤4：对HashMap的其他操作" class="headerlink" title="步骤4：对HashMap的其他操作"></a>步骤4：对HashMap的其他操作</h3><p><code>HashMap</code>除了核心的<code>put（）</code>、<code>get（）</code>函数，还有以下主要使用的函数方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清除哈希表中的所有键值对</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;  <span class="comment">// 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断HashMap是否为空；size == 0时 表示为 空 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;  <span class="comment">// 将指定Map中的键值对 复制到 此Map中</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;  <span class="comment">// 删除该键值对</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">// 判断是否存在该键的键值对；是 则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;  <span class="comment">// 判断是否存在该值的键值对；是 则返回true</span></span><br></pre></td></tr></table></figure><ul><li>关于上述方法的源码的原理 同 <code>JDK 1.7</code>，此处不作过多描述。</li><li>总结内容 = 数据结构、主要参数、添加 &amp; 查询数据流程、扩容机制.</li></ul><h4 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a>removeNode()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line"><span class="comment">//tab：引用当前hashMap的散列表</span></span><br><span class="line"><span class="comment">//p：当前node元素（桶位中头元素）</span></span><br><span class="line"><span class="comment">//n：表示散列表数组长度</span></span><br><span class="line"><span class="comment">//index:表示寻址结果</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说明路由的桶位是有数据的，需要进行查找操作，并且删除</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//node：查找到的结果</span></span><br><span class="line"><span class="comment">//e：当前Node的下一个元素</span></span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种情况：当前桶位中的元素 即为要删除的元素</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//说明当前桶位不止一个元素，可能是链表，可能是红黑树</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) 判断当前桶位是否升级为红黑树</span><br><span class="line">    <span class="comment">//第二种情况：红黑树查找操作</span></span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//第三种情况：链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//循环链表 查找node节点</span></span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;  <span class="comment">//保证e一直往下查找</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);一直向下找</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line"><span class="comment">//判断node不为空的话，说明按照key查找到需要删除的数据了</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//第一种情况：node是树节点，说明需要进行树节点移除操作</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种情况：桶位元素即为查找结果，则将该元素的下一个元素放到桶位中</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种情况：将当前元素p的下一个元素 设置成 要删除的下一个元素</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">依次将数组中的元素重置为<span class="keyword">null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="额外补充：关于HashMap的其他问题"><a href="#额外补充：关于HashMap的其他问题" class="headerlink" title="额外补充：关于HashMap的其他问题"></a>额外补充：关于HashMap的其他问题</h2><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708221739910.png" alt="image-20210708221739910" style="zoom: 67%;" /><h3 id="哈希表如何解决Hash冲突"><a href="#哈希表如何解决Hash冲突" class="headerlink" title="哈希表如何解决Hash冲突?"></a>哈希表如何解决Hash冲突?</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708221806238.png" alt="image-20210708221806238"></p><h3 id="为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？"><a href="#为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？" class="headerlink" title="为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？"></a>为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-ce5aa2227f269410.jpg" alt="img"></p><p> <code>HashMap</code> 线程不安全的其中一个重要原因：多线程下容易出现<code>resize（）</code>死循环。 <strong>本质 = 并发 执行 <code>put（）</code>操作导致触发 扩容行为，从而导致 环形链表，使得在获取数据遍历链表时形成死循环，即<code>Infinite Loop</code></strong></p><p><strong>先看扩容的源码分析<code>resize（）：</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析：resize(2 * table.length)</span></span><br><span class="line"><span class="comment">   * 作用：当容量不足时（容量 &gt; 阈值），则扩容（扩到2倍）</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 保存旧数组（old table） </span></span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保存旧容量（old capacity ），即数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 根据新容量（2倍容量）新建1个数组，即新table  </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. （重点分析）将旧数组上的数据（键值对）转移到新table中，从而完成扩容 -&gt;&gt;分析1.1 </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 新数组table引用到HashMap的table属性上</span></span><br><span class="line">    table = newTable;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 重新设置阈值  </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1.1：transfer(newTable); </span></span><br><span class="line"><span class="comment">   * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span></span><br><span class="line"><span class="comment">   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1. src引用了旧数组</span></span><br><span class="line">      Entry[] src = table; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 获取新数组的大小 = 获取新容量大小                 </span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">          <span class="comment">// 3.1 取得旧数组的每个元素  </span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 3.2 释放旧数组的对象引用（for循环后，旧数组不再引用任何对象）</span></span><br><span class="line">              src[j] = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">              <span class="keyword">do</span> &#123; </span><br><span class="line">                  <span class="comment">// 3.3 遍历 以该数组元素为首 的链表</span></span><br><span class="line">                  <span class="comment">// 注：转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开</span></span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next; </span><br><span class="line">                 <span class="comment">// 3.3 重新计算每个元素的存储位置</span></span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 <span class="comment">// 3.4 将元素放在数组上：采用单链表的头插入方式 = 在链表头上存放数据 = 将数组位置的原有数据放在后1个指针、将需放入的数据放到数组位置中</span></span><br><span class="line">                 <span class="comment">// 即 扩容后，可能出现逆序：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line">                 e.next = newTable[i]; </span><br><span class="line">                 newTable[i] = e;  </span><br><span class="line">                 <span class="comment">// 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点</span></span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">             <span class="comment">// 如此不断循环，直到遍历完数组上的所有数据元素</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面可看出：在扩容<code>resize（）</code>过程中，在将旧数组上的数据 转移到 新数组上时，<strong>转移数据操作 = 按旧链表的正序遍历链表、在新链表的头部依次插入</strong>，即在转移数据、扩容后，容易出现<strong>链表逆序的情况</strong>。</p><blockquote><p>设重新计算存储位置后不变，即扩容前 = 1-&gt;2-&gt;3，扩容后 = 3-&gt;2-&gt;1</p></blockquote><p>此时若（多线程）并发执行 <code>put（）</code>操作，一旦出现扩容情况，则 <strong>容易出现 环形链表</strong>，从而在获取数据、遍历链表时 形成死循环（<code>Infinite Loop</code>），即 死锁的状态，具体请看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-8748867d2085b481.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-4989e9b5e1b3ef6d.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708221933718.png" alt="image-20210708221933718"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708222003422.png" alt="image-20210708222003422"></p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708222037780.png" alt="image-20210708222037780"></p><p>由于 <code>JDK 1.8</code> 转移数据操作 = <strong>按旧链表的正序遍历链表、在新链表的尾部依次插入</strong>，所以不会出现链表 <strong>逆序、倒置</strong>的情况，故不容易出现环形链表的情况。</p><h3 id="为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键？"><a href="#为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键？" class="headerlink" title="为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键？"></a>为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键？</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-318b6e178419065b.png" alt="img"></p><h3 id="HashMap-中的-key若-Object类型，-则需实现哪些方法？"><a href="#HashMap-中的-key若-Object类型，-则需实现哪些方法？" class="headerlink" title="HashMap 中的 key若 Object类型， 则需实现哪些方法？"></a>HashMap 中的 <code>key</code>若 <code>Object</code>类型， 则需实现哪些方法？</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-23536584ac590783.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="2021/02/19/Java%E9%9B%86%E5%90%88%E7%89%B9%E7%82%B9/"/>
      <url>2021/02/19/Java%E9%9B%86%E5%90%88%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="java集合及特点"><a href="#java集合及特点" class="headerlink" title="java集合及特点"></a>java集合及特点</h2><p>  java中常见的数据结构，主要分为Collection和Map两种主要接口，程序中的数据结构是继承这些接口的数据结构类。</p><p><strong>Collection接口</strong>：</p><ol><li><p>List 接口继承：ArrayList、 Vector、 LinkedList等实现；</p></li><li><p>Set 接口继承：HashSet、LinkedHashSet、TreeSet等实现。</p><p>​          </p></li></ol><p><strong>Map接口</strong>： HashMap、SortedMap继承，LinkedHashMap、TreeMap等实现。</p><p>几个常用的类及其特点：</p><p><strong>ArrayList</strong></p><ul><li>数据结构：ArrayList底层使用的是Object数组；</li><li>存储结构：物理存储单元上连续的存储结构；</li><li>线程是否安全：线程不安全的；ArrayList是非同步的，方法没有加锁；</li><li>特点：方便查找，但是新增和删除操作的时候，是要有移动位置的操作，所以ArrayList适用于存储，查询操作比较频繁的数据存储。</li></ul><p><strong>LinkedList</strong></p><ul><li>数据结构：LinkedList底层使用的是双向循环链表数据结构；</li><li>存储方式：物理存储单元上非连续、非顺序的存储结构；</li><li>线程是否安全：线程不安全的；</li><li>特点：存储每一个元素消耗的空间要比ArrayList大，并且由于它的存储结构，导致他的查询不是很方便，需要去遍历每一个节点，然后查找该节点后继节点，不适合存储需要大量查询操作的数据存储，但插入比ArrayList方便，不需要进行换位操作，只需要改变指针前驱和后继，增删操作很快，不耗费多余资源 。</li></ul><p><strong>List总结</strong></p><ul><li>所有的List中只能容纳单个不同类型的对象组成的表，而不是Key－Value键值对。例如：[ tom,1,c ]</li><li>所有的List中可以有相同的元素，例如Vector中可以有 [ tom,koo,too,koo ]</li><li>所有的List中可以有null元素，例如[ tom,null,1 ]</li><li>基于Array的List（Vector，ArrayList）适合查询，而LinkedList 适合添加，删除操作</li></ul><p><strong>Vector</strong></p><ul><li>数据结构：Vector底层使用的是Object数组；</li><li>存储结构：物理存储单元上连续的存储结构；</li><li>线程是否安全：Vector是线程安全的，Vector类的方法都是有锁的；</li><li>特点：Vector是线程安全的，可以由多个线程访问一个Vector对象。但当一个线程访问的话，保证线程安全会消耗一定的资源，因此一个线程访问就无需考虑是否线程安全的问题，建议使用ArrayList。</li></ul><p><strong>TreeSet</strong></p><ul><li>数据结构：底层数据结构是二叉树；</li><li>线程是否安全：不保证线程安全的；</li><li>特点：有序的，并且没有重复元素。可以指定一个顺序，排序后按升序排列元素 。</li></ul><p><strong>HashSet</strong></p><ul><li>数据结构：链表和红黑树（jdk1.8以后）；</li><li>线程是否安全：不保证线程安全的；</li><li>特点：元素没有顺序(因为底层用的是HashMap，HashMap本身中的元素度没有顺序)、元素不能重复，不可随机访问包含的元素 ，只能用Iterator实现单向遍历，多次迭代访问，元素的顺序可能不同  。</li></ul><p><strong>Set总结</strong></p><ul><li>Set实现的基础是Map（HashMap）；</li><li>Set中的元素是不能重复的，如果使用add(Object obj)方法添加已经存在的对象，则会覆盖前面的对象。</li></ul><p><strong>HashMap</strong></p><ul><li>数据结构：链表和红黑树（jdk1.8以后）；</li><li>线程是否安全：非线程安全；</li><li>特点：Null可以做主键，但只能有一个，可以有多个Value为Null；适用于在Map中插入、删除和定位元素。</li></ul><p><strong>TreeMap</strong></p><ul><li>数据结构：树；</li><li>线程是否安全：非线程安全；</li><li>特点：有序的，适用于按自然顺序或自定义顺序遍历键（key）。</li></ul><p><strong>LinkedHashMap</strong></p><ul><li>数据结构：HashMap+LinkedList；</li><li>线程是否安全：非线程安全；</li><li>特点：有序、Key和Value都允许空、Key重复会覆盖、Value允许重复。</li></ul><p><strong>java 中, 什么查询最快？</strong></p><p>根据数组下标, 查找数组的元素, 是java中天下第一快的操作!</p><p><strong>数组和ArrayList 的区别:</strong></p><ul><li>数组可以存储数据类型一致的一组数据, 没有提供操作算法, 使用数组需要自行编写算法, 使用数组编码的专用算法,<br>性能最佳！而ArrayList也可以存储一组数据, 其内部也是数组, 还提供操作算法, 使用方便. 通用算法好处是使用方便,<br>算法是经过检验的, 非常可靠。但是如果期望高性能, 使用数组, 如期望高开发效率, 使用Arraylist。</li></ul><p><strong>Vector、ArrayList和LinkedList使用</strong> </p><p>大多数情况下，从性能上来说ArrayList最好，但是当集合内的元素需要频繁插入、删除时LinkedList会有比较好的表现，但是它们三个性能都比不上数组。所以： </p><ul><li>如果能用数组的时候(元素类型固定，数组长度固定)，请尽量使用数组来代替List；</li><li>如果没有频繁的删除插入操作，又不用考虑多线程问题，优先选择ArrayList；</li><li>如果在多线程条件下使用，可以考虑Vector；</li><li>如果需要频繁地删除插入，LinkedList就有了用武之地；</li><li>如果你什么都不知道，用ArrayList没错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码分析</title>
      <link href="2021/02/13/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>2021/02/13/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="linkedList说明"><a href="#linkedList说明" class="headerlink" title="linkedList说明"></a>linkedList说明</h2><p>LinkedList是List接口的另一种实现，它的底层是基于双向链表实现的，因此它具有插入删除快而查找修改慢的特点，此外，通过对双向链表的操作还可以实现队列和栈的功能。</p><h3 id="LinkedList解释说明"><a href="#LinkedList解释说明" class="headerlink" title="LinkedList解释说明"></a>LinkedList解释说明</h3><p>说明文档解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* 双向链表是实现了List和Deque接口。实现了所有List的操作和允许值为Null。</span><br><span class="line">* </span><br><span class="line">* 所有的操作执行都与双向链表相似。操作索引将遍历整个链表，至于是从头开始遍历还是从尾部</span><br><span class="line">* 开始遍历取决于索引的下标距离哪个比较近。</span><br><span class="line">* </span><br><span class="line">* 需要注意的是这个方法不是同步的方法，需要同步的应用(ConcurrentLinkedDeque高效的队列),如果多个</span><br><span class="line">* 线程同时操作LinkedList实例和至少有一个线程修改list的结构,必须在外部加同步操作。</span><br><span class="line">* 关于结构性操作可以看前面的HashMap的介绍。这个同步操作通常是压缩在某些对象头上面。(synchronized就是存储在对象头上面)</span><br><span class="line">* </span><br><span class="line">* 如果对象头不存在这样的对象，这个列表应该使用&#123;@link Collections#synchronizedList Collections.synchronizedList&#125;工具</span><br><span class="line">* 来封装，这个操作最好是在创建List之前完成，防止非同步的操作。</span><br><span class="line">* List list &#x3D; Collections.synchronizedList(new ArrayList(...));</span><br><span class="line">* 但是一般不用这个方法，而是用JUC包下的ConcurrentLinkedDeque更加高效,(因为这个底层采用的是CAS操作)</span><br><span class="line">* </span><br><span class="line">* 快速失败机制，当一个list被多个线程同时修改的时候会抛出异常。但是不能用来保证线程安全。</span><br><span class="line">* 所以在多线程环境下，还是要自己加锁或者采用JUC包下面的方法来保证线程安全，</span><br><span class="line">* 而不能依靠fail-fast机制抛出异常，这个方法只是用来检测bug。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LinkedList数据结构"><a href="#LinkedList数据结构" class="headerlink" title="LinkedList数据结构"></a>LinkedList数据结构</h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527093412978.png" alt="image-20210527093412978" style="zoom: 50%;" /><ol><li>节点Node主要由三部分组成：pre：前驱引用，ele1：节点信息，next：后驱引用。</li><li>first和last分别指向头结点和尾结点。</li></ol><p><strong>源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Node 类是LinkedList中的私有内部类，LinkedList中就是通过Node来存储集合中的元素。</li><li>E ：节点的值。</li><li>Node next：当前节点的后一个节点的引用（可以理解为指向当前节点的后一个节点的指针）。</li><li>Node prev：当前节点的前一个节点的引用（可以理解为指向当前节点的前一个节点的指针）。</li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527093919777.png" alt="image-20210527093919777" style="zoom:50%;" /><ol><li>LinkedList继承了AbstractSequentialList抽象类，在遍历LinkedList的时候，官方更推荐使用顺序访问，也就是使用迭代器。因为LinkedList底层是通过一个链表来实现的，虽然LinkedList也提供了get（int index）方法，但是底层的实现是：每次调用get（int index）方法的时候，都需要从链表的头部或者尾部进行遍历，每次的遍历时间复杂度是O(index)，而相对比ArrayList的底层实现，每次遍历的时间复杂度都是O(1)。所以不推荐通过get（int index）遍历LinkedList。</li><li>至于从链表的头部或者尾部进行遍历，官方对遍历进行了优化：通过判断索引index更靠近链表的头部还是尾部来选择遍历的方向，因此这里遍历LinkedList推荐使用迭代器。</li><li>实现了List接口。即提供List接口中所有方法的实现。</li><li>实现了Cloneable接口，支持克隆（浅克隆），底层实现：LinkedList节点并没有被克隆，只是通过Object的clone（）方法得到的Object对象强制转化为了LinkedList,然后把它内部的实例域都置空，然后把被拷贝的LinkedList节点中的每一个值都拷贝到clone中。（后面有源码解析）</li><li>实现了Deque接口，实现了Deque所有的可选的操作。</li><li>实现了Serializable接口。表明它支持序列化。和ArrayList一样，底层都提供了两个方法：readObject（ObjectInputStream o）、writeObject（ObjectOutputStream o），用于实现序列化，而在底层只序列化节点的个数和节点的值。</li></ol><blockquote><p>注：由于后面源码分析过多，所以直接把总结部分放到这里。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>LinkedList底层是一个双链表，是一个直线型的链表结构。</p></li><li><p>LinkedList内部实现了6种主要的辅助方法：它们都是private修饰的方法或者没有修饰符，表明这里都只是为LinkedList的其他方法提供服务，或者同一个包中的类提供服务。在LinkedList内部，绝大部分方法的实现都是依靠这6种辅助方法，所以只要把这6个辅助方法理解了，LinkedList的基本操作也就掌握了。</p><ul><li><p>void linkFirst(E e)</p></li><li><p>void linkLast(E e)</p></li><li><p>linkBefore(E e, Node<E> succ)</p></li><li><p>E unlinkFirst(Node<E> f)</p></li><li><p>E unlinkLast(Node<E> l)</p></li><li><p>E unlink(Node<E> x)</p></li></ul></li></ol><h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h2><h3 id="方法字段"><a href="#方法字段" class="headerlink" title="方法字段"></a>方法字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向第一个节点</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向最后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>size：用来记录LinkedList的元素个数。</li><li>Node first：用来表示LinkedList的头节点。</li><li>Node last：用来表示LinkedList的尾节点。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//包含一个数组的构造函数，链表中的顺序按照集合中的元素顺序进行插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>();</span><br><span class="line">     addAll(c);<span class="comment">//这里调用了addAll(),就是插入所有元素</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在传入一个集合进行初始化的时候主要调用了addAll()方法，那么这个addAll()方法是怎么样添加元素的呢？</p><h3 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a>addAll(int index, Collection&lt;? extends E&gt; c)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//通过调用addAll(int index, Collection&lt;? extends E&gt; c) 完成集合的添加。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//几乎所有的涉及到在指定位置添加或者删除或修改操作都需要判断传进来的参数是否合法。</span></span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//先把集合转化为数组，然后为该数组添加一个新的引用（Objext[] a）。</span></span><br><span class="line">        Object[] a = c.toArray();<span class="comment">//为什么要将集合转为数组？？？？？</span></span><br><span class="line">        <span class="comment">//存储数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="comment">//如果待添加的集合为空，直接返回，无需进行后面的步骤。后面都是用来把集合中的元素添加到LinkedList中</span></span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node&lt;E&gt; succ：指代待添加节点的位置。Node&lt;E&gt; pred：指代待添加节点的前一个节点。</span></span><br><span class="line"><span class="comment">//下面的代码是依据新添加的元素的位置分为两个分支：</span></span><br><span class="line"><span class="comment">//1.新添加的元素的位置位于LinkedList最后一个元素的后面。</span></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;<span class="comment">//插入的位置刚好在最后位置</span></span><br><span class="line">            <span class="comment">//则succ为空</span></span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//前驱为last所引用的尾结点</span></span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//寻找插入的节点位置</span></span><br><span class="line">            succ = node(index);</span><br><span class="line">            <span class="comment">//找到插入节点的前驱</span></span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环插入每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;<span class="comment">//向下转型</span></span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);<span class="comment">//生成一个新节点</span></span><br><span class="line">            <span class="comment">//前驱为空，表示在第一个位置插入</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="comment">//否则在index前面插入新节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//后继为空</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) </span><br><span class="line">            last = pred;<span class="comment">//在末尾插入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则链接最后的节点</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;<span class="comment">//节点个数增加</span></span><br><span class="line">        modCount++;<span class="comment">//结构性修改</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合转数组</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>中间位置插入元素图解如下：</p><ol><li><p>找到节点</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527141853019.png" alt="image-20210527141853019"  /></li><li><p>插入新节点</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527141952529.png" alt="image-20210527141952529"></p></li><li><p>改变指针</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527142031213.png" alt="image-20210527142031213"></p></li></ol><h3 id="linkFirst-E-e"><a href="#linkFirst-E-e" class="headerlink" title="linkFirst(E e)"></a>linkFirst(E e)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//在头部插入一个新节点</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//因为需要把插入的该元素设置为头节点，所以需要新建一个变量把原来的头节点存储起来。</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="comment">//然后新建一个节点，保存插入节点的值e，由于插入的节点为头结点，因此前驱为null，而后继则为原来的头结点</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">       <span class="comment">//将头结点引用指向新节点</span></span><br><span class="line">       first = newNode;</span><br><span class="line">       <span class="comment">//如果原来的头结点为空，则说明没有头结点，头尾节点均为null</span></span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">//将新节点置为尾结点</span></span><br><span class="line">           last = newNode;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">//否则原来的头结点的前引用指向新节点</span></span><br><span class="line">           f.prev = newNode;</span><br><span class="line">       <span class="comment">//size和modCount自增</span></span><br><span class="line">       size++;</span><br><span class="line">       modCount++<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>图解如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527162010829.png" alt="image-20210527162010829"></p><h3 id="linkLast-E-e"><a href="#linkLast-E-e" class="headerlink" title="linkLast(E e)"></a>linkLast(E e)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在尾部插入一个新节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为需要把插入的该元素设置为尾节点，所以需要新建一个变量把原来的尾节点存储起来。</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="comment">//然后新建一个节点，保存插入节点的值e，由于插入的节点为尾结点，因此前驱为l，而后继则为null</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//last引用指向新节点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">         <span class="comment">//如果原来的尾结点为空，则说明没有尾结点，则尾结点为新节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则原来尾结点的后引用指向新的尾结点</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>过程与头部插入节点类似。</p></blockquote><h3 id="linkBefore-E-e-Node-succ"><a href="#linkBefore-E-e-Node-succ" class="headerlink" title="linkBefore(E e, Node succ)"></a>linkBefore(E e, Node<E> succ)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在某个节点之前插入一个新节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="comment">//找到该节点的前一个节点，因为要在succ前面插入一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;<span class="comment">//</span></span><br><span class="line">    <span class="comment">//新节点的前一个节点就是原来succ的前一个节点（pred），后一个节点当然就是succ</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">    <span class="comment">//如果pred为空，说明要插入的节点位置为第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则pred的下一个节点就是新节点</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br></pre></td></tr></table></figure><h3 id="unlinkFirst-Node-f"><a href="#unlinkFirst-Node-f" class="headerlink" title="unlinkFirst(Node f)"></a>unlinkFirst(Node<E> f)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//删除LinkedList中第一个节点（该节点不为空,并且返回删除的节点的值）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//（因为我们需要设置f节点的下一个节点为头结点，而且需要把f节点的值设置为空）</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//接着判断一个它的下一个节点是否为空，如果为空的话，则需要把last设置为空。否则</span></span><br><span class="line">  <span class="comment">//的话，需要把next的prev设置为空，因为next现在指代头节点。</span></span><br><span class="line">  <span class="comment">//定义一个变量element指向待删除节点的值，</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="comment">//接着定义一个变量next指向待删除节点的下一个节点。</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        <span class="comment">//接着把f的值和它的next设置为空，把它的下一个节点设置为头节点。</span></span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>; <span class="comment">// help GC 解开与下一个元素的连接，方便GC回收</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="comment">//如果待删除节点的下一个节点为空，说明LinkedList中就一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//则需要把last设置为空。</span></span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//断开后一个节点与待删除节点的连接</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="unlinkLast-Node-l"><a href="#unlinkLast-Node-l" class="headerlink" title="unlinkLast(Node l)"></a>unlinkLast(Node<E> l)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//删除LinkedList的最后一个节点。（该节点不为空,并且返回删除节点对应的值）</span></span><br><span class="line"><span class="comment">//思路和unlinkFirst（）方法差不多。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node<E> x)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//删除一个节点（该节点不为空）</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建变量用来存储当前被删除节点的值，后面要把该节点返回</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">     <span class="comment">//第二个变量用来存储待删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">     <span class="comment">//第三个变量用来存储待删除节点的后一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//判断prev</span></span><br><span class="line">     <span class="comment">//如果待删除节点的前一个节点为空，表明待删除的节点是头结点</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//把待删除节点的后一个节点设置为头结点</span></span><br><span class="line">            first = next;</span><br><span class="line">        <span class="comment">//如果不为空，就需要把待删除的节点的前、后节点链接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将待删除节点的前后节点进行连接</span></span><br><span class="line">            prev.next = next;</span><br><span class="line">            <span class="comment">//断开待删除节点与其前一个节点的联系</span></span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//判断next是否为空</span></span><br><span class="line">        <span class="comment">//如果为空则表明待删除节点是尾节点，则需要把待删除节点的前一个节点设置为尾节点。</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        <span class="comment">//如果不为空,则把前后节点进行连接</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>图解如下：</p><ol><li>找到待删除节点的信息以及它的前后节点</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527204905178.png" alt="image-20210527204905178"></p><ol start="2"><li>修改前置指针</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527205037292.png" alt="image-20210527205037292"></p><ol start="3"><li><p>修改后继指针</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527205107998.png" alt="image-20210527205107998"></p></li><li><p>将待删除节点置空，方便GC</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210527205148729.png" alt="image-20210527205148729"></p><h3 id="node-int-index"><a href="#node-int-index" class="headerlink" title="node(int index)"></a>node(int index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//计算指定索引上的节点（返回Node）</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">//比较index更靠近链表（LinkedList）的头节点还是尾节点。然后进行遍历，获取相应的节点。</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst()"></a>removeFirst()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//提供给用户使用的删除头结点，并返回删除的值。</span></span><br><span class="line"><span class="comment">//直接调用了上面的工具方法unlinkFirst（Node f）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="removeLast"><a href="#removeLast" class="headerlink" title="removeLast()"></a>removeLast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//删除链表中的最后一个节点，并返回被删除节点的值。</span></span><br><span class="line"><span class="comment">//和上面一样调用了unlinkLast（Node last）方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="addFirst-E-e-、addLast-E-e"><a href="#addFirst-E-e-、addLast-E-e" class="headerlink" title="addFirst(E e)、addLast(E e)"></a>addFirst(E e)、addLast(E e)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在LinkedList头部添加一个新的元素、尾部添加一个新元素,都是调用了私有方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a>contains(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断LinkedList是否包含某一个元素,底层通过调用indexof()。</span></span><br><span class="line"><span class="comment">//该方法主要用于计算元素在LinkedList中的位置。</span></span><br><span class="line"><span class="comment">//思路：先依据obejct是否为空，分为两种情况，然后通过在每种情况下，从头节点开始遍历LinkedList，判断是否有与object相等的元素，如果有，则返回对应的位置index，如果找不到，则返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//计算LinkedList的大小,直接返回实例域size。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加一个新元素。直接在最后面添加，调用了linkLast（）方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//从LinkedList中删除指定元素。（且只删除第一次出现的指定的元素，如果指定的元素在集合中不存在，则返回false，否则返回true）</span></span><br><span class="line"><span class="comment">//该方法也是通过object是否为空分为两种情况去，之后与LinkedList中的每一个元素比较，如果找到了，就删掉，返回true即可。如果找不到，则返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//清空LinkedList中的所有元素</span></span><br><span class="line"><span class="comment">//该方法也简单，直接遍历整个LinkedList，然后把每个节点都置空,最后要把头节点和尾节点设置为空，size也设置为空，但是modCount仍然自增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">        <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">        <span class="comment">//   more than one generation</span></span><br><span class="line">        <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = <span class="keyword">null</span>;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取对应index的节点的值。</span></span><br><span class="line"><span class="comment">//通过node（）方法返回其值。（node（）方法依据索引的值返回其对应的节点。）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//设置对应index的节点的值。</span></span><br><span class="line"><span class="comment">//首先检查一下索引是否合法，然后通过node（）方法求出旧值，然后设置新值。最后把旧值返回回去。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        E oldVal = x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在指定的位置上添加新的元素。</span></span><br><span class="line"><span class="comment">//在方法中先判断新添加的元素是否是位于LinkedList的最后，然后则直接调用linkLast（）方法添加即可。否则的话，调用linkBefore（）添加即可。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//移除指定位置上的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="isPositionIndex-int-index"><a href="#isPositionIndex-int-index" class="headerlink" title="isPositionIndex(int index)"></a>isPositionIndex(int index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断新添加元素的时候，传进来的index是否合法，而且新添加的元素可能在LinkedList最后一个元素的后面，所以这里允许index&lt;=size。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="checkElementIndex-int-index"><a href="#checkElementIndex-int-index" class="headerlink" title="checkElementIndex(int index)"></a>checkElementIndex(int index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断参数index是否是元素的索引（如果不是则抛出异常）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="checkPositionIndex-int-index"><a href="#checkPositionIndex-int-index" class="headerlink" title="checkPositionIndex(int index)"></a>checkPositionIndex(int index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断新添加元素的时候，传进来的index是否合法，（调用的是isPositionIndex(index)方法）而且新添加的元素可能在LinkedList最后一个元素的后面，所以这里允许index&lt;=size。如果不合法，则抛出异常。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="lastIndexOf-Object-o"><a href="#lastIndexOf-Object-o" class="headerlink" title="lastIndexOf(Object o)"></a>lastIndexOf(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在LinkedList中查找object在LinkedList中的位置。（从后向前遍历，只返回第一出线的元素的索引，如果没找到，则返回-1）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LinkedList是基于双向链表实现的，不论是增删改查方法还是队列和栈的实现，都可通过操作结点实现。</li><li>LinkedList无需提前指定容量，因为基于链表操作，集合的容量随着元素的加入自动增加。</li><li>LinkedList删除元素后集合占用的内存自动缩小，无需像ArrayList一样调用trimToSize()方法。</li><li>LinkedList的所有方法没有进行同步，因此它也不是线程安全的，应该避免在多线程环境下使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码分析</title>
      <link href="2021/02/06/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>2021/02/06/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList集合底层数据结构"><a href="#ArrayList集合底层数据结构" class="headerlink" title="ArrayList集合底层数据结构"></a>ArrayList集合底层数据结构</h2><p>ArrayList是由可调整大小的数组实现的，与数组不同的是：数组一旦初始化长度就不可以发生改变，而ArrayList长度可变。</p><p>数组特点：</p><ul><li>增删慢：每次删除元素，都需要更改数组长度、拷贝以及移动元素位置。</li><li>查询快：由于数组在内存中是一块连续空间，因此可以根据地址+索引的方式快速获取对应位置上的元素。 </li></ul><h2 id="ArrayList继承关系"><a href="#ArrayList继承关系" class="headerlink" title="ArrayList继承关系"></a>ArrayList继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="Serializable标记性接口"><a href="#Serializable标记性接口" class="headerlink" title="Serializable标记性接口"></a>Serializable标记性接口</h3><ol><li>类的序列化由实现java.io.Serializable接口的类启用。 不实现此接口的类将不会使任何状态序列化或反序列化。 可序列化类的所有子类型都是可序列化的。 序列化接口没有方法或字段，仅用于标识可串行化的语义。</li></ol><blockquote><p>序列化：将对象的数据写入到文件(写对象)。</p><p>反序列化：将文件中对象的数据读取出来(读对象)。</p></blockquote><ol start="2"><li><p>Serializable源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Cloneable-标记性接口"><a href="#Cloneable-标记性接口" class="headerlink" title="Cloneable 标记性接口"></a>Cloneable 标记性接口</h3><ol><li><p>一个类实现 Cloneable 接口来指示 Object.clone() 方法，该方法对于该类的实例进行字段的复制是合法的。在不实现 Cloneable 接口的实例上调用对象的克隆方法会导致异常 CloneNotSupportedException 被抛出。简言：克隆就是依据已经有的数据，创造一份新的完全一样的数据拷贝。</p></li><li><p>Cloneable源码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>克隆的前提条件</li></ol><ul><li><p>被克隆对象所在的类必须实现 Cloneable 接口</p></li><li><p>必须重写 clone 方法</p></li></ul><ol start="4"><li><p>clone源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="RandomAccess标记接口"><a href="#RandomAccess标记接口" class="headerlink" title="RandomAccess标记接口"></a>RandomAccess标记接口</h3><ol><li><p>此标记接口由 List 实现使用，以表明它们支持快速（通常为恒定时间）随机访问。</p></li><li><p>此接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问列表或顺序访问列表时提供良好的性能。</p></li></ol><h3 id="AbstractList抽象类"><a href="#AbstractList抽象类" class="headerlink" title="AbstractList抽象类"></a>AbstractList抽象类</h3><ol><li>该类提供了List接口的骨架实现，以最小化实现由”随机存取”数据存储(如阵列)支持的此接口所需的工作量。对于顺序访问数据 (例如链接列表) ，应该使用AbstractSequentialist优先于此类。</li><li>要实现一个不可修改的列表，程序员只需要扩展这个类并提供get (int)和size ()方法的实现。</li><li>要实现可修改的列表，程序员必须另外覆盖set (int, E)方法 (否则将抛出一个UnsupportedoperationException)。如果列表是可变大小， 则程序员必须另外覆盖add (int, E)和remove (int)方法。</li></ol><h2 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table><thead><tr><th>Constructor</th><th>Constructor描述</th></tr></thead><tbody><tr><td>ArrayList()</td><td>构造一个初始容量为十的空列表。</td></tr><tr><td>ArrayList(int initialCapacity)</td><td>构造具有指定初始容量的空列表。</td></tr><tr><td>ArrayList(Collection&lt;? extends E&gt; c)</td><td>构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回 的顺序。</td></tr></tbody></table><blockquote><p>在源码分析时首先会将涉及的变量、方法等列出来，之后一块进行详细分析！</p></blockquote><h4 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//默认空容量的数组,长度为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合真正存储数据的容器</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//空参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br></pre></td></tr></table></figure><h4 id="有参构造方法一"><a href="#有参构造方法一" class="headerlink" title="有参构造方法一"></a>有参构造方法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定容量的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断容量是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//根据构造方法的参数创建指定长度的数据</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等于0则将空数组的地址赋值给elementData</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//以上两个条件都不满足报错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有参构造方法二"><a href="#有参构造方法二" class="headerlink" title="有参构造方法二"></a>有参构造方法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//长度为0的空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合存元素的数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将集合构造中的集合对象转成数组,且将数组的地址赋值给elementData</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">// 将elementData的长度赋值给集合长度size,且判断是否不等于 0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断elementData 和 Object[] 是否为不一样的类型</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//如果不一样,使用Arrays的copyOf方法进行元素的拷贝</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 就把空数组的地址赋值给集合存元素的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将集合转数组的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="comment">//调用数组工具类的方法</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="comment">//再次调用方法进行拷贝</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="comment">//不管三元运算符的结果如何,都会创建一个新的数组</span></span><br><span class="line">        <span class="comment">//新数组的长度一定是和集合的size一样</span></span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">            ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        <span class="comment">//数组的拷贝</span></span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">       <span class="comment">//返回拷贝元素成功后的数组</span></span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>public boolean add(E e)</td><td>将指定的元素追加到此列表的末尾。</td></tr><tr><td>public void add(int index, E element)</td><td>在此列表中的指定位置插入指定的元素。</td></tr><tr><td>public boolean addAll(Collection&lt;? extends E&gt; c)</td><td>按指定集合的Iterator返回的顺序将指定集合中的所有元素 追加到此列表的末尾。</td></tr><tr><td>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</td><td>将指定集合中的所有元素插入到此列表中，从指定的位置 开始。</td></tr></tbody></table><ul><li><p>public boolean add(E e) 添加单个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;程序员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//长度为0的空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认容量为空的数组（无参构造调用）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合真实存元素的数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将添加的数据传入给 e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法对内部容量进行校验</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">//minCapacity=1</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断集合存数据的数组是否等于空容量的数组（无参构造肯定两者相等）</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//通过最小容量和默认容量 求出较大值 (用于第一次扩容)</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<span class="comment">//minCapacity=10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将if中计算出来的容量传递给下一个方法,继续校验</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实际修改集合次数++ (在扩容的过程中没用,主要是用于迭代器中)</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//判断最小容量 - 数组长度是否大于 0</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//将第一次计算出来的容量传递给 核心扩容方法(grow)</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录数组的实际长度,此时由于木有存储元素,长度为0</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// &gt;&gt; : 右移,右移几位就相当于除以2的几次幂</span></span><br><span class="line">        <span class="comment">// &lt;&lt; : 左移,左移几位就相当于乘以2的几次幂</span></span><br><span class="line">        <span class="comment">//扩容的核心算法: 原容量的1.5倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//判断新容量 - 最小容量 是否小于 0, 如果是第一次调用add方法必然小于0</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//还是将最小容量赋值给新容量</span></span><br><span class="line">            newCapacity = minCapacity; <span class="comment">//newCapacity=10</span></span><br><span class="line">        <span class="comment">//判断新容量-最大数组大小 是否&gt;0,如果条件满足就计算出一个超大容量</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        <span class="comment">// 调用数组工具类方法,创建一个新数组,将新数组的地址赋值给elementData</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>public void add(int index, E element) 在指定索引处添加元素 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智大学&quot;</span>);</span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;长沙校区&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//长度为0的空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认容量为空的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合存元素的数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//添加范围检查</span></span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">//调用方法检验是否要扩容,且让增量++</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//超出指定范围就报错</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//增量++ (也就是实际修改集合的次数)</span></span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只有容量不够的情况下才会调用 核心扩容的grow方法</span></span><br><span class="line">        <span class="comment">//如果再调用 add(index,element) 方法之前已经扩容,那么源码跟踪到此结束</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210525095343406.png" alt="image-20210525095343406" style="zoom:80%;" /></li><li><p>public boolean addAll(Collection&lt;? extends E&gt; c)将集合的所有元素一次性添加到集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智大学&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.addAll(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//长度为0的空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认容量为空的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合存元素的数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把有数据的集合转成数组</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">//有数据集合长度赋值给numNew</span></span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="comment">//调用方法检验是否要扩容,且让增量++</span></span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        <span class="comment">//调用方法将a数组的元素拷贝到elementData数组中</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        <span class="comment">//集合的长度+=a数组的长度</span></span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="comment">//只要a数组的长度不等于0,即说明添加成功</span></span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//结论:底层使用了System.arraycopy方法进行了拷贝</span></span><br></pre></td></tr></table></figure></li><li><p>public boolean addAll(int index, Collection&lt;? extends E&gt; c) 在指定的索引位置添加集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智大学&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;酷丁鱼&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;博学谷&quot;</span>)</span><br><span class="line">        list1.addAll(l1,ist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//长度为0的空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认容量为空的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合存元素的数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//校验索引</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">//将数据源转成数组</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">//记录数据源的长度 3</span></span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="comment">//目的就是为了给集合存储数据的数组进行扩容</span></span><br><span class="line">        ensureCapacityInternal(size + numNew);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//numMoved: 要移动元素的个数 --&gt; 1个</span></span><br><span class="line">        <span class="comment">//numMoved: 集合list1的长度-调用addAll的第一个参数 (索引1)</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="comment">//判断需要移动的个数是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//先使用System中的方法arraycopy将需要移动的数据进行移动</span></span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line">        <span class="comment">//将数据源(list)中的所有数据添加到list1中（中间空的位置中）</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*参数:</span></span><br><span class="line"><span class="comment">            src - 源数组。</span></span><br><span class="line"><span class="comment">            srcPos - 源数组中的起始位置。</span></span><br><span class="line"><span class="comment">            dest - 目标数组。</span></span><br><span class="line"><span class="comment">            destPos - 目的地数据中的起始位置。</span></span><br><span class="line"><span class="comment">            length - 要复制的数组元素的数量。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,<span class="keyword">int</span> srcPos,Object dest,<span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>如何计算元素移动的位置&amp;数量：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayCopyMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] a = &#123;<span class="string">&quot;黑马程序员&quot;</span>,<span class="string">&quot;传智播客&quot;</span>,<span class="string">&quot;传智大学&quot;</span>&#125;;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;酷丁鱼&quot;</span>,<span class="string">&quot;博学谷&quot;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>&#125;;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//获取数据源的长度 3</span></span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//numMoved = 集合真实长度 - 要存的索引位置</span></span><br><span class="line">        <span class="comment">//要移动元素的个数为:1</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断是否需要移动元素</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//src - 源数组。</span></span><br><span class="line">            <span class="comment">//srcPos - 源数组中的起始位置。</span></span><br><span class="line">            <span class="comment">//dest - 目标数组。</span></span><br><span class="line">            <span class="comment">//destPos - 目的地数据中的起始位置。</span></span><br><span class="line">            <span class="comment">//length - 要复制的数组元素的数量</span></span><br><span class="line">            System.arraycopy(arr, <span class="number">1</span>, arr, <span class="number">4</span>,</span><br><span class="line">                    numMoved);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[酷丁鱼, 博学谷, <span class="keyword">null</span>, <span class="keyword">null</span>, 博学谷, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><ul><li><p>public E remove(int index) 根据索引删除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">     <span class="comment">//根据索引删除元素</span></span><br><span class="line">     String value = list.remove(<span class="number">3</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;删除的元素为: &quot;</span>+value);</span><br><span class="line">     System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除的元素为: 西门大人</span><br><span class="line">集合的元素: [山东大李逵, 天魁星宋江, 天罡星卢俊义]</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//范围校验</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"><span class="comment">//增量++</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">//将index对应的元素赋值给 oldValue</span></span><br><span class="line">E oldValue = elementData(index);</span><br><span class="line"><span class="comment">//计算集合需要移动元素个数</span></span><br><span class="line"><span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果需要移动元素个数大于0,就使用arrayCopy方法进行拷贝</span></span><br><span class="line"><span class="comment">//注意:数据源和数据目的都ntData</span></span><br><span class="line"><span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">numMoved);</span><br><span class="line"><span class="comment">//将源集合最后一个元素置为null,尽早让垃圾回收机制对其进行回收</span></span><br><span class="line">elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//返回被删除的元素</span></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>public boolean remove(Object o) 根据元素删除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line"><span class="comment">//根据索引删除元素效果</span></span><br><span class="line"><span class="keyword">boolean</span> flag = list.remove(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是否删除成功: &quot;</span>+flag);</span><br><span class="line">System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是否删除成功: <span class="keyword">true</span></span><br><span class="line">集合的元素: [山东大李逵, 天魁星宋江, 天罡星卢俊义]</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断要删除的元素是否为null</span></span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line"><span class="comment">//判断集合的元素是否为null</span></span><br><span class="line"><span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果相等,调用fastRemove方法快速删除</span></span><br><span class="line">fastRemove(index);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line"><span class="comment">//用o对象的equals方法和集合每一个元素进行比较</span></span><br><span class="line"><span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line"><span class="comment">//如果相等,调用fastRemove方法快速删除</span></span><br><span class="line">fastRemove(index);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果集合没有o该元素,那么就会返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="number">3.5</span> 修改方法</span><br><span class="line"><span class="comment">//增量++</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">//计算集合需要移动元素的个数</span></span><br><span class="line"><span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果需要移动的个数大于0,调用arrayCopy方法进行拷贝</span></span><br><span class="line"><span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,numMoved);</span><br><span class="line"><span class="comment">//将集合最后一个元素置为null,尽早被释放</span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><ul><li><p>public E set(int index, E element) 根据索引修改集合元素源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//校验索引</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">//根据索引取出元素 --&gt; 被替换的元素</span></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        <span class="comment">//把element存入到elementData数组中</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回被替换的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><ul><li><p>public E get(int index) 根据索引获取元素源码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//校验索引</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">//根据索引获取数组(集合)中的元素</span></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><ul><li><p>ArrayList中的toString方法继承于它的爷爷类AbstractCollection，继承关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210525144352412.png" alt="image-20210525144352412"></p></li><li><p>public String toString() 把集合所有数据转换成字符串源码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//长度为0的空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//默认容量为空的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//集合存元素的数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//默认的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//ArrayList集合的亲爷爷类</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="comment">//判断迭代器是否有元素</span></span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="comment">//创建StringBuilder</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//先追加了&#x27;[&#x27;</span></span><br><span class="line">        sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="comment">//无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//调用迭代器的next方法取出元素,且将光标向下移动</span></span><br><span class="line">            E e = it.next();</span><br><span class="line">            <span class="comment">//三元判断</span></span><br><span class="line">            sb.append(e == <span class="keyword">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);<span class="comment">//拼接元素</span></span><br><span class="line">            <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">                <span class="comment">//没有元素,在缓冲区的最后追加&#x27;]&#x27;,且把整个缓冲区的数据转成字符串</span></span><br><span class="line">                <span class="comment">//然后再结束该方法</span></span><br><span class="line">                <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有元素,就直接追加</span></span><br><span class="line">            sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li><p>public Iterator<E> iterator() 普通迭代器源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//长度为0的空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认容量为空的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合存元素的数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取迭代器的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建了一个对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList集合的内部类 --&gt; 迭代器的源码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// 光标,默认值就是0,用来指向元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 记录-1</span></span><br><span class="line">        <span class="comment">// 将集合实际修改次数赋值给预期修改次数，用来判断并发安全性</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断集合是否有元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//即光标不等于size时，证明集合还有元素没有遍历完，而光标等于size时，说明元素遍历完毕。</span></span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">//光标（0）赋值给i</span></span><br><span class="line">            <span class="keyword">int</span> i = cursor; <span class="comment">//i=0</span></span><br><span class="line">            <span class="comment">//判断,如果大于集合的size就说明没有元素了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="comment">//把集合存储数据数组的地址赋值给该方法的局部变量</span></span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="comment">//进行判断,如果条件满足就会产生并发修改异常</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="comment">//光标自增</span></span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//从数组中取出元素且返回</span></span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验预期修改集合次数是否和实际修改集合次数一样</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>案例：已知集合：List list = new ArrayList();里面有三个元素：”hello”、”Java”、”PHP”，使用迭代器遍历集合看有没有”PHP”这个元素，如果有，就使用集合对象删除该元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">String s = it.next();</span><br><span class="line"><span class="keyword">if</span>(s.equals(<span class="string">&quot;PHP&quot;</span>)) &#123;</span><br><span class="line">list.remove(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台结果：<strong>并发修改异常</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException at</span><br><span class="line">java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">901</span>) at</span><br><span class="line">java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">851</span>) at cn.heu.method.Test01.main(Test01.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//ArrayList内部类</span></span><br><span class="line"><span class="comment">//一定要注意观察 Itr 类中的几个成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cursor; <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line"><span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 最后一个返回元素的索引</span></span><br><span class="line"><span class="comment">//将实际修改集合次数 赋值 给预期修改次数</span></span><br><span class="line"><span class="comment">//在迭代的过程中,只要实际修改次数和预期修改次数不一致就会产生并发修改异常</span></span><br><span class="line"><span class="comment">//由于expectedModCount是Itr的成员变量,那么只会被赋值一次!!!</span></span><br><span class="line"><span class="comment">//同时由于集合调用了三次add方法,那么实际修改集合次数就是 3,因此expectedModCount的值也是 3</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"><span class="comment">//判断集合元素为后面是否还有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//每次获取元素,会先调用该方法校验 预期修改次数是否 == 实际修改次数</span></span><br><span class="line">checkForComodification();</span><br><span class="line"><span class="comment">//把下一个元素的索引赋值给i</span></span><br><span class="line"><span class="keyword">int</span> i = cursor;</span><br><span class="line"><span class="comment">//判断是否有元素</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= size)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"><span class="comment">//将集合底层存储数据的数组赋值给迭代器的局部变量 elementData</span></span><br><span class="line">Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line"><span class="comment">//再次判断,如果下一个元素的索引大于集合底层存储元素的长度 并发修改异常</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"><span class="comment">//每次成功获取到元素,下一个元素的索引都是当前索引+1</span></span><br><span class="line">cursor = i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//返回元素</span></span><br><span class="line"><span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果预期修改次数 和 实际修改次数不相等 就产生并发修改异常</span></span><br><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//集合的remove方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line"><span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line"><span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">fastRemove(index);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//快速删除方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//最最最关键的一个操作,集合实际修改次数++,那么这个时候由原来的3变成4</span></span><br><span class="line"><span class="comment">//but迭代器的预期修改次数还是3!!!</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line"><span class="comment">//还有一个很关键的操作,集合的长度也发生了改变</span></span><br><span class="line">elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例二：已知集合：List list = new ArrayList();里面有三个元素：”hello”、”PHP”、”JavaSE”，使用迭代器遍历集合看有没有”PHP”这个元素，如果有，就使用集合对象删除该元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">String s = it.next();</span><br><span class="line"><span class="keyword">if</span>(s.equals(<span class="string">&quot;PHP&quot;</span>)) &#123;</span><br><span class="line">list.remove(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hello,Java]</span><br></pre></td></tr></table></figure><p>问题：使用迭代器遍历集合的时候，集合自身修改了长度，但是却没有产生并发修改异常！为什么？</p><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210526092755956.png" alt="image-20210526092755956"></p></li><li><p>default void remove() 迭代器中的remove方法，删除集合中的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//ArrayList内部类</span></span><br><span class="line"><span class="comment">//一定要注意观察 Itr 类中的几个成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cursor; <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line"><span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 最后一个返回元素的索引</span></span><br><span class="line"><span class="comment">//将实际修改集合次数 赋值 给预期修改次数</span></span><br><span class="line"><span class="comment">//在迭代的过程中,只要实际修改次数和预期修改次数不一致就会产生并发修改异常</span></span><br><span class="line"><span class="comment">//由于expectedModCount是Itr的成员变量,那么只会被赋值一次!!!</span></span><br><span class="line"><span class="comment">//同时由于集合调用了三次add方法,那么实际修改集合次数就是 3,因此expectedModCount的值也是 3</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"><span class="comment">//判断集合元素为后面是否还有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器删除元素方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断最后返回元素的索引是否小于0,满足条件就产生 非法状态异常</span></span><br><span class="line"><span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"><span class="comment">//校验是否会产生并发修改异常,第一次调用不会,因为与其修改次数和实际修改次数一致</span></span><br><span class="line">checkForComodification();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//真正删除集合元素的方法,调用方法为ArrayList的方法remove,且将0作为参数进行传递</span></span><br><span class="line">ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line"><span class="comment">//将lastRet赋值给cursor</span></span><br><span class="line">cursor = lastRet;</span><br><span class="line"><span class="comment">//再次等于-1</span></span><br><span class="line">lastRet = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//再次将集合实际修改次数赋值给预期修改次数,那么这个时候不管集合自身是否删除成功</span></span><br><span class="line"><span class="comment">//那么实际修改次数和预期修改次数又一致了,所以并不会产生并发修改异常</span></span><br><span class="line">expectedModCount = modCount;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果预期修改次数 和 实际修改次数不相等 就产生并发修改异常</span></span><br><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><ol><li>迭代器remove方法底层调用的还是集合自身的remove方法删除元素；</li><li>之所以不会产生并发修改异常，其原因是因为在迭代器的remove方法中会再次将集合实际修改次数赋值给预期修改次数  。</li></ol></li></ul><h3 id="清空方法"><a href="#清空方法" class="headerlink" title="清空方法"></a>清空方法</h3><ul><li><p>public void clear() 清空集合所有数据源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//实际修改集合次数++</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">//遍历集合,将集合每一个索引对应位置上的元素都置为null,尽早让其释放</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//集合长度更改为0</span></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="包含方法"><a href="#包含方法" class="headerlink" title="包含方法"></a>包含方法</h3><ul><li><p>public boolean contains(Object o) 判断集合是否包含指定元素源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//源码contains方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用indexOf方法进行查找</span></span><br><span class="line"><span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果元素是null,也进行遍历操作</span></span><br><span class="line"><span class="comment">//因为集合中有可能够会存储null</span></span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"><span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"><span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有走if,也没有走else,那么就说明o该元素在集合中不存在</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空"></a>判断集合是否为空</h3><ul><li><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="ArrayList是如何扩容的？"><a href="#ArrayList是如何扩容的？" class="headerlink" title="ArrayList是如何扩容的？"></a>ArrayList是如何扩容的？</h3><p>见上面的构造方法，简单说就是：第一次扩容10，以后每次都是原容量的1.5倍。</p><h3 id="ArrayList频繁扩容导致添加性能急剧下降，如何处理？"><a href="#ArrayList频繁扩容导致添加性能急剧下降，如何处理？" class="headerlink" title="ArrayList频繁扩容导致添加性能急剧下降，如何处理？"></a>ArrayList频繁扩容导致添加性能急剧下降，如何处理？</h3><p>解决方法：直接指定一个大容量的集合。但这种优化方式只针对特定的场景，如果添加的元素是少量的、未知的，不推荐使用  。</p><h3 id="ArrayList插入或删除元素一定比LinkedList慢么"><a href="#ArrayList插入或删除元素一定比LinkedList慢么" class="headerlink" title="ArrayList插入或删除元素一定比LinkedList慢么?"></a>ArrayList插入或删除元素一定比LinkedList慢么?</h3><ul><li><p>根据索引删除 ：ArrayList和LinkedList对比 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建ArrayList集合对象</span></span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加500W个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000</span>; i++) &#123;</span><br><span class="line">            arrayList.add(i+<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//根据索引删除ArrayList集合元素</span></span><br><span class="line">        <span class="comment">//删除索引5000对应的元素</span></span><br><span class="line">        String value = arrayList.remove(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//获取结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;ArrayList集合删除元素的时间: &quot;</span>+(endTime-startTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建LinkedList集合对象</span></span><br><span class="line">        LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加500W个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000</span>; i++) &#123;</span><br><span class="line">            linkedList.add(i+<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取开始时间</span></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//根据索引删除LinkedList集合元素</span></span><br><span class="line">        <span class="comment">//删除索引5000对应的元素</span></span><br><span class="line">        value = arrayList.remove(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedList集合删除元素的时间: &quot;</span>+(endTime-startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">50000</span>小黑</span><br><span class="line">ArrayList集合删除元素的时间: <span class="number">10</span></span><br><span class="line"><span class="number">50001</span>小黑</span><br><span class="line">LinkedList集合删除元素的时间: <span class="number">44</span></span><br></pre></td></tr></table></figure><p>源码分析：</p><ul><li><p>ArrayList根据索引删除元素源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//范围校验</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"><span class="comment">//增量++</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">//将index对应的元素赋值给 oldValue</span></span><br><span class="line">E oldValue = elementData(index);</span><br><span class="line"><span class="comment">//计算集合需要移动元素个数</span></span><br><span class="line"><span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果需要移动元素个数大于0,就使用arrayCopy方法进行拷贝</span></span><br><span class="line"><span class="comment">//注意:数据源和数据目的都ntData</span></span><br><span class="line"><span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">numMoved);</span><br><span class="line"><span class="comment">//将源集合最后一个元素置为null,尽早让垃圾回收机制对其进行回收</span></span><br><span class="line">elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//返回被删除的元素</span></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LinkedList根据索引删除元素源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LinkedList集合删除的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法校验元素的索引</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="comment">//先调用node(index)方法,找到需要删除的索引</span></span><br><span class="line">        <span class="comment">//再调用unlink方法解开链条</span></span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验索引是否在合法范围之内,不在就报错</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取要删除的元素</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不管索引是多少,在源码底层都会对整个链表上的元素进行折半的动作</span></span><br><span class="line"><span class="comment">//如果要删除元素的索引小于集合长度的一半,那么就从头节点一个个的往后找</span></span><br><span class="line"><span class="comment">//如果要删除元素的索引大于集合长度的一半,那么就从尾节点一个个的往后找</span></span><br><span class="line"><span class="comment">//(注:这个查找的效率相对于ArrayList集合来说较低)</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="comment">//从头节点开始往后找</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                <span class="comment">//获取下一个节点</span></span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="comment">//返回找到的节点</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="comment">//从最后一个位置往前找</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                <span class="comment">//获取前一个节点</span></span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="comment">//返回找到的节点</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解开链表,让前后节点相互记录地址</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取要删除的元素</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="comment">//获取被删除节点下一个节点的地址</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="comment">//获取被删除节点下一个节点的地址</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果被删除节点的上一个节点为null,就让被删除节点的下一个节点成为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则,被删除元素上一个节点的 下一个节点 变成 被删除元素的下一个节点</span></span><br><span class="line">            prev.next = next;</span><br><span class="line">            <span class="comment">//被删除元素的上一个节点置为null,即断开删除元素与上一个元素的链条</span></span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果被删除元素的下一个节点为null,最后一个节点就等于被删除元素的上一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则,被删除节点的下一个节点 等于被删除节点的前一个节点</span></span><br><span class="line">            next.prev = prev;</span><br><span class="line">            <span class="comment">//被删除元素的下一个节点置为null,即断开删除元素与后面元素的链条</span></span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被删除元素的内容置为null</span></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//集合长度--</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">//实际修改集合的次数自增</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//返回被删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><ol><li><p>数组删除元素确实要比链表慢，慢在需要创建新数组，还有比较麻烦的数据拷贝，但是在ArrayList底层不是每次操作元素都需要扩容，因此在这个方面相对于链表来说数组的性能更好。</p></li><li><p>LinkedList删除元素之所以效率并不高，其原理在于底层先需要对整个集合进行折半的动作，然后又需要对集合进行遍历一次，这些操作导致效率变低  。</p></li></ol></li></ul></li><li><p>根据元素删除：ArrayList和LinkedList对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ArrayList集合对象</span></span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加500W个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000</span>; i++) &#123;</span><br><span class="line">            arrayList.add(i+<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line">        &#125; <span class="comment">//获取开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//根据元素删除ArrayList集合元素</span></span><br><span class="line">        <span class="comment">//删除元素为 &quot;5000XXX&quot;</span></span><br><span class="line">        <span class="keyword">boolean</span> b = arrayList.remove(<span class="string">&quot;5000XXX&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除的状态: &quot;</span>+b);</span><br><span class="line">        <span class="comment">//获取结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;ArrayList集合删除元素的时间: &quot;</span>+(endTime-startTime));</span><br><span class="line">        <span class="comment">//创建LinkedList集合对象</span></span><br><span class="line">        LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加500W个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000</span>; i++) &#123;</span><br><span class="line">            linkedList.add(i+<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取开始时间</span></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//根据元素删除LinkedList集合元素</span></span><br><span class="line">        <span class="comment">//删除元素为 &quot;5000XXX&quot;</span></span><br><span class="line">        b = linkedList.remove(<span class="string">&quot;5000XXX&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除的状态: &quot;</span>+b);</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedList集合删除元素的时间: &quot;</span>+(endTime-startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除的状态: <span class="keyword">true</span></span><br><span class="line">ArrayList集合删除元素的时间: <span class="number">10</span></span><br><span class="line">删除的状态: <span class="keyword">true</span></span><br><span class="line">LinkedList集合删除元素的时间: <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li><p>ArrayList根据元素删除元素的源码见上面解析！</p></li><li><p>LinkedList根据元素删除元素 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断要删除的元素是否为null</span></span><br><span class="line">        <span class="comment">//不管是否为null都从第一个元素开始,从头部往后找</span></span><br><span class="line"><span class="comment">//找到之后,调用unlink方法进行解绑,更改节点和节点之间记录的地址</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="ArrayList是线程安全的么？"><a href="#ArrayList是线程安全的么？" class="headerlink" title="ArrayList是线程安全的么？"></a>ArrayList是线程安全的么？</h3><ul><li>ArrayList不是线程安全的。</li><li>需要线程安全怎么办?  <ul><li>使用Collections.synchronizedList(list)  </li><li>使用Vector</li></ul></li></ul><h3 id="如何复制某个ArrayList到另一个ArrayList中去？"><a href="#如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="如何复制某个ArrayList到另一个ArrayList中去？"></a>如何复制某个ArrayList到另一个ArrayList中去？</h3><ul><li>使用clone()方法</li><li>使用ArrayList构造方法</li><li>使用addAll方法  </li></ul><h3 id="已知成员变量集合存储N多用户名称-在多线程的环境下-使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？"><a href="#已知成员变量集合存储N多用户名称-在多线程的环境下-使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？" class="headerlink" title="已知成员变量集合存储N多用户名称,在多线程的环境下,使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？"></a>已知成员变量集合存储N多用户名称,在多线程的环境下,使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？</h3><ul><li><p>使用读写分离集合（CopyOnWriteArrayList  ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//private static ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Lucy&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Jimmy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">            <span class="comment">//在读取数据的同时又向集合写入数据</span></span><br><span class="line">            list.add(<span class="string">&quot;coco&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地方法接口与本地方法栈</title>
      <link href="2020/12/17/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
      <url>2020/12/17/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><img src="https://img-blog.csdnimg.cn/20210311111042215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /> - 简单地讲，一个 Native Method 是一个 Java 调用非 Java 代码的接囗。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C 。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++ 中，你可以用 extern "c"  告知 c++ 编译器去调用一个 c 的函数。 - "A native method is a Java method whose implementation is provided by non-java code."（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）。 - 在定义一个 native method 时，并不提供实现体（有些像定义一个 Java interface ），因为其实现体是由非 java 语言在外面实现的。 - 本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++ 程序。<p>代码举例说明 Native 方法是如何编写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IhaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Natives</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>需要注意的是：标识符 native 可以与其它 java 标识符连用，但是 abstract 除外。</code></pre><p>为什么使用 Native Method ？</p><ol><li>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</li><li>与Java环境的交互 ，有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。可以想想 Java 需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。</li><li>与操作系统的交互，JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 c 写的。还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li><li>Sun’s Java，Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setpriority（）方法是用 Java 实现的，但是它实现调用的是该类里的本地方法 setpriorityo（）。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 Windows 95 的平台上，这个本地方法最终将调用 Win32 setpriority（）Api 。一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVM 调用。</li></ol><p><strong>现状</strong></p><ul><li>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul><li>Java 虚拟机栈于管理Java 方法的调用，而本地方法栈用于管理本地方法的调用。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</li><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个outofMemoryError 异常。</li><li>本地方法是使用C语言实现的。</li><li>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210311111027982.png" style="zoom:80%;" /><ul><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存。</li><li>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</li><li>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地方法接口 </tag>
            
            <tag> 本地方法栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区</title>
      <link href="2020/12/12/%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
      <url>2020/12/12/%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="方法区概述"><a href="#方法区概述" class="headerlink" title="方法区概述"></a>方法区概述</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>方法区是运行时数据区的最后一个部分。<br><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210301200808967.png" style="zoom:80%;" /><br>从线程共享与否的角度来看：</p><img src="https://img-blog.csdnimg.cn/20210301200953571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /><p> <strong>栈、堆、方法区的交互关系</strong></p><img src="https://img-blog.csdnimg.cn/20210301201405395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /><ul><li>Person 类的 .class 信息存放在方法区中；</li><li>person 变量存放在 Java 栈的局部变量表中；</li><li>真正的 person 对象存放在 Java 堆中；</li><li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的。</li></ul><p><strong>方法区的理解</strong></p><blockquote><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p></blockquote><p><strong>方法区在哪里：</strong></p><ul><li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于 HotSpot JVM 而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>所以，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong> <strong>。</strong><img src="https://img-blog.csdnimg.cn/20210301201725842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:90%;" />方法区的基本理解：**方法区主要存放的是 Class，而堆中主要存放的是实例化的对象。**</li><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载同一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和 Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutofMemoryError:PermGen space或者java.lang.OutOfMemoryError:Metaspace 。以下几种情况会导致内存溢出错误：<ol><li>加载大量的第三方的jar包；</li><li>Tomcat部署的工程过多（30~50个）；</li><li>大量动态的生成反射类。</li></ol></li><li>关闭JVM就会释放这个区域的内存。</li></ul><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面简单的程序，加载了2000多个类！！<br><img src="https://img-blog.csdnimg.cn/20210301202639937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /></p><h3 id="HotSpot方法区演进"><a href="#HotSpot方法区演进" class="headerlink" title="HotSpot方法区演进"></a><strong>HotSpot方法区演进</strong></h3><ol><li>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8 开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类；</li><li>本质上，方法区和永久代并不等价。仅是对 Hotspot 而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit/ IBM J9 中不存在永久代的概念；</li><li>到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替；</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>；</li><li>永久代、元空间二者并不只是名字变了，内部结构也调整了；</li><li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。<img src="https://img-blog.csdnimg.cn/20210301205214296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /></li></ol><h3 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h3><p>方法区的大小不必是固定的，JVM 可以根据应用的需要动态调整。</p><p>JDK7及以前(永久代)：</p><ul><li>通过 -XX:Permsize 来设置永久代初始分配空间。默认值是20.75M；</li><li> -XX:MaxPermsize 来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M；</li><li>当JVM加载的类信息容量超过了这个值，会报异常 OutofMemoryError:PermGen space 。<br><img src="https://img-blog.csdnimg.cn/20210301205600788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li></ul><p>JDK8及以后(元空间)：</p><ul><li>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 指定。</li><li>默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize 的值是-1，即没有限制。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常 OutOfMemoryError:Metaspace。</li><li>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC 多次调用。为了避免频繁地GC，建议将 -XX:MetaspaceSize 设置为一个相对较高的值。</li></ul><h3 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a><strong>方法区OOM</strong></h3><p>代码示例：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6/7中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OOMTest test = <span class="keyword">new</span> OOMTest();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不设置元空间的上限：使用默认的 JVM 参数，元空间不设置上限。输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure><p>设置元空间的上限：参数：-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m  输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8531</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">763</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line">at com.heu.method.OOMTest.main(OOMTest.java:<span class="number">29</span>)</span><br></pre></td></tr></table></figure><p><strong>如何解决OOM?</strong></p><blockquote><p>这个属于调优的问题，这里先简单的说一下</p></blockquote><ol><li>要解决 OOM 异常或 heap space 的异常，一般的手段是首先通过内存映像分析工具（如Eclipse MemoryAnalyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）；</li><li>内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和 GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题；</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><h3 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a><strong>方法区存储什么？</strong></h3><img src="https://img-blog.csdnimg.cn/20210307152712410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom: 67%;" /><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。<br><img src="https://img-blog.csdnimg.cn/20210307152909304.png" alt="在这里插入图片描述"><br><strong>类型信息</strong></p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名=包名.类名）；</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）；</li><li>这个类型的修饰符（public，abstract，final的某个子集）；</li><li>这个类型直接接口的一个有序列表。</li></ol><p><strong>域（Field）信息</strong></p><blockquote><p>也就是我们常说的成员变量，域信息是比较官方的称呼。</p></blockquote><ol><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序；</li><li>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）。</li></ol><p><strong>方法（Method）信息</strong></p><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称；</li><li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class；</li><li>方法参数的数量和类型（按顺序）；</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）；</li><li>方法的字节码（byte codes）、操作数栈、局部变量表及大小（abstract和native方法除外）；</li><li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。</li></ol><p><strong>举例说明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 测试方法区的内部构成</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStructTest</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str = <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> cal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p MethodInnerStructTest.class &gt; test.txt</span><br></pre></td></tr></table></figure><p>反编译字节码文件，并输出值文本文件中，便于查看。参数 -p 确保能查看 private 权限类型的字段或方法。字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line">Classfile  /E:/Projects/JVM/out/production/com/heu/java/MethodInnerStructTest.class</span><br><span class="line">  Last modified <span class="number">2021</span>-<span class="number">3</span>-<span class="number">7</span>; size <span class="number">1626</span> bytes</span><br><span class="line">  MD5 checksum 0d0fcb54854d4ce183063df985141ad0</span><br><span class="line">  Compiled from <span class="string">&quot;MethodInnerStructTest.java&quot;</span></span><br><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">heu</span>.<span class="title">java</span>.<span class="title">MethodInnerStructTest</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #18.#52        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #17.#53        // com/heu/java/MethodInnerStructTest.num:I</span><br><span class="line">   #3 = Fieldref           #54.#55        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Class              #56            // java/lang/StringBuilder</span><br><span class="line">   #5 = Methodref          #4.#52         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #6 = String             #57            // count =</span><br><span class="line">   #7 = Methodref          #4.#58         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">   #8 = Methodref          #4.#59         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">   #9 = Methodref          #4.#60         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #10 = Methodref          #61.#62        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #11 = Class              #63            // java/lang/Exception</span><br><span class="line">  #12 = Methodref          #11.#64        // java/lang/Exception.printStackTrace:()V</span><br><span class="line">  #13 = Class              #65            // java/lang/String</span><br><span class="line">  #14 = Methodref          #17.#66        // com/heu/java/MethodInnerStructTest.compareTo:(Ljava/lang/String;)I</span><br><span class="line">  #15 = String             #67            // 测试方法的内部结构</span><br><span class="line">  #16 = Fieldref           #17.#68        // com/heu/java/MethodInnerStructTest.str:Ljava/lang/String;</span><br><span class="line">  #17 = Class              #69            // com/heu/java/MethodInnerStructTest</span><br><span class="line">  #18 = Class              #70            // java/lang/Object</span><br><span class="line">  #19 = Class              #71            // java/lang/Comparable</span><br><span class="line">  #20 = Class              #72            // java/io/Serializable</span><br><span class="line">  #21 = Utf8               num</span><br><span class="line">  #22 = Utf8               I</span><br><span class="line">  #23 = Utf8               str</span><br><span class="line">  #24 = Utf8               Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               &lt;init&gt;</span><br><span class="line">  #26 = Utf8               ()V</span><br><span class="line">  #27 = Utf8               Code</span><br><span class="line">  #28 = Utf8               LineNumberTable</span><br><span class="line">  #29 = Utf8               LocalVariableTable</span><br><span class="line">  #30 = Utf8               this</span><br><span class="line">  #31 = Utf8               Lcom/heu/java/MethodInnerStructTest;</span><br><span class="line">  #32 = Utf8               test1</span><br><span class="line">  #33 = Utf8               count</span><br><span class="line">  #34 = Utf8               test2</span><br><span class="line">  #35 = Utf8               (I)I</span><br><span class="line">  #36 = Utf8               value</span><br><span class="line">  #37 = Utf8               e</span><br><span class="line">  #38 = Utf8               Ljava/lang/Exception;</span><br><span class="line">  #39 = Utf8               cal</span><br><span class="line">  #40 = Utf8               result</span><br><span class="line">  #41 = Utf8               StackMapTable</span><br><span class="line">  #42 = Class              #63            // java/lang/Exception</span><br><span class="line">  #43 = Utf8               compareTo</span><br><span class="line">  #44 = Utf8               (Ljava/lang/String;)I</span><br><span class="line">  #45 = Utf8               o</span><br><span class="line">  #46 = Utf8               (Ljava/lang/Object;)I</span><br><span class="line">  #47 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #48 = Utf8               Signature</span><br><span class="line">  #49 = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">  #50 = Utf8               SourceFile</span><br><span class="line">  #51 = Utf8               MethodInnerStrucTest.java</span><br><span class="line">  #52 = NameAndType        #25:#26        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #53 = NameAndType        #21:#22        // num:I</span><br><span class="line">  #54 = Class              #73            // java/lang/System</span><br><span class="line">  #55 = NameAndType        #74:#75        // out:Ljava/io/PrintStream;</span><br><span class="line">  #56 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #57 = Utf8               count =</span><br><span class="line">  #58 = NameAndType        #76:#77        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #59 = NameAndType        #76:#78        // append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #60 = NameAndType        #79:#80        // toString:()Ljava/lang/String;</span><br><span class="line">  #61 = Class              #81            // java/io/PrintStream</span><br><span class="line">  #62 = NameAndType        #82:#83        // println:(Ljava/lang/String;)V</span><br><span class="line">  #63 = Utf8               java/lang/Exception</span><br><span class="line">  #64 = NameAndType        #84:#26        // printStackTrace:()V</span><br><span class="line">  #65 = Utf8               java/lang/String</span><br><span class="line">  #66 = NameAndType        #43:#44        // compareTo:(Ljava/lang/String;)I</span><br><span class="line">  #67 = Utf8               测试方法的内部结构</span><br><span class="line">  #68 = NameAndType        #23:#24        // str:Ljava/lang/String;</span><br><span class="line">  #69 = Utf8               com/heu/java/MethodInnerStructTest</span><br><span class="line">  #70 = Utf8               java/lang/Object</span><br><span class="line">  #71 = Utf8               java/lang/Comparable</span><br><span class="line">  #72 = Utf8               java/io/Serializable</span><br><span class="line">  #73 = Utf8               java/lang/System</span><br><span class="line">  #74 = Utf8               out</span><br><span class="line">  #75 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #76 = Utf8               append</span><br><span class="line">  #77 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #78 = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #79 = Utf8               toString</span><br><span class="line">  #80 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #81 = Utf8               java/io/PrintStream</span><br><span class="line">  #82 = Utf8               println</span><br><span class="line">  #83 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #84 = Utf8               printStackTrace</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法信息</span></span><br><span class="line">  <span class="keyword">public</span> com.heu.java.MethodInnerStructTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         7: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/heu/java/MethodInnerStructTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/heu/java/MethodInnerStructTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">30</span></span><br><span class="line">         <span class="number">4</span>: istore_2</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iload_0</span><br><span class="line">         <span class="number">7</span>: idiv</span><br><span class="line">         <span class="number">8</span>: istore_1</span><br><span class="line">         <span class="number">9</span>: goto          <span class="number">17</span></span><br><span class="line">        <span class="number">12</span>: astore_2</span><br><span class="line">        <span class="number">13</span>: aload_2</span><br><span class="line">        14: invokevirtual #12                 // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        <span class="number">18</span>: ireturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">9</span>    <span class="number">12</span>   Class java/lang/Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">27</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">26</span>: <span class="number">13</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">5</span>       <span class="number">4</span>     <span class="number">2</span> value   I</span><br><span class="line">           <span class="number">13</span>       <span class="number">4</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">0</span>   cal   I</span><br><span class="line">            <span class="number">2</span>      <span class="number">17</span>     <span class="number">1</span> result   I</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">12</span></span><br><span class="line">          locals = [ <span class="keyword">int</span>, <span class="keyword">int</span> ]</span><br><span class="line">          stack = [ class java/lang/Exception ]</span><br><span class="line">        frame_type = <span class="number">4</span> <span class="comment">/* same */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/heu/java/MethodInnerStructTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">1</span>     o   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/Object;)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         2: checkcast     #13                 // class java/lang/String</span><br><span class="line">         5: invokevirtual #14                 // Method compareTo:(Ljava/lang/String;)I</span><br><span class="line">         <span class="number">8</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/heu/java/MethodInnerStructTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: ldc           #15                 // String 测试方法的内部结构</span><br><span class="line">         2: putstatic     #16                 // Field str:Ljava/lang/String;</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #49                          // Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型信息：在运行时方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">heu</span>.<span class="title">java</span>.<span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>域信息：</p><ol><li>descriptor：I 表示字段类型为 Integer；</li><li>flags：ACC_PUBLIC 表示字段权限修饰符为 public。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br></pre></td></tr></table></figure><p>方法信息：</p><ol><li>descriptor： ()V 表示方法返回值类型为 void；</li><li>flags：ACC_PUBLIC 表示方法权限修饰符为 public；</li><li>stack=3 表示操作数栈深度为 3；</li><li>locals=2 表示局部变量个数为 2 个（实例方法包含 this）；</li><li>test1() 方法虽然没有参数，但是其 args_size=1 ，这时因为将 this 作为了参数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/heu/java/MethodInnerStructTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br></pre></td></tr></table></figure><p><strong>non-final 类型的类（静态）变量</strong></p><ul><li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分；</li><li>类变量（静态变量）被类的所有实例共享，即使没有类实例时，也可以访问它。</li></ul><p>举例说明：</p><ol><li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常；</li><li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>全局常量：static final</strong></p><ol><li>全局常量就是使用 static final 进行修饰；</li><li>被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</li></ol><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>查看上面代码的字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p><p>总结：<br><img src="https://img-blog.csdnimg.cn/20210307162305856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h3><p>运行时常量池 VS 常量池</p><blockquote><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p></blockquote><img src="https://img-blog.csdnimg.cn/20210307165931350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:67%;" /><ol><li>方法区，内部包含了运行时常量池；</li><li>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多 Constant pool的东西，这个就是常量池）；</li><li>要弄清楚方法区，需要理解清楚 Class File ，因为加载类的信息都在方法区；</li><li>要弄清楚方法区的运行时常量池，需要理解清楚 Class File 中的常量池。</li></ol><p><strong>常量池</strong></p><ol><li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用；</li><li>字面量： 10 ， “我是某某” ，这种数字和字符串都是字面量。<img src="https://img-blog.csdnimg.cn/20210307170510984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom: 67%;" /></li></ol><img src="https://img-blog.csdnimg.cn/20210307170430891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom: 67%;" />为什么需要常量池？<ul><li>一个java源文件中的类、接口，编译后产生一个字节码文件，而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，因此换另一种方式，可以存到常量池。字节码包含了指向常量池的引用，在动态链接的时候会用到运行时常量池（类的加载过程中有讲）。</li></ul><p>比如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虽然上述代码很小，但是里面却使用了String、System、PrintStream及Object等结构；</li><li>这个文件中有6个地方用到了 ”hello” 这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。可以将 ”hello” 等所需用到的结构信息记录在常量池中，并通过引用的方式，来加载、调用所需的结构；</li><li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li></ul><p>常量池中有什么？</p><ol><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ol><p>上面的 MethodInnerStructTest 的 test1方法的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">20</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> 3 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"> 6 new #4 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line">10 invokespecial #5 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">13 ldc #6 &lt;count = &gt;</span><br><span class="line">15 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">18</span> iload_1</span><br><span class="line">19 invokevirtual #8 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">22 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line">25 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>#3，#5等等这些带# 的，都是引用了常量池。常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><p><strong>运行时常量池</strong></p><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分；</li><li>常量池表（Constant Pool Table）是 Class 字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。（运行时常量池就是常量池在程序运行时的称呼）；</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池；</li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的；</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。而运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性；</li><li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些；</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</li></ul><h3 id="方法区的使用举例"><a href="#方法区的使用举例" class="headerlink" title="方法区的使用举例"></a><strong>方法区的使用举例</strong></h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">heu</span>.<span class="title">java</span>.<span class="title">MethodAreaDemo</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">51</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #27.#28        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #29            // com/heu/java/MethodAreaDemo</span><br><span class="line">   #5 = Class              #30            // java/lang/Object</span><br><span class="line">   #6 = Utf8               &lt;init&gt;</span><br><span class="line">   #7 = Utf8               ()V</span><br><span class="line">   #8 = Utf8               Code</span><br><span class="line">   #9 = Utf8               LineNumberTable</span><br><span class="line">  #10 = Utf8               LocalVariableTable</span><br><span class="line">  #11 = Utf8               this</span><br><span class="line">  #12 = Utf8               Lcom/heu/java/MethodAreaDemo;</span><br><span class="line">  #13 = Utf8               main</span><br><span class="line">  #14 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #15 = Utf8               args</span><br><span class="line">  #16 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #17 = Utf8               x</span><br><span class="line">  #18 = Utf8               I</span><br><span class="line">  #19 = Utf8               y</span><br><span class="line">  #20 = Utf8               a</span><br><span class="line">  #21 = Utf8               b</span><br><span class="line">  #22 = Utf8               SourceFile</span><br><span class="line">  #23 = Utf8               MethodAreaDemo.java</span><br><span class="line">  #24 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #25 = Class              #31            // java/lang/System</span><br><span class="line">  #26 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;</span><br><span class="line">  #27 = Class              #34            // java/io/PrintStream</span><br><span class="line">  #28 = NameAndType        #35:#36        // println:(I)V</span><br><span class="line">  #29 = Utf8               com/heu/java/MethodAreaDemo</span><br><span class="line">  #30 = Utf8               java/lang/Object</span><br><span class="line">  #31 = Utf8               java/lang/System</span><br><span class="line">  #32 = Utf8               out</span><br><span class="line">  #33 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #34 = Utf8               java/io/PrintStream</span><br><span class="line">  #35 = Utf8               println</span><br><span class="line">  #36 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.heu.java.MethodAreaDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/heu/java/MethodAreaDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: sipush        <span class="number">500</span></span><br><span class="line">         <span class="number">3</span>: istore_1</span><br><span class="line">         <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: iload_2</span><br><span class="line">         <span class="number">9</span>: idiv</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: bipush        <span class="number">50</span></span><br><span class="line">        <span class="number">13</span>: istore        <span class="number">4</span></span><br><span class="line">        15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">21</span>: iadd</span><br><span class="line">        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">25</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">26</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">4</span>      <span class="number">22</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">7</span>      <span class="number">19</span>     <span class="number">2</span>     y   I</span><br><span class="line">           <span class="number">11</span>      <span class="number">15</span>     <span class="number">3</span>     a   I</span><br><span class="line">           <span class="number">15</span>      <span class="number">11</span>     <span class="number">4</span>     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodAreaDemo.java&quot;</span></span><br></pre></td></tr></table></figure><p>图解字节码指令执行流程：</p><p>1、初始状态；<br><img src="https://img-blog.csdnimg.cn/20210307172226640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /></p><p>2、首先将操作数500压入操作数栈中；<br><img src="https://img-blog.csdnimg.cn/20210307172251371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /></p><p>3、然后操作数 500 从操作数栈中取出，存储到局部变量表中索引为 1 的位置；<br><img src="https://img-blog.csdnimg.cn/20210307172334372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /></p><p>4、重复一次，把100压如操作数栈中，之后放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作；<br><img src="https://img-blog.csdnimg.cn/2021030717263787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /></p><p>5、将500 和 100 进行一个除法运算，再把结果入栈；<br><img src="https://img-blog.csdnimg.cn/20210307172728433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /><br>接着50入栈出栈，并将其保存在局部变量4中；<br><img src="https://img-blog.csdnimg.cn/20210307173939961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /></p><p>6、将50和5 压入操作数栈，并执行加法操作；<br><img src="https://img-blog.csdnimg.cn/20210307174308777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /></p><img src="https://img-blog.csdnimg.cn/20210307174227289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /><img src="https://img-blog.csdnimg.cn/20210307172840415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" />7、最后调用 invokevirtual（虚方法调用），进行打印，然后返回。<img src="https://img-blog.csdnimg.cn/20210307172921240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" />返回时：<img src="https://img-blog.csdnimg.cn/2021030717312587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" />程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录方法调用后能够正常返回，或者是进行了 CPU 切换后，也能回来到原来的代码进行执行。<p>符号引用 –&gt; 直接引用</p><ol><li>上面代码调用 System.out.println()  方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载；</li><li>如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）。</li></ol><h2 id="方法区演进细节与垃圾回收"><a href="#方法区演进细节与垃圾回收" class="headerlink" title="方法区演进细节与垃圾回收"></a>方法区演进细节与垃圾回收</h2><h3 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a><strong>方法区演进细节</strong></h3><p><strong>永久代演进过程：</strong></p><ol><li>首先明确：只有 Hotspot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</li><li>Hotspot 中方法区的变化如下图：<br><img src="https://img-blog.csdnimg.cn/2021030820204968.png"></li></ol><p><strong>JDK6 ：方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存)。</strong><br><img src="https://img-blog.csdnimg.cn/20210308203103599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom: 67%;" /><br><strong>JDK7 ：方法区由永久代实现，使用 JVM 虚拟机内存。</strong><br><img src="https://img-blog.csdnimg.cn/20210308203031873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom: 70%;" /><br><strong>JDK8 ：方法区由元空间实现，使用物理机本地内存。</strong><br><img src="https://img-blog.csdnimg.cn/20210308202735504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom: 80%;" /></p><p><strong>永久代为什么要被元空间替代？</strong></p><blockquote><p>官方文档：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p></blockquote><ol><li>随着 Java8 的到来，HotSpot VM 中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了，这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</li><li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li><li>这项改动是很有必要的，原因有：<ol><li>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM 。比如某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。如：Exception in thread ‘dubbo client x.x connector’ java.lang .OutOfMemoryError:PermGen space，而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低 Full GC。</li></ol></li></ol><p><strong>字符串常量池</strong></p><p>字符串常量池 StringTable 为什么要调整位置？</p><p>JDK7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 Full GC 的时候才会执行永久代的垃圾回收，而 Full GC 是老年代的空间不足、永久代不足时才会触发，这就导致StringTable回收效率不高，而开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足，放到堆里，能及时回收内存。</p><p><strong>静态变量放在哪里</strong></p><p>对象实体在哪里放着？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 1、静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])始终都存在堆空间，</span></span><br><span class="line"><span class="comment"> * 2、只是那个变量(相当于下面的arr变量名)在 JDK6,JDK7,JDK8 存放位置中有所变化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK6 环境下：</p><img src="https://img-blog.csdnimg.cn/20210308205510512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /><p>JDK7 环境下：</p><p><img src="https://img-blog.csdnimg.cn/20210308205453393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" />JDK8 环境下：</p><img src="https://img-blog.csdnimg.cn/20210308205618417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /><p>变量(名)存放在哪里？用JHSDB工具来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> StaticObjTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDK6 环境下：</p><ol><li><p>staticObj 随着 Test 的类型信息存放在方法区；</p></li><li><p>instanceObj 随着 Test 的对象实例存放在Java堆；</p></li><li><p>localObject （局部变量）则是存放在 foo() 方法栈帧的局部变量表中；</p></li><li><p>测试发现：三个对象的数据在内存中的地址都落在 Eden 区范围内，所以结论：只要是对象实例必然会在Java堆中分配。<br><img src="https://img-blog.csdnimg.cn/20210308210129274.png"></p></li></ol><blockquote><ol><li>0x00007f32c7800000(Eden区的起始地址) —- 0x00007f32c7b50000(Eden区的终止地址)，</li><li>可以发现三个变量都在这个范围内，</li><li>所以可以得到上面结论。</li></ol></blockquote><ol start="5"><li>接着，找到了一个引用该 staticObj 对象的地方，是在一个 java.lang.Class 的实例里，并且给出了这个实例的地址，通过 Inspector 查看该对象实例，可以清楚看到这确实是一个 java.lang.Class 类型的对象实例，里面有一个名为 staticobj 的实例字段：<br><img src="https://img-blog.csdnimg.cn/20210308210305159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li></ol><ul><li>从《Java虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7 及其以后版本的 HotSpot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 Class 对象存放在一起，存储于 Java 堆之中，从实验中也明确验证了这一点。</li></ul><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a><strong>方法区的垃圾回收</strong></h3><ol><li><p>有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的ZGC 收集器就不支持类卸载）。</p></li><li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。</p></li><li><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><ol><li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p></li><li><p>回收废弃常量与回收 Java 堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p></li></ol></li></ol><p>方法区的类卸载：</p><ol><li><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例；</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP 的重加载等，否则通常是很难达成的；</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li><li><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了”-Xnoclassgc “参数进行控制，还可以使用 -verbose:class 以及 -XX：+TraceClass-Loading、-XX： +TraceClassUnLoading 查看类加载和卸载信息。</p></li><li><p>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p></li></ol><h3 id="运行时数据区总结"><a href="#运行时数据区总结" class="headerlink" title="运行时数据区总结"></a><strong>运行时数据区总结</strong></h3><img src="https://img-blog.csdnimg.cn/20210308211337629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom: 67%;" /><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a><strong>常见面试题</strong></h2><ol><li><p>百度</p><ul><li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li></ul></li><li><p>蚂蚁金服：</p><ul><li>Java8的内存分代改进</li><li>JVM内存分哪几个区，每个区的作用是什么？</li><li>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li><li>二面：Eden和survior的比例分配。</li></ul></li><li><p>小米：</p><ul><li>jvm内存分区，为什么要有新生代和老年代？</li></ul></li><li><p>字节跳动：</p><ul><li>二面：Java的内存分区</li><li>二面：讲讲jvm运行时数据库区。</li><li>什么时候对象会进入老年代？</li></ul></li><li><p>京东：</p><ul><li>JVM的内存结构，Eden和Survivor比例。</li><li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li></ul></li><li><p>天猫：</p><ul><li>一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li><li>一面：JVM的内存模型，Java8做了什么改变？</li></ul></li><li><p>拼多多：</p><ul><li>JVM内存分哪几个区，每个区的作用是什么？</li></ul></li><li><p>美团：</p><ul><li>java内存分配</li><li>jvm的永久代中会发生垃圾回收吗？</li><li>一面：jvm内存分区，为什么要有新生代和老年代？</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内部结构 </tag>
            
            <tag> 演变细节 </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="2020/12/06/%E5%A0%86/"/>
      <url>2020/12/06/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="堆的基本概述"><a href="#堆的基本概述" class="headerlink" title="堆的基本概述"></a>堆的基本概述</h2><h3 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h3><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）。</p><p>但从实际使用角度看，“几乎”所有的对象实例都在这里分配内存。因为还有一些对象是在栈上分配的，而数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><ul><li>堆针对一个JVM进程来说是唯一的，也就是说一个进程对应着一个JVM实例，但是进程包含多个线程，他们是共享同一堆空间的；</li><li>一个JVM实例只存在一个堆内存，堆是Java内存管理的核心区域；</li><li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，是JVM管理的最大一块内存空间；</li><li>但堆内存的大小是可以调节的；</li><li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的（可类比操作系统）；</li><li>Java堆中可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB），也就是说堆中不是所有信息都是线程共享。</li></ul><p>下面代码对于堆内存进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置堆大小：</p><ul><li>-Xms10m：最小堆内存</li><li>-Xmx10m：最大堆内存<img src="https://img-blog.csdnimg.cn/20210220204754481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /></li></ul><p>下图就是使用Java VisualVM查看堆空间的内容，通过VisualVM中的GC插件。<br><img src="https://img-blog.csdnimg.cn/20210220202525954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><p><strong>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除也就是触发了GC的时候，才会进行回收。</strong></p><p>因为如果堆中对象马上被回收，那么用户线程就会收到影响。</p><p>堆、Java栈和方法区之间联系：<br><img src="https://img-blog.csdnimg.cn/20210220182333420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /></p><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a><strong>堆内存细分</strong></h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区：</p><ul><li>Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区；</li><li>Tenure generation space 养老区 Old/Tenure；</li><li>Permanent Space永久区 Perm。</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间：</p><ul><li>Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区；</li><li>Tenure generation space 养老区 Old/Tenure；</li><li>Meta Space 元空间 Meta。</li></ul><p>约定：新生区 -&gt; 新生代 -&gt; 年轻代 、 养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代<br><img src="https://img-blog.csdnimg.cn/2021022018270499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间！！！<br><img src="https://img-blog.csdnimg.cn/20210220182427295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /><br>堆空间逻辑上包括新生代、老年代、元空间，实际上只包括新生代和老年代，元空间也叫方法区！！！</p><h3 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a><strong>设置堆内存大小与OOM</strong></h3><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize；</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize。</li><li>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</li><li>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</li></ul><p>默认情况下：</p><ol><li>初始内存大小：物理电脑内存大小/64；</li><li>最大内存大小：物理电脑内存大小/4。</li></ol><p>下面代码测试查看堆内存大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;系统内存大小为：&quot; + initialMemory * 64.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;系统内存大小为：&quot; + maxMemory * 4.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms : 246M</span><br><span class="line">-Xmx : 3934M</span><br></pre></td></tr></table></figure><p>如何查看堆内存的内存分配情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps  -&gt;  jstat -gc 进程id</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210220203658996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" />![](https://img-blog.csdnimg.cn/20210220203635951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70)**OutOfMemory举例**：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置启动参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms500m -Xmx:500m</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.heu.heap.OOMTest.main(OOMTest.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>通过 VisualVM工具查看具体内存占用：</p><p><img src="https://img-blog.csdnimg.cn/20210220204556115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br>可以看到当Used heap达到500，就会出现OOM异常。</p><h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a><strong>年轻代与老年代</strong></h3><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速，生命周期短的，及时回收即可；</li><li>另一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）。其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。<br><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/2021022018254959.png"><br>下面的堆参数开发中一般不会调：<br><img src="https://img-blog.csdnimg.cn/20210220182559941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><ul><li>Eden：From：to -&gt; 8:1:1</li><li>新生代：老年代 - &gt; 1 : 2</li></ul><p>配置新生代与老年代在堆结构的占比：</p><ul><li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3；</li><li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5；</li><li>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整老年代的大小，来进行调优；</li><li>在HotSpot虚拟机中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例，比如-xx:SurvivorRatio=8。</li></ul><p>几乎所有的Java对象都是在Eden区被new出来的，绝大部分（80%）Java对象的销毁都在新生代进行，（有些大的对象在Eden区无法存储时候，将直接进入老年代）。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小。而这个参数一般使用默认值就可以了。<br><img src="https://img-blog.csdnimg.cn/20210220182619138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><h2 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><p>下面几点说明：</p><ul><li>new的对象先放伊甸园区，此区有大小限制；</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器对伊甸园区进行垃圾回（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区；</li><li>然后将伊甸园中的剩余对象移动到幸存者0区；</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区（0区、1区互相换）；</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次；</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理；</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><p>可以设置参数（次数）：-Xx:MaxTenuringThreshold= N进行设置。</p><h3 id="对象分配图解过程"><a href="#对象分配图解过程" class="headerlink" title="对象分配图解过程"></a><strong>对象分配图解过程</strong></h3><ol><li><p>我们创建的对象，一般都是存放在Eden区的，当Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作；<br><img src="https://img-blog.csdnimg.cn/20210222205115297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p></li><li><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时给每个对象设置了一个年龄计数器，一次回收后就是1；</p></li><li><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1；<br><img src="https://img-blog.csdnimg.cn/20210222205138826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p></li><li><p>我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，即将年轻代中的对象晋升到老年代中；<br><img src="https://img-blog.csdnimg.cn/20210222205204260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><strong>幸存区区满了后？</strong></p></li></ol><ul><li>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发 MinorGC 操作；</li><li>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。</li></ul><p>  举例：以当兵为例，正常人的晋升可能是 ： 新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长。</p><p>  但是也有可能有些人因为做了非常大的贡献，直接从 新兵 -&gt; 排长。</p><p><strong>对象分配的特殊情况</strong><br><img src="https://img-blog.csdnimg.cn/20210222205419609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /><br><strong>代码演示对象分配过程</strong></p><p>示例程序：不断的创建大对象添加到 list 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapInstanceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HeapInstanceTest());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置JVM参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms600m -Xmx600m</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210222210341660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" />之后打开VisualVM工具，通过执行上面代码，通过VisualGC进行动态化查看：![](https://img-blog.csdnimg.cn/20210222210529173.gif)最终，在老年代和新生代都满了，就出现OOM。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.heu.heap.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:<span class="number">13</span>)</span><br><span class="line">at com.heu.heap.HeapInstanceTest.main(HeapInstanceTest.java:<span class="number">17</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to（s0，s1不固定）；</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不在永久代和元空间进行收集；</li><li>新生代采用复制算法的目的：是为了减少内碎片。</li></ul><h3 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a><strong>Minor GC，MajorGC、Full GC</strong></h3><ul><li>Minor GC：新生代的GC</li><li>Major GC：老年代的GC</li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><ol><li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（stop the word）的问题，而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上。</p></li><li><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对 Hotspot VM 的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）。</p></li></ol><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集。</li><li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。<pre><code>       - 目前，只有CMS GC会有单独收集老年代的行为；       - 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</code></pre></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<pre><code>       - 目前，只有G1 GC会有这种行为。</code></pre></li></ul><p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p><p><strong>Minor GC</strong></p><ul><li>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC，（每次Minor GC会清理年轻代的内存）；</li><li>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快；</li><li>Minor GC会引发STW（stop the word），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。<img src="https://img-blog.csdnimg.cn/20210222211718796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /></li></ul><p><strong>Major GC</strong></p><p>Majoy GC指发生在老年代的GC，对象从老年代消失时，就说 “Major GC” 或 “Full GC” 发生了。</p><ul><li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程），也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足，则触发Major GC；</li><li>Major GC的速度一般会比MinorGc慢10倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了。</li></ul><p><strong>Full GC</strong></p><p>触发 Full GC 执行的情况有如下五种：</p><ol><li>调用System.gc（）时，系统建议执行Full GC，但是不必然执行；</li><li>老年代空间不足；</li><li>方法区空间不足；</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存；</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小（即年轻代、老年代的内存大小装不下该对象）。</li></ol><p><strong>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些。</strong></p><p><strong>GC 举例</strong></p><p>编写一个OOM的异常，不断的创建字符串示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">&quot;mogu blog&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置JVM启动参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>打印出的日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2038K-&gt;500K(2560K)] 2038K-&gt;797K(9728K), <span class="number">0.3532002</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.36</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2108K-&gt;480K(2560K)] 2405K-&gt;1565K(9728K), <span class="number">0.0014069</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2288K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 6845K-&gt;5281<span class="title">K</span><span class="params">(7168K)</span>] 9133K-&gt;5281<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3482K-&gt;3482<span class="title">K</span><span class="params">(1056768K)</span>], 0.0058675 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5281K-&gt;5281K(9728K), <span class="number">0.0002857</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 5281K-&gt;5263<span class="title">K</span><span class="params">(7168K)</span>] 5281K-&gt;5263<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3482K-&gt;3482<span class="title">K</span><span class="params">(1056768K)</span>], 0.0058564 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 60K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 2048K, <span class="number">2</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd0f138</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 5263K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">73</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffb23cf0</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3514K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 388<span class="title">K</span>, <span class="title">capacity</span> 390<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">  </span></span><br><span class="line">  Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOfRange(Arrays.java:<span class="number">3664</span>)</span><br><span class="line">at java.lang.String.&lt;init&gt;(String.java:<span class="number">207</span>)</span><br><span class="line">at java.lang.StringBuilder.toString(StringBuilder.java:<span class="number">407</span>)</span><br><span class="line">at com.heu.heap.GCTest.main(GCTest.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2038K-&gt;500K(2560K)] 2038K-&gt;797K(9728K), <span class="number">0.3532002</span> secs] </span><br></pre></td></tr></table></figure><ul><li>[PSYoungGen: 2038K-&gt;500K(2560K)]：年轻代总空间为 2560K ，当前占用 2038K ，经过垃圾回收后剩余500K；</li><li>2038K-&gt;797K(9728K)：堆内存总空间为 9728K ，当前占用2038K ，经过垃圾回收后剩余797K。</li></ul><p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常。</p><h3 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a><strong>堆空间分代思想</strong></h3><p>为什么要把Java堆分代？不分代就不能正常工作了吗？</p><p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>新生代：有Eden、两块大小相同的survivor（又称为from/to或s0/s1）构成，to总为空。</li><li>老年代：存放新生代中经历多次GC仍然存活的对象。</li></ul><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。</p><ul><li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）</li><li>而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li></ul><h3 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a><strong>对象内存分配策略</strong></h3><ol><li>如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li><li>对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代。</li><li>对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置。</li></ol><p>针对不同年龄段的对象分配原则如下所示：</p><ol><li>优先分配到Eden：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢。</li><li>大对象直接分配到老年代：尽量避免程序中出现过多的大对象。</li><li>长期存活的对象分配到老年代。</li><li>动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li><li>空间分配担保： -XX:HandlePromotionFailure 。</li></ol><h2 id="TLAB为对象分配内存"><a href="#TLAB为对象分配内存" class="headerlink" title="TLAB为对象分配内存"></a>TLAB为对象分配内存</h2><h3 id="为什么要有-TLAB？"><a href="#为什么要有-TLAB？" class="headerlink" title="为什么要有 TLAB？"></a><strong>为什么要有 TLAB？</strong></h3><ol><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据；</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的；</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li></ol><h3 id="什么是-TLAB？"><a href="#什么是-TLAB？" class="headerlink" title="什么是 TLAB？"></a><strong>什么是 TLAB？</strong></h3><p>TLAB（Thread Local Allocation Buffer）：</p><ol><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域（栈中提到），它包含在Eden空间内；</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此可以将这种内存分配方式称之为快速分配策略；</li><li>目前所知，所有OpenJDK衍生出来的JVM都提供了TLAB的设计。<br><img src="https://img-blog.csdnimg.cn/2021022421362744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li><li>每个线程都有一个TLAB空间；</li><li>当一个线程的TLAB存满时，可以使用公共区域（蓝色）的。</li></ol><p><strong>说明</strong></p><ol><li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p></li><li><p>在程序中，开发人员可以通过选项 -XX:UseTLAB 设置是否开启TLAB空间。</p></li><li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项 -XX:TLABWasteTargetPercent 设置TLAB空间所占用Eden空间的百分比大小。</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><p><strong>注：</strong> 哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定—《深入理解JVM》第三版 。</p></li></ol><p><strong>代码演示</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-XX:UseTLAB参数是否开启的情况:默认情况是开启的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TLABArgsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我只是来打个酱油~&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>终端输入 jsp，查看TLABArgsTest进程id;</li><li>jinfo -flag UseTLAB 36732（进程id），输出-XX:+UseTLAB，证明TLAB默认是开启的.<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210815093435986.png" alt="image-20210815093435986" style="zoom: 50%;" /></li></ul><h3 id="TLAB-分配过程"><a href="#TLAB-分配过程" class="headerlink" title="TLAB 分配过程"></a><strong>TLAB 分配过程</strong></h3><p><img src="https://img-blog.csdnimg.cn/2021022421433530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="堆空间的参数设置"><a href="#堆空间的参数设置" class="headerlink" title="堆空间的参数设置"></a><strong>堆空间的参数设置</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-XX:PrintFlagsInitial: 查看所有参数的默认初始值</span><br><span class="line">-XX:PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）具体查看某个参数的指令：</span><br><span class="line">      - jps：查看当前运行中的进程;</span><br><span class="line">      - jinfo -flag SurvivorRatio 进程id： 查看新生代中Eden和S0/S1空间的比例.</span><br><span class="line">-Xms: 初始堆空间内存（默认为物理内存的<span class="number">1</span>/<span class="number">64</span>）</span><br><span class="line">-Xmx: 最大堆空间内存（默认为物理内存的<span class="number">1</span>/<span class="number">4</span>）</span><br><span class="line">-Xmn: 设置新生代大小（初始值及最大值）</span><br><span class="line">-XX:NewRatio: 配置新生代与老年代在堆结构的占比</span><br><span class="line">-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span><br><span class="line">-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄(默认<span class="number">15</span>)</span><br><span class="line">-XX:+PrintGCDetails：输出详细的GC处理日志</span><br><span class="line">        打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span><br><span class="line">-XX:HandlePromotionFailure：是否设置空间分配担保</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3><p>在发生Minor Gc之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li>如果大于，则此次Minor GC是安全的;</li><li>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true,那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<pre><code>  -  如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；-  如果小于，则改为进行一次Full GC。-  如果HandlePromotionFailure=false,则改为进行一次Full GC。</code></pre></li></ul><p>历史版本:</p><ol><li>在JDK6 Update 24 之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。</li><li>JDK6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。即 HandlePromotionFailure=true.</li></ol><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p><strong>堆是分配对象的唯一选择么？</strong></p><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><ol><li>随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li><li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li><li>此外，基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li></ol><h3 id="逃逸分析-1"><a href="#逃逸分析-1" class="headerlink" title="逃逸分析"></a><strong>逃逸分析</strong></h3><ol><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li><li>通过逃逸分析，Java Hotspot 编译器能够分析出一个新对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li> 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ol><p><strong>逃逸分析举例</strong></p><ol><li>没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="comment">//sb可以被外部方法引用</span></span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果想要StringBuffer sb不发生逃逸，可以这样写。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸，同上sb</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逃逸分析参数设置"><a href="#逃逸分析参数设置" class="headerlink" title="逃逸分析参数设置"></a><strong>逃逸分析参数设置</strong></h3><ul><li>在JDK 1.7 版本之后，HotSpot 中默认就已经开启了逃逸分析；</li><li>如果使用的是较早的版本，开发人员则可以通过：选项” -XX:+DoEscapeAnalysis“显式开启逃逸分析，通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果。</li></ul><p>开发中能使用局部变量的，就不要在方法外定义。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ol><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配。</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ol><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a><strong>栈上分配</strong></h4><ul><li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收，这样就无须进行垃圾回收了。</li><li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li></ul><p>栈上分配举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  * 栈上分配测试</span></span><br><span class="line"><span class="comment"> *  * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="https://img-blog.csdnimg.cn/20210224223039763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><ol><li>JVM 参数设置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure></li><li>日志打印：发生了 GC ，耗时 44ms。</li></ol><p>开启逃逸分析的情况，输出结果：<br><img src="https://img-blog.csdnimg.cn/20210224223402722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><ol><li>JVM 参数设置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure></li><li>日志打印：发生了 GC ，耗时 44ms。</li></ol><h4 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a><strong>同步省略（同步消除）</strong></h4><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li><li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</li><li>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码分析上面第一个程序发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/Object&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">7</span> astore_1</span><br><span class="line"> <span class="number">8</span> aload_1</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> monitorenter</span><br><span class="line">12 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">15</span> aload_1</span><br><span class="line">16 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">19</span> aload_2</span><br><span class="line"><span class="number">20</span> monitorexit</span><br><span class="line"><span class="number">21</span> goto <span class="number">29</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">24</span> astore_3</span><br><span class="line"><span class="number">25</span> aload_2</span><br><span class="line"><span class="number">26</span> monitorexit</span><br><span class="line"><span class="number">27</span> aload_3</span><br><span class="line"><span class="number">28</span> athrow</span><br><span class="line"><span class="number">29</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，同步省略操作是在解释运行时发生的！</p><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a><strong>标量替换</strong></h4><p>分离对象或标量替换：</p><ul><li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li><li>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li><li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程就是标量替换。</li></ul><p>标量替换代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li><li>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li><li>标量替换为栈上分配提供了很好的基础。</li></ol><p>标量替换参数设置：</p><p>参数 -XX:+ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><p>代码示例：</p><p>未开启标量替换：</p><ul><li>JVM 参数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span><br></pre></td></tr></table></figure></li></ul><p>2.输出：<br><img src="https://img-blog.csdnimg.cn/20210224224545413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br>开启标量替换：</p><ul><li><p>JVM 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure></li><li><p>输出：时间减少很多，且无GC。<br><img src="https://img-blog.csdnimg.cn/20210224224700954.png"><br>上述代码在主函数中调用了1亿次 alloc() 方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure><p>这里设置参数如下：</p></li><li><p>参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</p></li><li><p>参数 -XX:+DoEscapeAnalysis：启用逃逸分析。</p></li><li><p>参数 -Xmx10m：指定了堆空间最大为10MB。</p></li><li><p>参数 -XX:+PrintGC：将打印GC日志。</p></li><li><p>参数-XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。</p></li></ul><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a><strong>逃逸分析的不足</strong></h3><ol><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除，但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上。</li></ol><p><strong>堆是分配对象的唯一选择么？</strong> <strong>（不是！）</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li><li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</li><li>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上。</li><li>如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上。</li><li>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li><li>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</li><li>当GC发生在老年代时则被称为Major GC或者Full GC。</li><li>一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 对象分配过程 </tag>
            
            <tag> TLAB </tag>
            
            <tag> 逃逸分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="2020/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
      <url>2020/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a><strong>虚拟机栈概述</strong></h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。由于不同平台CPU架构不同，所以不能设计为基于寄存器的。 其优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>为什么不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java战（stack）？</p><p>首先栈是运行时的单位，而堆是存储的单位：</p><ul><li><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</p></li><li><p>堆解决的是数据存储的问题，即数据怎么放，放哪里。</p></li></ul><h3 id="Java虚拟机栈是什么"><a href="#Java虚拟机栈是什么" class="headerlink" title="Java虚拟机栈是什么"></a><strong>Java虚拟机栈是什么</strong></h3><ul><li><p>Java虚拟机栈（Java Virtual Machine  Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（StackFrame），对应着一次次的Java方法调用。</p></li><li><p>Java虚拟机栈是线程私有的。</p></li></ul>  <img src="https://img-blog.csdnimg.cn/20210202164634273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" style="zoom:80%;" /><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h3><p>生命周期和线程一致，即线程结束了，该虚拟机栈也销毁了。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><ul><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a><strong>栈的特点</strong></h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p> <strong>注：对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</strong></p><p><strong>开发中遇到哪些异常？</strong></p><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ol><li>如果采用固定大小的Java虚拟机栈，那么每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9656</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a><strong>设置栈内存大小</strong></h3><p>可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><blockquote><p>-Xss1m<br>-Xss1k</p></blockquote><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a><strong>栈的存储单位</strong></h3><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ul><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a><strong>栈中存储什么？</strong></h3><ul><li><p>栈中存储的就是栈帧，栈帧中存储着方法和类的信息。</p></li><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出 “后进先出” 原则。</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current  Class）。</p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210202170041525.png" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFrameTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method02();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method03();;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法3的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法3的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>的开始</span><br><span class="line">方法<span class="number">2</span>的开始</span><br><span class="line">方法<span class="number">3</span>的开始</span><br><span class="line">方法<span class="number">3</span>的结束</span><br><span class="line">方法<span class="number">2</span>的结束</span><br><span class="line">方法<span class="number">1</span>的结束</span><br></pre></td></tr></table></figure><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a><strong>栈运行原理</strong></h3><ul><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧；</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧；</li><li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a><strong>栈帧的内部结构</strong></h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）<br><img src="https://img-blog.csdnimg.cn/20210202174023289.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li><li>并行的每个线程下的栈都是私有的，因此每个线程都有自己各自的虚拟机栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表和操作数栈决定的。<br><img src="https://img-blog.csdnimg.cn/20210202174111754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li></ul><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表（Local Variables）：被称之为局部变量数组或本地变量表。</p><ul><li>局部变量表定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</li><li>局部变量表所需的容量大小是在编译期就确定下来的，并保存在方法的Code属性的maximum local  variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。而对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，函数调用占用的栈空间就会越多，进而导致其嵌套调用次数就会减少。</li><li>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul><h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a><strong>Slot</strong></h3><ul><li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li><li>局部变量表最基本的存储单元是slot（变量槽），局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li><li>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 long和double则占据两个slot。</li><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上。</li><li>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可。</li><li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210216190106201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><p><strong>Slot的重复利用</strong></p><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><img src="https://img-blog.csdnimg.cn/20210216190133216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><p><strong>静态变量与局部变量的对比</strong></p><p>变量的分类：</p><p>按数据类型分：基本数据类型、引用数据类型。</p><p>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量。</p><p>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块。</p><p>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值。</p><p>局部变量：在使用前必须进行显式赋值，不然编译不通过。</p><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li><li>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ul><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p><img src="https://img-blog.csdnimg.cn/20210216171709568.png"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>操作数栈：Operand Stack</p><ul><li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以称之为表达式栈（Expression Stack）;</li><li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）;</li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用它们后再把结果压入栈，比如：执行复制、交换、求和等操作；</li><li>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。<br><img src="https://img-blog.csdnimg.cn/2021021419235896.png"></li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时，该方法的操作数栈是空的；</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack 的值；</li><li>栈中的任何一个元素都可以是任意的Java数据类型；</li><li>在操作数栈中，32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位深度；</li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问；</li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令（该方法执行完成，回到之前方法的字节码指令）；</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</li></ul><p><strong>注：Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</strong></p><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a><strong>代码解释</strong></h3><p>给一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成字节码指令:<br><img src="https://img-blog.csdnimg.cn/20210216170639798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br><strong>byte、short、char、boolean 内部都是使用int型来进行保存的。</strong></p><p>从上面的代码可知，通过bipush对操作数 15 和 8进行入栈操作，同时使用的是 iadd方法进行相加操作，其中 i 代表的就是 int，也就是int类型的加法操作。</p><p>执行流程如下所示：</p><ol><li>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈；<br><img src="https://img-blog.csdnimg.cn/20210216170710558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li><li>执行完后，让PC +1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，可以看到局部变量表的已经增加了一个元素；<br><img src="https://img-blog.csdnimg.cn/20210216170742167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li></ol><p><strong>为什么局部变量表不是从0开始的呢？</strong></p><p>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了。</p><ol start="3"><li>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中；<br><img src="https://img-blog.csdnimg.cn/20210216170802946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20210216170808346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li><li>然后从局部变量表中，依次将数据放在操作数栈中；<br><img src="https://img-blog.csdnimg.cn/20210216170829819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210216170840404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li><li>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置；<br><img src="https://img-blog.csdnimg.cn/20210216170851989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210216170858374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></li><li>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</li></ol><h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a><strong>栈顶缓存技术</strong></h3><ul><li>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instructiondispatch）次数和内存读/写次数；</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot  JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</li></ul><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p><img src="https://img-blog.csdnimg.cn/20210216180441689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><ul><li>动态链接、方法返回地址、附加信息 ：有些地方被称为帧数据区；</li><li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking），比如：invoke指令；</li><li>Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</li></ul><p>比如：一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用（即方法运行所需的的信息存在常量池里面，当方法执行时，需要去常量池里面拿，而拿的方法就是动态链接）。<br><img src="https://img-blog.csdnimg.cn/20210216180656324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br><strong>为什么需要运行时常量池？</strong></p><p>因为不同的方法，都可能调用常量或者方法，因此在常量池里存储一份，可以节省空间， 而常量池的作用：就是为了提供一些符号和常量，便于指令的识别。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p><strong>方法返回地址存放调用该方法的pc寄存器的值。</strong></p><p>一个方法的结束，有两种方式：</p><ul><li>正常执行完成；</li><li>出现未处理的异常，非正常退出。</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址；而通过异常退出的，返回地址要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定；</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul><p>方法执行遇到异常：</p><ul><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是说在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出；</li><li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表中，方便在发生异常的时候找到处理异常的代码；</li><li>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。<br><img src="https://img-blog.csdnimg.cn/20210216181257381.png"><br>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li></ul><h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作数栈 </tag>
            
            <tag> 局部变量表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序计数器</title>
      <link href="2020/11/24/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>2020/11/24/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>程序计数器（Program Counter Register）中的Register的命名源于CPU的寄存器，寄存器存储相关指令的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。<br><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210201183248423.png"></p><ul><li>程序计数器是一块很小的内存空间，几乎可以忽略不记，它也是运行速度最快的存储区域。</li><li>在JVM规范中，每 个线程都有它自己的程序计数器，它是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间的一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者如果是在执行native方法，则是未指定值（undefned）。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。并且字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p><strong>PC寄存器用来存储指向下一条指令的地址，即将要执行的指令代码，并由执行引擎读取下一条指令。</strong></p><p><strong>注</strong>：程序计数器会存储当前线程正在执行的Java方法的JVM指令地址（一个线程有很多指令），这里的指令地址指的是当前下一条指令的地址。</p><p><strong>代码演示</strong></p><ul><li>首先写一个简单的代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后将代码进行编译成字节码文件，再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line"><span class="number">2</span>: istore_1</span><br><span class="line"><span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line"><span class="number">5</span>: istore_2</span><br><span class="line"><span class="number">6</span>: iload_1</span><br><span class="line"><span class="number">7</span>: iload_2</span><br><span class="line"><span class="number">8</span>: iadd</span><br><span class="line"><span class="number">9</span>: istore_3</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>通过PC寄存器，我们就可以知道当前程序执行到哪一步了。<br><img src="https://img-blog.csdnimg.cn/20210201183908737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br>解释：PC寄存器存储的是指令地址，执行引擎读取PC寄存器中的指令地址，拿到其所对应的操作指令，之后执行引擎操作局部变量表以及操作数栈，实现数据的存取加减等操作，同时将字节码翻译成机器指令，并交给CPU进行运行。</li></ul><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong></p><ul><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</li><li>JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</li></ul><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ul><li><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p></li><li><p>而由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令，这样必然导致经常中断或恢复，因此每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p></li></ul><p><strong>CPU时间片</strong></p><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="https://img-blog.csdnimg.cn/2021020119014375.png"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序计数器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区概述</title>
      <link href="2020/11/18/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0/"/>
      <url>2020/11/18/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区概述"><a href="#运行时数据区概述" class="headerlink" title="运行时数据区概述"></a>运行时数据区概述</h2><p>运行时数据区，见下图，它是在类加载完成后的阶段。<br><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210809104947350.png" alt="image-20210809104947350" style="zoom:50%;" /></p><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 ， 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区。<br><img src="https://img-blog.csdnimg.cn/20210126192157244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /><br><strong>内存</strong></p><ul><li>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行，JVM规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。</li><li>而我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁。</li></ul><p><strong>运行时数据区的完整图</strong></p><p><img src="https://img-blog.csdnimg.cn/20210126192305609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p><strong>灰色的为单独线程私有的，红色的为多个线程共享的</strong>。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）。</li></ul><p><strong>线程</strong></p><ul><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot  JVM里，每个线程都与操作系统的本地线程直接映射。</li><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li><li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</li></ul><p><strong>JVM系统线程</strong></p><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[ ]）的main线程以及所有这个main线程自己创建的线程。 这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><p><strong>注意：一个JVM只有一个Runtime的实例。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运行时数据区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="2020/11/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/11/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h2><ul><li><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p></li><li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210809094221203.png" alt="image-20210809094221203" style="zoom:120%;" /><h2 id="Java中类的加载过程"><a href="#Java中类的加载过程" class="headerlink" title="Java中类的加载过程"></a>Java中类的加载过程</h2><p>例如下面的一段简单的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我已经被加载啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它的加载过程是怎么样的呢?</strong><br><img src="https://img-blog.csdnimg.cn/20210119143449441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" alt="" style="zoom:67%;" /><br><strong>完整的流程如下图所示：</strong><br><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210119144225101.png"><br><strong>加载阶段</strong></p><ul><li>通过一个类的全限定名获取定义此类的二进制字节流 </li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为这个类的各种数据的访问入口</li></ul><p><strong>加载class文件的方式</strong></p><ul><li>从本地系统中直接加载 </li><li>通过网络获取，典型场景：Web Applet </li><li>从zip压缩包中读取，成为日后 jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术    </li><li>由其他文件生成，典型场景：JSP应用 从专有数据库中提取.class文件，比较少见 </li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><p><strong>链接阶段</strong></p><p><strong>验证 verify</strong></p><ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</li></ul><p> <strong>通过工具Binary Viewer查看字节码</strong><br><img src="https://img-blog.csdnimg.cn/20210119145156840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br>如果出现不合法的字节码文件，那么将会验证不通过！</p><p><strong>准备 Prepare</strong></p><p>为类变量分配内存并且设置该类变量的默认初始值，即<strong>零值，null</strong>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化。</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul><p><strong>解析 Resolve</strong></p><ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等。</li></ul><p> <strong>初始化阶段</strong></p><ul><li>初始化阶段就是执行类构造器方法的过程。此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来（也就是说，当我们代码中包含static变量的时候，就会有clinit方法）。构造器方法中指令按语句在源文件中出现的顺序执行。</li><li>类构造方法不同于类的构造器。如果没有static变量，则类构造方法（clinit）不会执行，而任何一个类在声明后，都有生成一个构造器，默认是空参构造器。执行类的构造器是执行init方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(number);  <span class="comment">//报错，非法的前向引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(ClassInitTest.number); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于涉及到父类时候的变量赋值过程</strong></p><p>若该类具有父类，JVM会保证子类的执行前，父类的已经执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">putstatic #2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class="line">iconst_2</span><br><span class="line">putstatic #2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>虚拟机必须保证一个类的初始化方法在多线程下被同步加锁。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 线程t1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> DeadThread();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 线程t2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> DeadThread();</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程t1开始</span><br><span class="line">线程t2开始</span><br><span class="line">线程t2 初始化当前类</span><br></pre></td></tr></table></figure><p><strong>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程。</strong></p><h2 id="类加载器的分类及关系"><a href="#类加载器的分类及关系" class="headerlink" title="类加载器的分类及关系"></a>类加载器的分类及关系</h2><ul><li>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined<br>ClassLoader）。</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</li></ul><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210119171634765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"><br><strong>注：JDK1.9之后扩展类加载器ExtClassLoader变成PlatFromClassLoader平台加载器。这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</strong></p><p>我们通过一个类，获取它不同的加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层的:扩展类加载器</span></span><br><span class="line">        ClassLoader classLoaderParent = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(classLoaderParent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取根加载器</span></span><br><span class="line">        ClassLoader loaderParentParent = classLoaderParent.getParent();</span><br><span class="line">        System.out.println(loaderParentParent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取自定义加载器</span></span><br><span class="line">        ClassLoader loader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取String类型的加载器</span></span><br><span class="line">        ClassLoader classLoader = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@2437c6dc</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@58ceff1</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@2437c6dc</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>注：这里的PlatformClassLoader可以看成是ExtClassLoader。</p><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a><strong>虚拟机自带的加载器</strong></h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类。</li><li>它并不继承自 java.lang.ClassLoader，没有父加载器。</li><li>加载扩展类加载器和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类。</li></ul><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java语言编写，JDK1.8由sun.misc.Launcher$ExtClassLoader实现，JDK1.9之后改成PlatFromClassLoader，由jdk.internal.loader.PlatformClassLoader实现。</li><li>派生于ClassLoader类。</li><li>父类加载器为启动类加载器。</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader)</strong></p><ul><li>java语言编写，由sun.misc.LaunchersAppClassLoader实现。</li><li>派生于ClassLoader类。</li><li>父类加载器为扩展类加载器。</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载，通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器。</li></ul><p><strong>用户自定义类加载器</strong></p><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p><strong>用户自定义类加载器实现步骤：</strong></p><ul><li>开发人员可以通过继承抽象类Java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求。</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中。</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><p><strong>ClassLoader类</strong></p><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）。</p><p>获取ClassLoader的途径：</p><ul><li>获取当前ClassLoader：clazz.getClassLoader()</li><li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li><li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li><li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><p><strong>工作原理</strong></p><p>具体原理如下图<br><img src="https://img-blog.csdnimg.cn/20210119185817200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70"></p><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器； </li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><strong>沙箱安全机制</strong></p><p>我们自定义一个String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk中rt.jar包中java\lang\String.class，当执行String类中的main方法时，会报错说没有main方法，就是因为加载的是rt.jar包中的string核心类，该类没有main方法。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><p><strong>双亲委派机制的优势</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改，如自定义类：java.lang.String</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类加载过程 </tag>
            
            <tag> 类加载器 </tag>
            
            <tag> 双亲委派机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基本架构及生命周期</title>
      <link href="2020/11/01/JVM%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"/>
      <url>2020/11/01/JVM%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM基本介绍"><a href="#JVM基本介绍" class="headerlink" title="JVM基本介绍"></a>JVM基本介绍</h2><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p><p>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点</strong>：</p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><h2 id="JVM整体架构"><a href="#JVM整体架构" class="headerlink" title="JVM整体架构"></a>JVM整体架构</h2><ul><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li></ul> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210809091111315.png" alt="image-20210809091111315" style="zoom:50%;" /><p>执行引擎包含三部分：解释器，及时编译器，垃圾回收器。</p><h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210809091428263.png" alt="image-20210809091428263" style="zoom:50%;" /><h2 id="JVM-架构模型"><a href="#JVM-架构模型" class="headerlink" title="JVM 架构模型"></a>JVM 架构模型</h2><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210103210020821.png" alt="在这里插入图片描述" style="zoom: 67%;" /><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p><p>基于栈式架构的特点：</p><ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈，指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台。</li></ul><p>基于寄存器架构的特点：</p><ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，可移植性差。</li><li>性能优秀和执行更高效。</li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主。</li></ul><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p> <strong>栈</strong>：</p><ul><li>跨平台性</li><li>指令集小</li><li>指令多</li><li>执行性能比寄存器差</li></ul><p><strong>程序的编译和运行过程</strong><br><img src="https://img-blog.csdnimg.cn/20210103210515790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjI2OTk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><p><strong>虚拟机的启动</strong></p><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p>  <strong>虚拟机的执行</strong></p><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序；</li><li>程序开始执行时他才运行，程序结束时他就停止；</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li></ul><p><strong>虚拟机的退出</strong></p><ul><li>程序正常执行结束；</li><li>程序在执行过程中遇到了异常或错误而异常终止；</li><li>由于操作系统出现错误而导致Java虚拟机进程终止；</li><li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作；</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM架构 </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
