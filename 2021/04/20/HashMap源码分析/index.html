<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>HashMap1.7与1.8源码的区别 | ZC的学习录</title><meta name="keywords" content="HashMap"><meta name="author" content="zhangc233"><meta name="copyright" content="zhangc233"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介类定义123public class HashMap&lt;K,V&gt;         extends AbstractMap&lt;K,V&gt;          implements Map&lt;K,V&gt;, Cloneable, Serializable  主要简介 数据结构：引入了 红黑树 存储流程 数组元素 &amp; 链表节点的 实现类 HashMap中的数组元素 &amp;a">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap1.7与1.8源码的区别">
<meta property="og:url" content="https://zhangc233.github.io/2021/04/20/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="ZC的学习录">
<meta property="og:description" content="简介类定义123public class HashMap&lt;K,V&gt;         extends AbstractMap&lt;K,V&gt;          implements Map&lt;K,V&gt;, Cloneable, Serializable  主要简介 数据结构：引入了 红黑树 存储流程 数组元素 &amp; 链表节点的 实现类 HashMap中的数组元素 &amp;a">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/hashmap.jpeg">
<meta property="article:published_time" content="2021-04-20T13:00:00.000Z">
<meta property="article:modified_time" content="2021-07-09T05:36:17.284Z">
<meta property="article:author" content="zhangc233">
<meta property="article:tag" content="java">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/hashmap.jpeg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhangc233.github.io/2021/04/20/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fbe67500831b74f989430bb8dbe1e7ca";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: zhangc233","link":"链接: ","source":"来源: ZC的学习录","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-09 13:36:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="/css/card_botui.css" /><link rel="stylesheet" href="/css/iconfont.css" /><style type="text/css">#toggle-sidebar {bottom: 80px}</style><style type="text/css">#toggle-sidebar {left:100px}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont  icon-shouye_huaban1"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont  icon-timeAxis"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont  icon-biaoqian_huaban1"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont  icon-quanbu"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-yinle"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw iconfont  icon-yinle1"></i><span> 音乐</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw iconfont  icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page" href="/FilmAndTV/"><i class="fa-fw iconfont  icon-wodezhuifan"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont  icon-lianjie-tianchong"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont  icon-guanyu1"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/hashmap.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZC的学习录</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont  icon-shouye_huaban1"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont  icon-timeAxis"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont  icon-biaoqian_huaban1"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont  icon-quanbu"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-yinle"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw iconfont  icon-yinle1"></i><span> 音乐</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw iconfont  icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page" href="/FilmAndTV/"><i class="fa-fw iconfont  icon-wodezhuifan"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont  icon-lianjie-tianchong"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont  icon-guanyu1"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HashMap1.7与1.8源码的区别</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-20T13:00:00.000Z" title="发表于 2021-04-20 21:00:00">2021-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-09T05:36:17.284Z" title="更新于 2021-07-09 13:36:17">2021-07-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a><strong>类定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">         <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h3 id="主要简介"><a href="#主要简介" class="headerlink" title="主要简介"></a><strong>主要简介</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-086b58aeee2d00cb.png" alt="img"></p>
<h2 id="数据结构：引入了-红黑树"><a href="#数据结构：引入了-红黑树" class="headerlink" title="数据结构：引入了 红黑树"></a>数据结构：引入了 红黑树</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-98178707855677bc.jpg" alt="img"></p>
<h3 id="存储流程"><a href="#存储流程" class="headerlink" title="存储流程"></a>存储流程</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-441706c5a99e02a3.png" alt="img"></p>
<h3 id="数组元素-amp-链表节点的-实现类"><a href="#数组元素-amp-链表节点的-实现类" class="headerlink" title="数组元素 &amp; 链表节点的 实现类"></a>数组元素 &amp; 链表节点的 实现类</h3><ul>
<li><p><code>HashMap</code>中的数组元素 &amp; 链表节点采用 <code>Node</code>类 实现。</p>
</li>
<li><p>与 <code>JDK 1.7</code> 的对比（<code>Entry</code>类），仅仅只是换了名字。</p>
</li>
<li><p>该类的源码分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * Node  = HashMap的内部类，实现了Map.Entry接口，本质是 = 一个映射(键值对)</span></span><br><span class="line"><span class="comment">  * 实现了getKey()、getValue()、equals(Object o)和hashCode()等方法</span></span><br><span class="line"><span class="comment">  **/</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// 哈希值，HashMap根据该值确定记录的位置</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">// key</span></span><br><span class="line">        V value; <span class="comment">// value</span></span><br><span class="line">        Node&lt;K,V&gt; next;<span class="comment">// 链表下一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;   <span class="comment">// 返回 与 此项 对应的键</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 返回 与 此项 对应的值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * hashCode（） </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * equals（）</span></span><br><span class="line"><span class="comment">        * 作用：判断2个Entry是否相等，必须key和value都相等，才返回true  </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="红黑树节点实现类"><a href="#红黑树节点实现类" class="headerlink" title="红黑树节点实现类"></a>红黑树节点实现类</h3><ul>
<li><p><code>HashMap</code>中的红黑树节点采用 <code>TreeNode</code> 类 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树节点 实现类：继承自LinkedHashMap.Entry&lt;K,V&gt;类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 属性 = 父节点、左子树、右子树、删除辅助节点 + 颜色</span></span><br><span class="line">   TreeNode&lt;K,V&gt; parent;  </span><br><span class="line">   TreeNode&lt;K,V&gt; left;   </span><br><span class="line">   TreeNode&lt;K,V&gt; right;</span><br><span class="line">   TreeNode&lt;K,V&gt; prev;   </span><br><span class="line">   <span class="keyword">boolean</span> red;   </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 构造函数</span></span><br><span class="line">   TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;  </span><br><span class="line">       <span class="keyword">super</span>(hash, key, val, next);  </span><br><span class="line">   &#125;  </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 返回当前节点的根节点  </span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;  </span><br><span class="line">           <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)  </span><br><span class="line">               <span class="keyword">return</span> r;  </span><br><span class="line">           r = p;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="具体方法使用"><a href="#具体方法使用" class="headerlink" title="具体方法使用"></a>具体方法使用</h2><h3 id="主要使用API（方法、函数）"><a href="#主要使用API（方法、函数）" class="headerlink" title="主要使用API（方法、函数）"></a>主要使用API（方法、函数）</h3><blockquote>
<p>与 <code>JDK 1.7</code> 基本相同。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>; <span class="comment">// 获得指定键的值</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;  <span class="comment">// 添加键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;  <span class="comment">// 将指定Map中的键值对 复制到 此Map中</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;  <span class="comment">// 删除该键值对</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">// 判断是否存在该键的键值对；是 则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;  <span class="comment">// 判断是否存在该值的键值对；是 则返回true</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;  <span class="comment">// 单独抽取key序列，将所有key生成一个Set</span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;  <span class="comment">// 单独value序列，将所有value生成一个Collection</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清除哈希表中的所有键值对</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;  <span class="comment">// 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断HashMap是否为空；size == 0时 表示为 空 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><blockquote>
<p>与 <code>JDK 1.7</code> 基本相同</p>
</blockquote>
<p><strong>在具体使用时，主要流程是：</strong></p>
<ol>
<li>声明1个 <code>HashMap</code>的对象；</li>
<li>向 <code>HashMap</code> 添加数据（成对 放入 键 - 值对）；</li>
<li>获取 <code>HashMap</code> 的某个数据；</li>
<li>获取 <code>HashMap</code> 的全部数据：遍历<code>HashMap</code>。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1. 声明1个 HashMap的对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 2. 向HashMap添加数据（成对 放入 键 - 值对）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.put(<span class="string">&quot;Android&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;iOS&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;数据挖掘&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">&quot;产品经理&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 3. 获取 HashMap 的某个数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;key = 产品经理时的值为：&quot;</span> + map.get(<span class="string">&quot;产品经理&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 4. 获取 HashMap 的全部数据：遍历HashMap</span></span><br><span class="line"><span class="comment">        * 核心思想：</span></span><br><span class="line"><span class="comment">        * 步骤1：获得key-value对（Entry） 或 key 或 value的Set集合</span></span><br><span class="line"><span class="comment">        * 步骤2：遍历上述Set集合(使用for循环 、 迭代器（Iterator）均可)</span></span><br><span class="line"><span class="comment">        * 方法共有3种：分别针对 key-value对（Entry） 或 key 或 value</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法1：获得key-value的Set集合 再遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法1&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 获得key-value对（Entry）的Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历Set集合，从而获取key-value</span></span><br><span class="line">        <span class="comment">// 2.1 通过for循环</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entrySet)&#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.2 通过迭代器：先获得key-value对（Entry）的Iterator，再循环遍历</span></span><br><span class="line">        Iterator iter1 = entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter1.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 遍历时，需先获取entry，再分别获取key、value</span></span><br><span class="line">            Map.Entry entry = (Map.Entry) iter1.next();</span><br><span class="line">            System.out.print((String) entry.getKey());</span><br><span class="line">            System.out.println((Integer) entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法2：获得key的Set集合 再遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获得key的Set集合</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历Set集合，从而获取key，再获取value</span></span><br><span class="line">        <span class="comment">// 2.1 通过for循环</span></span><br><span class="line">        <span class="keyword">for</span>(String key : keySet)&#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 通过迭代器：先获得key的Iterator，再循环遍历</span></span><br><span class="line">        Iterator iter2 = keySet.iterator();</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">            key = (String)iter2.next();</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法3：获得value的Set集合 再遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获得value的Set集合</span></span><br><span class="line">        Collection valueSet = map.values();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历Set集合，从而获取value</span></span><br><span class="line">        <span class="comment">// 2.1 获得values 的Iterator</span></span><br><span class="line">        Iterator iter3 = valueSet.iterator();</span><br><span class="line">        <span class="comment">// 2.2 通过遍历，直接获取value</span></span><br><span class="line">        <span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter3.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：对于遍历方式，推荐使用针对 key-value对（Entry）的方式：效率高</span></span><br><span class="line"><span class="comment">// 原因：</span></span><br><span class="line">   <span class="comment">// 1. 对于 遍历keySet 、valueSet，实质上 = 遍历了2次：1 = 转为 iterator 迭代器遍历、2 = 从 HashMap 中取出 key 的 value 操作（通过 key 值 hashCode 和 equals 索引）</span></span><br><span class="line">   <span class="comment">// 2. 对于 遍历 entrySet ，实质 = 遍历了1次 = 获取存储实体Entry（存储了key 和 value ）</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span></span><br><span class="line">Java2</span><br><span class="line">iOS3</span><br><span class="line">数据挖掘<span class="number">4</span></span><br><span class="line">Android1</span><br><span class="line">产品经理<span class="number">5</span></span><br><span class="line">----------</span><br><span class="line">Java2</span><br><span class="line">iOS3</span><br><span class="line">数据挖掘<span class="number">4</span></span><br><span class="line">Android1</span><br><span class="line">产品经理<span class="number">5</span></span><br><span class="line">方法<span class="number">2</span></span><br><span class="line">Java2</span><br><span class="line">iOS3</span><br><span class="line">数据挖掘<span class="number">4</span></span><br><span class="line">Android1</span><br><span class="line">产品经理<span class="number">5</span></span><br><span class="line">----------</span><br><span class="line">Java2</span><br><span class="line">iOS3</span><br><span class="line">数据挖掘<span class="number">4</span></span><br><span class="line">Android1</span><br><span class="line">产品经理<span class="number">5</span></span><br><span class="line">方法<span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="HashMap中的重要参数（变量）"><a href="#HashMap中的重要参数（变量）" class="headerlink" title="HashMap中的重要参数（变量）"></a>HashMap中的重要参数（变量）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 主要参数 同  JDK 1.7 </span></span><br><span class="line"><span class="comment">  * 即：容量、加载因子、扩容阈值（要求、范围均相同）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 1. 容量（capacity）： 必须是2的幂 &amp; &lt;最大容量（2的30次方）</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认容量 = 16 = 1&lt;&lt;4 = 00001中的1向左移4位 = 10000 = 十进制的2^4=16</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 最大容量 =  2的30次方（若传入的容量过大，将被最大值替换）</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2. 加载因子(Load factor)：HashMap在其容量自动增加前可达到多满的一种尺度 </span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 实际加载因子</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 默认加载因子 = 0.75</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3. 扩容阈值（threshold）：当哈希表的大小 ≥ 扩容阈值时，就会扩容哈希表（即扩充HashMap的容量） </span></span><br><span class="line"> <span class="comment">// a. 扩容 = 对哈希表进行resize操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数</span></span><br><span class="line"> <span class="comment">// b. 扩容阈值 = 容量 x 加载因子</span></span><br><span class="line"> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4. 其他</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;  <span class="comment">// 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">// HashMap的大小，即 HashMap中存储的键值对的数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 与红黑树相关的参数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 1. 桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 &gt; 该值时，则将链表转换成红黑树</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line">  <span class="comment">// 2. 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt; 6时，则将 红黑树转换成链表</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 3. 最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）</span></span><br><span class="line">  <span class="comment">// 否则，若桶内元素太多时，则直接扩容，而不是树形化</span></span><br><span class="line">  <span class="comment">// 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h3 id="加载因子"><a href="#加载因子" class="headerlink" title="加载因子"></a><strong>加载因子</strong></h3><blockquote>
<p>同 <code>JDK 1.7</code>，但由于其重要性，故此处再次说明。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-b85819e2f8a3c30a.jpg" alt="img"></p>
<p>总结 数据结构 &amp; 参数方面与 <code>JDK 1.7</code>的区别：</p>
<p><img src="img/944365-67768bc4f0d23d69.png" alt="img"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>本次的源码分析主要是根据 <strong>使用步骤</strong> 进行相关函数的详细分析，主要分析内容如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-43ee4c315b6f82d8.png" alt="img"></p>
<h3 id="源码中数据结构-amp-主要参数"><a href="#源码中数据结构-amp-主要参数" class="headerlink" title="源码中数据结构 &amp; 主要参数"></a>源码中数据结构 &amp; 主要参数</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-38b76323d9e4ceb7.png" alt="img"></p>
<h3 id="步骤1：声明1个-HashMap的对象"><a href="#步骤1：声明1个-HashMap的对象" class="headerlink" title="步骤1：声明1个 HashMap的对象"></a>步骤1：声明1个 HashMap的对象</h3><p>此处主要分析的构造函数类似 <code>JDK 1.7</code>。</p>
<p><strong>源码分析：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数使用原型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析：主要是HashMap的构造函数 = 4个</span></span><br><span class="line"><span class="comment">   * 仅贴出关于HashMap构造函数的源码</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略上节阐述的参数</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数1：默认构造函数（无参）</span></span><br><span class="line"><span class="comment">     * 加载因子 &amp; 容量 = 默认 = 0.75、16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数2：指定“容量大小”的构造函数</span></span><br><span class="line"><span class="comment">     * 加载因子 = 默认 = 0.75 、容量 = 指定大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际上是调用指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line">        <span class="comment">// 只是在传入的加载因子参数 = 默认加载因子</span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数3：指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="comment">     * 加载因子 &amp; 容量 = 自己指定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定初始容量必须非负，否则报错  </span></span><br><span class="line">         <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +  </span><br><span class="line">                                           initialCapacity); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY，哪怕传入的 &gt; 最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充比必须为正  </span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +  </span><br><span class="line">                                           loadFactor);  </span><br><span class="line">        <span class="comment">// 设置 加载因子</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 扩容阈值</span></span><br><span class="line">        <span class="comment">// 注：此处不是真正的阈值，仅仅只是将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂，该阈值后面会重新计算</span></span><br><span class="line">        <span class="comment">// 下面会详细讲解 -&gt;&gt; 分析1</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数4：包含“子Map”的构造函数</span></span><br><span class="line"><span class="comment">     * 即 构造出来的HashMap包含传入Map的映射关系</span></span><br><span class="line"><span class="comment">     * 加载因子 &amp; 容量 = 默认</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置容量大小 &amp; 加载因子 = 默认</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入的子Map中的全部元素逐个添加到HashMap中</span></span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析1：tableSizeFor(initialCapacity)</span></span><br><span class="line"><span class="comment">     * 作用：将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂</span></span><br><span class="line"><span class="comment">     * 与JDK 1.7对比：类似于JDK 1.7 中 inflateTable()里的 roundUpToPowerOf2(toSize)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">     <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：（同<code>JDK 1.7</code>类似）</strong></p>
<ol>
<li>此处仅用于接收初始容量大小（<code>capacity</code>）、加载因子(<code>Load factor</code>)，但仍无真正初始化哈希表，即初始化存储数组<code>table</code>。</li>
<li>此处先给出结论：<strong>真正初始化哈希表（初始化存储数组<code>table</code>）是在第1次添加键值对时，即第1次调用<code>put（）</code>时。下面会详细说明</strong>。</li>
</ol>
<h3 id="步骤2：向HashMap添加数据（成对-放入-键-值对）"><a href="#步骤2：向HashMap添加数据（成对-放入-键-值对）" class="headerlink" title="步骤2：向HashMap添加数据（成对 放入 键 - 值对）"></a>步骤2：向HashMap添加数据（成对 放入 键 - 值对）</h3><p>在该步骤中，与<code>JDK 1.7</code>的差别较大：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-45ec8c640c5e5363.png" alt="img"></p>
<p><strong>添加数据的流程如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-2914343d292dc7e0.png" alt="img"></p>
<p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数使用原型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  map.put(<span class="string">&quot;Android&quot;</span>, <span class="number">1</span>);</span><br><span class="line">       map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">       map.put(<span class="string">&quot;iOS&quot;</span>, <span class="number">3</span>);</span><br><span class="line">       map.put(<span class="string">&quot;数据挖掘&quot;</span>, <span class="number">4</span>);</span><br><span class="line">       map.put(<span class="string">&quot;产品经理&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 源码分析：主要分析HashMap的put函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 1. 对传入数组的键Key计算Hash值 -&gt;&gt;分析1</span></span><br><span class="line">       <span class="comment">// 2. 再调用putVal（）添加数据进去 -&gt;&gt;分析2</span></span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="分析1：hash（key）"><a href="#分析1：hash（key）" class="headerlink" title="分析1：hash（key）"></a><strong>分析1：hash（key）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：hash(key)</span></span><br><span class="line"><span class="comment">  * 作用：计算传入数据的哈希码（哈希值、Hash值）</span></span><br><span class="line"><span class="comment">  * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</span></span><br><span class="line"><span class="comment">  * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算</span></span><br><span class="line"><span class="comment">  * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">     h ^= k.hashCode(); </span><br><span class="line">     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span></span><br><span class="line">   <span class="comment">// 1. 取hashCode值： h = key.hashCode() </span></span><br><span class="line">   <span class="comment">// 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">         <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">         <span class="comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span></span><br><span class="line">         <span class="comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span></span><br><span class="line">         <span class="comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 计算存储位置的函数分析：indexFor(hash, table.length)</span></span><br><span class="line"><span class="comment">  * 注：该函数仅存在于JDK 1.7 ，JDK 1.8中实际上无该函数（直接用1条语句判断写出），但原理相同</span></span><br><span class="line"><span class="comment">  * 为了方便讲解，故提前到此讲解</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); </span><br><span class="line">       <span class="comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算存放在数组 table 中的位置（即数组下标、索引）的过程：</strong></p>
<ol>
<li>此处与 <code>JDK 1.7</code>的区别在于：<code>hash</code>值的求解过程中哈希码的二次处理方式（扰动处理）。</li>
<li>步骤1、2 = <code>hash</code>值的求解过程。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-4eec328e8dd3d7e7.png" alt="img"></p>
<p><strong>计算示意图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-1f13afa0cd516356.png" alt="img"></p>
<p>在了解如何计算存放数组<code>table</code> 中的位置 后，所谓 <strong>知其然而需知其所以然</strong>，下面讲解为什么要这样计算，即主要解答以下3个问题：</p>
<ol>
<li>为什么不直接采用经过<code>hashCode（）</code>处理的哈希码作为存储数组<code>table</code>的下标位置？</li>
<li>为什么采用 哈希码 <strong>与运算(&amp;)</strong> （数组长度-1） 计算数组下标？</li>
<li>为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？</li>
</ol>
<blockquote>
<p>在回答这3个问题前，请大家记住一个核心思想：<strong>所有处理的根本目的，都是为了提高存储<code>key-value</code>的数组下标位置的随机性 &amp; 分布均匀性，尽量避免出现hash值冲突</strong>。即：对于不同<code>key</code>，存储的数组下标位置要尽可能不一样。</p>
</blockquote>
<ol>
<li><p><strong>为什么不直接采用经过hashCode（）处理的哈希码作为存储数组table的下标位置？</strong></p>
<p>结论：容易出现哈希码与数组大小范围不匹配的情况，即计算出来的哈希码可能不在数组大小范围内，从而导致无法匹配存储位置。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-d18ee0697a1a1b53.png" alt="img"></p>
<p>为了解决 “哈希码与数组大小范围不匹配” 的问题，<code>HashMap</code>给出了解决方案：<strong>哈希码与运算（&amp;） （数组长度-1）</strong>，即问题3。</p>
<ol start="2">
<li><p><strong>为什么采用哈希码与运算(&amp;) （数组长度-1） 计算数组下标？</strong></p>
<p>结论：根据HashMap的容量大小（数组长度），按需取哈希码一定数量的低位作为存储的数组下标位置，从而 解决“哈希码与数组大小范围不匹配”的问题。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-04658793bae1ed90.png" alt="img"></p>
<ol start="3">
<li><p><strong>为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？</strong></p>
<p>结论：加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性 &amp; 均匀性，最终减少Hash冲突。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-20d396364b968713.png" alt="img"></p>
<h4 id="分析2：putVal-hash-key-key-value-false-true"><a href="#分析2：putVal-hash-key-key-value-false-true" class="headerlink" title="分析2：putVal(hash(key), key, value, false, true)"></a><strong>分析2：putVal(hash(key), key, value, false, true)</strong></h4><ul>
<li>计算完存储位置后，具体该如何存放数据到哈希表中。</li>
<li>具体如何扩容，即 <strong>扩容机制</strong>。</li>
</ul>
<p>由于数据结构中加入了红黑树，所以在存放数据到哈希表中时，需进行多次数据结构的判断：<strong>数组、红黑树、链表</strong>。</p>
<blockquote>
<p>与 <code>JDK 1.7</code>的区别： <code>JDK 1.7</code>只需判断 数组 &amp; 链表。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-53b07522b343ebe9.png" alt="img"></p>
<p><strong>源码分析：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析2：putVal(hash(key), key, value, false, true)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//onlyIfAbsent：插入的值是否存在，存在就不插了。</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 若哈希表的数组tab为空，则 通过resize() 创建</span></span><br><span class="line">        <span class="comment">// 所以，初始化哈希表的时机 = 第1次调用put函数时，即调用resize() 初始化创建</span></span><br><span class="line">        <span class="comment">// 关于resize（）的源码分析将在下面讲解扩容时详细分析，此处先跳过</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算插入存储的数组索引i：根据键值key计算的hash值 得到</span></span><br><span class="line">        <span class="comment">// 此处的数组下标计算方式 = i = (n - 1) &amp; hash，同JDK 1.7中的indexFor（），上面已详细描述</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 插入时，需判断是否存在Hash冲突：</span></span><br><span class="line">        <span class="comment">// 若不存在（即当前table[i] == null），则直接在该数组位置新建节点，插入完毕</span></span><br><span class="line">        <span class="comment">// 否则，代表存在Hash冲突，即当前存储位置已存在节点，则依次往下判断：a. 当前位置的key是否与需插入的key相同、b. 判断需插入的数据结构是否为红黑树 or 链表</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);  <span class="comment">// newNode(hash, key, value, null)的源码 = new Node&lt;&gt;(hash, key, value, next)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. 判断 table[i]的元素的key是否与 需插入的key一样，若相同则 直接用新value 覆盖 旧value</span></span><br><span class="line">        <span class="comment">// 判断原则：equals（）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. 继续判断：需插入的数据结构是否为红黑树 or 链表</span></span><br><span class="line">        <span class="comment">// 若是红黑树，则直接在树中插入 or 更新键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); -&gt;&gt;分析<span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若是链表,则在链表中插入 or 更新键值对</span></span><br><span class="line">        <span class="comment">// i.  遍历table[i]，判断Key是否已存在：采用equals（） 对比当前遍历节点的key 与 需插入数据的key：若已存在，则直接用新value 覆盖 旧value</span></span><br><span class="line">        <span class="comment">// ii. 遍历完毕后仍无发现上述情况，则直接在链表尾部插入数据</span></span><br><span class="line">        <span class="comment">// 注：新增节点后，需判断链表长度是否&gt;8（8 = 桶的树化阈值）：若是，则把链表转换为红黑树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 对于ii：若数组的下1个位置，表示已到表尾也没有找到key值相同节点，则新建节点 = 插入节点</span></span><br><span class="line">                <span class="comment">// 注：此处是从链表尾插入，与JDK 1.7不同（从链表头插入，即永远都是添加到数组的位置，原来数组位置的数据则往后移）</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 插入节点后，若链表节点&gt;树阈值，则将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 树化操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于i</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新p指向下一个节点，继续遍历</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对i情况的后续操作：发现key已存在，直接用新value 覆盖 旧value &amp; 返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">// 替换旧值时会调用的方法（默认实现为空）</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount; <span class="comment">//表示散列表结构被修改的次数，替换Node元素的value不计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入成功后，判断实际存在的键值对数量size &gt; 最大容量threshold</span></span><br><span class="line">    <span class="comment">// 若 &gt; ，则进行扩容 -&gt;&gt;分析4（但单独讲解，请直接跳出该代码块）</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"></span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 插入成功时会调用的方法（默认实现为空）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析3：putTreeVal(this, tab, hash, key, value)</span></span><br><span class="line"><span class="comment">     * 作用：向红黑树插入 or 更新数据（键值对）</span></span><br><span class="line"><span class="comment">     * 过程：遍历红黑树判断该节点的key是否与需插入的key 相同：</span></span><br><span class="line"><span class="comment">     *      a. 若相同，则新value覆盖旧value</span></span><br><span class="line"><span class="comment">     *      b. 若不相同，则插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>put流程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-4f700e47dda01f7f.png" alt="img"></p>
<h3 id="扩容机制（即-resize（）函数方法）"><a href="#扩容机制（即-resize（）函数方法）" class="headerlink" title="扩容机制（即 resize（）函数方法）"></a><strong>扩容机制（即 resize（）函数方法）</strong></h3><p><strong>扩容流程如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-9fb3fec07a0764ec.png" alt="img"></p>
<p><strong>源码分析：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//为什么需要扩容？ 元素太多就会导致查询效率由O(1)-&gt;O(n) 扩容后使得元素更加分散，查询效率更高</span></span><br><span class="line">   <span class="comment">//为了解决哈希冲突导致的链化影响查询效率的问题，扩容会缓解该问题</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析4：resize（）</span></span><br><span class="line"><span class="comment">     * 该函数有2种使用情况：1.初始化哈希表 2.当前数组容量过小，需扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   final Node&lt;K,V&gt;[] <span class="function"><span class="title">resize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 扩容前的数组（当前数组）</span></span><br><span class="line">    int oldCap = (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 扩容前的数组的容量 = 长度</span></span><br><span class="line">    int oldThr = threshold;<span class="comment">// 扩容前的数组的阈值</span></span><br><span class="line">    int newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对情况2：若扩容前的数组容量超过最大值，则不再扩充</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 针对情况2：若无超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 通过右移扩充2倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对情况1：初始化哈希表（采用指定 or 默认值）</span></span><br><span class="line">    <span class="comment">/*oldCap == 0 ，说明hashMap中的散列表是null</span></span><br><span class="line"><span class="comment">	*	1. new HashMap(initCap,loadFactor);</span></span><br><span class="line"><span class="comment">    *   2. new HashMap(intiCap);</span></span><br><span class="line"><span class="comment">    *   3. new HashMap(map);并且这个map有数据	 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">&quot;rawtypes&quot;</span>,<span class="string">&quot;unchecked&quot;</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">				<span class="comment">//第三种情况：桶位已经形成链表</span></span><br><span class="line">					    </span><br><span class="line">				<span class="comment">//低位链表：存放扩容之前的数组下标位置，与当期位置的下标位置一致</span></span><br><span class="line">                <span class="comment">//高位链表：存放扩容之后的数组下标位置为 当前数组下标位置 + 扩容之后数组的长度</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩容流程（含 与 <code>JDK 1.7</code> 的对比）：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-a31e51b24f135d7c.png" alt="img"></p>
<blockquote>
<p>这里主要是<code>JDK 1.8</code>扩容时，数据存储位置重新计算的方式。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708221831834.png" alt="image-20210708221831834"></p>
<p><strong>结论示意图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-2466f5db47fd7685.png" alt="img"></p>
<p><strong>数组位置转换的示意图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708214220642.png" alt="image-20210708214220642"></p>
<blockquote>
<p><code>JDK 1.8</code>根据此结论作出的新元素存储位置计算规则非常简单，提高了扩容效率，具体如下图。</p>
<p>这与 <code>JDK 1.7</code>在计算新元素的存储位置有很大区别：<code>JDK 1.7</code>在扩容后，都需按照原来方法重新计算，即<br> <code>hashCode（）</code>-&gt;&gt; 扰动处理 -&gt;&gt;<code>（h &amp; length-1）</code>）。</p>
</blockquote>
<p><strong>与 <code>JDK 1.7</code>的区别：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-e706a4817a35b021.png" alt="img"></p>
<h3 id="步骤3：从HashMap中获取数据"><a href="#步骤3：从HashMap中获取数据" class="headerlink" title="步骤3：从HashMap中获取数据"></a>步骤3：从HashMap中获取数据</h3><ul>
<li><p>假如理解了上述<code>put（）</code>函数的原理，那么<code>get（）</code>函数非常好理解，因为二者的过程原理几乎相同。</p>
</li>
<li><p><code>get（）</code>函数的流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-a02a9b827efebe30.png" alt="img"></p>
</li>
<li><p><strong>源码分析：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 函数原型</span></span><br><span class="line"><span class="comment">   * 作用：根据键key，向HashMap获取对应的值</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   map.get(key)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1. 计算需获取数据的hash值</span></span><br><span class="line">    <span class="comment">// 2. 通过getNode（）获取所查询的数据 -&gt;&gt;分析1</span></span><br><span class="line">    <span class="comment">// 3. 获取后，判断数据是否为空</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1：getNode(hash(key), key))</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 计算存放在数组table中的位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 通过该函数，依次在数组、红黑树、链表中查找（通过equals（）判断）</span></span><br><span class="line">        <span class="comment">// a. 先在数组中找，若存在，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. 若数组中没有，则到红黑树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// c. 若红黑树中也没有，则通过遍历，到链表中寻找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="步骤4：对HashMap的其他操作"><a href="#步骤4：对HashMap的其他操作" class="headerlink" title="步骤4：对HashMap的其他操作"></a>步骤4：对HashMap的其他操作</h3><p><code>HashMap</code>除了核心的<code>put（）</code>、<code>get（）</code>函数，还有以下主要使用的函数方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清除哈希表中的所有键值对</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;  <span class="comment">// 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断HashMap是否为空；size == 0时 表示为 空 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;  <span class="comment">// 将指定Map中的键值对 复制到 此Map中</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;  <span class="comment">// 删除该键值对</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">// 判断是否存在该键的键值对；是 则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;  <span class="comment">// 判断是否存在该值的键值对；是 则返回true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关于上述方法的源码的原理 同 <code>JDK 1.7</code>，此处不作过多描述。</li>
<li>总结内容 = 数据结构、主要参数、添加 &amp; 查询数据流程、扩容机制.</li>
</ul>
<h4 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a>removeNode()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//tab：引用当前hashMap的散列表</span></span><br><span class="line">		<span class="comment">//p：当前node元素（桶位中头元素）</span></span><br><span class="line">		<span class="comment">//n：表示散列表数组长度</span></span><br><span class="line">		<span class="comment">//index:表示寻址结果</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//说明路由的桶位是有数据的，需要进行查找操作，并且删除</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				</span><br><span class="line">			<span class="comment">//node：查找到的结果</span></span><br><span class="line">			<span class="comment">//e：当前Node的下一个元素</span></span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//第一种情况：当前桶位中的元素 即为要删除的元素</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">				</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//说明当前桶位不止一个元素，可能是链表，可能是红黑树</span></span><br><span class="line">				</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) 判断当前桶位是否升级为红黑树</span><br><span class="line">				    <span class="comment">//第二种情况：红黑树查找操作</span></span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">					</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//第三种情况：链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">						<span class="comment">//循环链表 查找node节点</span></span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;  <span class="comment">//保证e一直往下查找</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);一直向下找</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//删除数据</span></span><br><span class="line">			<span class="comment">//判断node不为空的话，说明按照key查找到需要删除的数据了</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//第一种情况：node是树节点，说明需要进行树节点移除操作				</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//第二种情况：桶位元素即为查找结果，则将该元素的下一个元素放到桶位中</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//第三种情况：将当前元素p的下一个元素 设置成 要删除的下一个元素</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">依次将数组中的元素重置为<span class="keyword">null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="额外补充：关于HashMap的其他问题"><a href="#额外补充：关于HashMap的其他问题" class="headerlink" title="额外补充：关于HashMap的其他问题"></a>额外补充：关于HashMap的其他问题</h2><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708221739910.png" alt="image-20210708221739910" style="zoom: 67%;" />

<h3 id="哈希表如何解决Hash冲突"><a href="#哈希表如何解决Hash冲突" class="headerlink" title="哈希表如何解决Hash冲突?"></a>哈希表如何解决Hash冲突?</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708221806238.png" alt="image-20210708221806238"></p>
<h3 id="为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？"><a href="#为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？" class="headerlink" title="为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？"></a>为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-ce5aa2227f269410.jpg" alt="img"></p>
<p> <code>HashMap</code> 线程不安全的其中一个重要原因：多线程下容易出现<code>resize（）</code>死循环。 <strong>本质 = 并发 执行 <code>put（）</code>操作导致触发 扩容行为，从而导致 环形链表，使得在获取数据遍历链表时形成死循环，即<code>Infinite Loop</code></strong></p>
<p><strong>先看扩容的源码分析<code>resize（）：</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析：resize(2 * table.length)</span></span><br><span class="line"><span class="comment">   * 作用：当容量不足时（容量 &gt; 阈值），则扩容（扩到2倍）</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 保存旧数组（old table） </span></span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保存旧容量（old capacity ），即数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 根据新容量（2倍容量）新建1个数组，即新table  </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. （重点分析）将旧数组上的数据（键值对）转移到新table中，从而完成扩容 -&gt;&gt;分析1.1 </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 新数组table引用到HashMap的table属性上</span></span><br><span class="line">    table = newTable;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 重新设置阈值  </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1.1：transfer(newTable); </span></span><br><span class="line"><span class="comment">   * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span></span><br><span class="line"><span class="comment">   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1. src引用了旧数组</span></span><br><span class="line">      Entry[] src = table; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 获取新数组的大小 = 获取新容量大小                 </span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">          <span class="comment">// 3.1 取得旧数组的每个元素  </span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 3.2 释放旧数组的对象引用（for循环后，旧数组不再引用任何对象）</span></span><br><span class="line">              src[j] = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">              <span class="keyword">do</span> &#123; </span><br><span class="line">                  <span class="comment">// 3.3 遍历 以该数组元素为首 的链表</span></span><br><span class="line">                  <span class="comment">// 注：转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开</span></span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next; </span><br><span class="line">                 <span class="comment">// 3.3 重新计算每个元素的存储位置</span></span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 <span class="comment">// 3.4 将元素放在数组上：采用单链表的头插入方式 = 在链表头上存放数据 = 将数组位置的原有数据放在后1个指针、将需放入的数据放到数组位置中</span></span><br><span class="line">                 <span class="comment">// 即 扩容后，可能出现逆序：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line">                 e.next = newTable[i]; </span><br><span class="line">                 newTable[i] = e;  </span><br><span class="line">                 <span class="comment">// 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点</span></span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">             <span class="comment">// 如此不断循环，直到遍历完数组上的所有数据元素</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从上面可看出：在扩容<code>resize（）</code>过程中，在将旧数组上的数据 转移到 新数组上时，<strong>转移数据操作 = 按旧链表的正序遍历链表、在新链表的头部依次插入</strong>，即在转移数据、扩容后，容易出现<strong>链表逆序的情况</strong>。</p>
<blockquote>
<p>设重新计算存储位置后不变，即扩容前 = 1-&gt;2-&gt;3，扩容后 = 3-&gt;2-&gt;1</p>
</blockquote>
<p>此时若（多线程）并发执行 <code>put（）</code>操作，一旦出现扩容情况，则 <strong>容易出现 环形链表</strong>，从而在获取数据、遍历链表时 形成死循环（<code>Infinite Loop</code>），即 死锁的状态，具体请看下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-8748867d2085b481.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-4989e9b5e1b3ef6d.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708221933718.png" alt="image-20210708221933718"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708222003422.png" alt="image-20210708222003422"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210708222037780.png" alt="image-20210708222037780"></p>
<p>由于 <code>JDK 1.8</code> 转移数据操作 = <strong>按旧链表的正序遍历链表、在新链表的尾部依次插入</strong>，所以不会出现链表 <strong>逆序、倒置</strong>的情况，故不容易出现环形链表的情况。</p>
<h3 id="为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键？"><a href="#为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键？" class="headerlink" title="为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键？"></a>为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键？</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-318b6e178419065b.png" alt="img"></p>
<h3 id="HashMap-中的-key若-Object类型，-则需实现哪些方法？"><a href="#HashMap-中的-key若-Object类型，-则需实现哪些方法？" class="headerlink" title="HashMap 中的 key若 Object类型， 则需实现哪些方法？"></a>HashMap 中的 <code>key</code>若 <code>Object</code>类型， 则需实现哪些方法？</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/944365-23536584ac590783.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhangc233</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhangc233.github.io/2021/04/20/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://zhangc233.github.io/2021/04/20/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhangc233.github.io" target="_blank">ZC的学习录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/HashMap/">HashMap</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/hashmap.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/20/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/collection.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ArrayList源码分析</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/20/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/LinkedList.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LinkedList源码分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/02/09/Java常见数据结构以及特点、使用场景/" title="java常见数据结构以及特点"><img class="cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/java2.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-09</div><div class="title">java常见数据结构以及特点</div></div></a></div><div><a href="/2021/04/20/LinkedList源码分析/" title="LinkedList源码分析"><img class="cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/LinkedList.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-20</div><div class="title">LinkedList源码分析</div></div></a></div><div><a href="/2021/04/20/ArrayList源码分析/" title="ArrayList源码分析"><img class="cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/collection.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-20</div><div class="title">ArrayList源码分析</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">类定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">主要简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BC%95%E5%85%A5%E4%BA%86-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">数据结构：引入了 红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">存储流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0-amp-%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">数组元素 &amp; 链表节点的 实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">红黑树节点实现类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">具体方法使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8API%EF%BC%88%E6%96%B9%E6%B3%95%E3%80%81%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">主要使用API（方法、函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">使用流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0%EF%BC%88%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">HashMap中的重要参数（变量）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90"><span class="toc-number">4.1.</span> <span class="toc-text">加载因子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-amp-%E4%B8%BB%E8%A6%81%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">源码中数据结构 &amp; 主要参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E5%A3%B0%E6%98%8E1%E4%B8%AA-HashMap%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">步骤1：声明1个 HashMap的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E5%90%91HashMap%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%EF%BC%88%E6%88%90%E5%AF%B9-%E6%94%BE%E5%85%A5-%E9%94%AE-%E5%80%BC%E5%AF%B9%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">步骤2：向HashMap添加数据（成对 放入 键 - 值对）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%901%EF%BC%9Ahash%EF%BC%88key%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">分析1：hash（key）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%902%EF%BC%9AputVal-hash-key-key-value-false-true"><span class="toc-number">5.3.2.</span> <span class="toc-text">分析2：putVal(hash(key), key, value, false, true)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%88%E5%8D%B3-resize%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">扩容机制（即 resize（）函数方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43%EF%BC%9A%E4%BB%8EHashMap%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">5.5.</span> <span class="toc-text">步骤3：从HashMap中获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A44%EF%BC%9A%E5%AF%B9HashMap%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">5.6.</span> <span class="toc-text">步骤4：对HashMap的其他操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#removeNode"><span class="toc-number">5.6.1.</span> <span class="toc-text">removeNode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clear"><span class="toc-number">5.6.2.</span> <span class="toc-text">clear()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85%EF%BC%9A%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">额外补充：关于HashMap的其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81"><span class="toc-number">6.1.</span> <span class="toc-text">哈希表如何解决Hash冲突?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E5%85%B7%E5%A4%87%E4%B8%8B%E8%BF%B0%E7%89%B9%E7%82%B9%EF%BC%9A%E9%94%AE-%E5%80%BC%EF%BC%88key-value%EF%BC%89%E9%83%BD%E5%85%81%E8%AE%B8%E4%B8%BA%E7%A9%BA%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E3%80%81%E4%B8%8D%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E3%80%81%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E9%9A%8F%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-HashMap-%E4%B8%AD-String%E3%80%81Integer-%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA-key-%E9%94%AE%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E4%B8%AD%E7%9A%84-key%E8%8B%A5-Object%E7%B1%BB%E5%9E%8B%EF%BC%8C-%E5%88%99%E9%9C%80%E5%AE%9E%E7%8E%B0%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">HashMap 中的 key若 Object类型， 则需实现哪些方法？</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 <i style="color:#FF6A6A;animation: announ_animation 0.8s linear infinite;" class="fa fa-heartbeat"></i> zhangc233</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    let initData = {
      el: '#twikoo-wrap',
      envId: 'zc-cloudbase-7gbysfm74e2b2c22',
      region: ''
    }

    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    twikoo.init(initData)
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'zc-cloudbase-7gbysfm74e2b2c22',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/sakura.js"></script><script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/title.js"></script><script src="/js/botui.js"></script><script data-pjax src="/js/botui_init.js"></script><script async src="/js/back.js"></script><script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=5V2tOKp8qAdRM-i8eu7ETTO9ugt5uKbbG-U7Yj8uMl8"></script><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script src="/js/chatra.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(d, w, c) {
    w.ChatraID = 'bJrdHqZM78fLH3i3H';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>